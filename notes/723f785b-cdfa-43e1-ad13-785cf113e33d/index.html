<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><title>Memory</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Memory"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://notes.tczhong.com/notes/723f785b-cdfa-43e1-ad13-785cf113e33d/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="4/6/2021"/><meta property="article:modified_time" content="5/4/2021"/><link rel="canonical" href="https://notes.tczhong.com/notes/723f785b-cdfa-43e1-ad13-785cf113e33d/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/35c8e98bba5d4075.css" as="style"/><link rel="stylesheet" href="/_next/static/css/35c8e98bba5d4075.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-378e68e29c265886.js" defer=""></script><script src="/_next/static/chunks/framework-dc33c0b5493501f0.js" defer=""></script><script src="/_next/static/chunks/main-a7fe8c0ea9a0f989.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fdb9297d37c44607.js" defer=""></script><script src="/_next/static/chunks/155-4c900bf5c5278e05.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-ebe33fbe56ae1215.js" defer=""></script><script src="/_next/static/FWMOU7HnIEvYhYu7_V-Vm/_buildManifest.js" defer=""></script><script src="/_next/static/FWMOU7HnIEvYhYu7_V-Vm/_ssgManifest.js" defer=""></script><script src="/_next/static/FWMOU7HnIEvYhYu7_V-Vm/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div class="ant-col"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"></div><div style="margin-left:4px;display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout site-layout" style="margin-top:64px"><section class="ant-layout site-layout" style="flex-direction:row"><section class="ant-layout site-layout-sidebar" style="flex:0 0 auto;width:calc((100% - 992px) / 2 + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></section><section class="ant-layout side-layout-main" style="max-width:960px;display:initial"><main class="ant-layout-content main-content" role="main" style="padding:0 24px"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-20"><div><h1 id="memory"><a aria-hidden="true" class="anchor-heading" href="#memory"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Memory</h1>
<p><a href="https://gywbd.github.io/posts/2016/1/segmentation-fault.html">reference</a></p>
<h1 id="phycical-memory"><a aria-hidden="true" class="anchor-heading" href="#phycical-memory"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>phycical memory</h1>
<p>stack（栈）是一块用于保存函数调用信息——传递的参数、每个函数的本地变量的内存区域</p>
<p>heap（堆）是一块程序可以任意使用的内存区域，程序员有完全自由的权限对这个区域进行任何想要的操作</p>
<p>stack部分的大小在程序运行过程中是可变的。当函数调用发生时，stack就会扩大，当函数调用结束时：之前扩大的stack就会缩小为调用之前的样子
heap同样也是一个大小可变的区域，当程序员从heap中请求内存（malloc()）时，heap就会扩大，当这些内存被释放后（free()），heap就会缩小。
stack和heap都是可伸缩的区域，它们处于整个地址空间中的相对位置：stack会向下扩展（由高地址到低地址），而heap则会向上扩展（由低地址到高地址）。它们都是可以自由增长的区域，只是增长的方向刚好相反。操作系统只需要检查这两个区域不会出现重叠的情况，这是它们主要的使用限制。</p>
<p><img src="/assets/images/2021-04-05-23-02-01.png"></p>
<h1 id="virtaul-memory"><a aria-hidden="true" class="anchor-heading" href="#virtaul-memory"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>virtaul memory</h1>
<p>The virtual memory abstracts the details of physical memory from the application software, allows to keep only needed information in the physical memory (demand paging) and provides a mechanism for the protection and controlled sharing of data between processes.</p>
<p>虚拟内存提供三个重要的能力，第一个把主存看作一个存储在磁盘上地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式高效的使用的主存，第二点，他为每个进程提供了一致的地址空间，从而简化了内存管理，第三它保护了每个进程地址空间，不被其他进程破坏。</p>
<p>虚拟内存其实是在磁盘上，需要用的时候放到主存里。每个虚拟地址指向一个PTE, 包含有效位以及物理页号或者磁盘地址。缓存不命中是缺页，调用缺页异常处理程序，选择一个页面换成需要的页面。之后重新启动缺页异常的指令。重新地址翻译。可以利用TLB加速地址翻译或者使用多级页表。</p>
<h2 id="缓存的工具"><a aria-hidden="true" class="anchor-heading" href="#缓存的工具"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>缓存的工具</h2>
<p>每个字节有唯一的虚拟地址。</p>
<p>virutal page有三种类型</p>
<ul>
<li>未分配的：VM系统中未分配的页，不占任何磁盘空间</li>
<li>缓存的：当前已缓存的在物理内存中的已分配页</li>
<li>未缓存的：未缓存在物理内存中的已分配页</li>
</ul>
<p><img src="/assets/images/2021-05-03-19-20-38.png"></p>
<p>DRAM 比 SRAM(L1,L2,L3)慢10倍，虚拟页比较大。, DRAM caches always use write-back instead of write-through.</p>
<p>In write through, data is simultaneously updated to cache and memory.
write back: The data is updated only in the cache and updated into the memory in later time. </p>
<p>通过mmu, 页表(page table)判断一个虚拟页是否缓存在DRAM中的某一个地方，mmu把VP->PP</p>
<p>PTE(page table entry) 有效位表明当前VP是否缓存在DRAM</p>
<p><img src="/assets/images/2021-05-03-19-25-39.png"></p>
<p>页命中：如果有效，可以获得物理地址</p>
<p>缺页：page fault，调用内核缺页处理程序。程序选择一个牺牲页，修改DRAM，把磁盘里的VP复制到DRAM，重新启动缺页的指令，把导致缺页的虚拟地址重新发到MMU，命中。</p>
<p>The activity of transferring a page between disk and memorf is known as swapping or paging. Pages are swapped in (paged in) from disk to DRAM, anct swapped out (paged out) from DRAM to disk</p>
<h3 id="swap"><a aria-hidden="true" class="anchor-heading" href="#swap"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>swap</h3>
<ul>
<li>
<p>What is swap, when will it be used?
Swap space is located on hard drives for inactive pages in memory
Swapping is the process whereby a page of memory is copied to the preconfigured space on the hard disk,
called swap space, to free up that page of memory.</p>
</li>
<li>
<p>What's the situation that a process will swap
Swap space in Linux is used when the amount of physical memory (RAM) is full.
If the system needs more memory resources and the RAM is full,
inactive pages in memory are moved to the swap space.</p>
</li>
<li>
<p>What's the down side of swap?
Swap space is located on hard drives, which have a slower access time than physical memory.
</p>
</li>
</ul>
<h2 id="内存管理"><a aria-hidden="true" class="anchor-heading" href="#内存管理"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>内存管理</h2>
<p>不同进程里的VP可以共享一个PP。简化linking，loading，share，内存分配</p>
<p>两个进程将私有对象映射到它们的虚拟内存的不同区域，但是共享这个对象，统一个物理副本，对于每个应设是有对象的进程，相应的所有区域的业表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要没有进程，试图修改他们自己的私有区域，他们就可以继续共享物理内存对象的一个单独副本，但是只要有一个进程，试图写私有区域内的某个页面，他就会复制一个新的，在那个里面写。</p>
<h2 id="内存保护"><a aria-hidden="true" class="anchor-heading" href="#内存保护"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>内存保护</h2>
<p>在page table有许可位，判定这个page的访问权限。</p>
<h2 id="地址翻译-mmu"><a aria-hidden="true" class="anchor-heading" href="#地址翻译-mmu"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>地址翻译 mmu</h2>
<p>MMU memory management unit.
The mapping between virtual address and physical address.</p>
<p><img src="/assets/images/2021-04-05-22-38-37.png"></p>
<p>当一个用户级进程想访问一些内存，它会产生一个访问请求，MMU会把请求的虚拟地址转换为对应的物理内存地址。但是如果这个地址访问存在错误：转换后的物理地址超出了物理段的界限，或者违反了段保护权限（例如请求向只读段中写入数据），此时默认情况下操作系统会产生一个表示需要进行错误处理的信号：SIGSEGV，对这个信号的默认处理行为（default handler）是杀死（kill）这个进程，并且输出一个消息：“Segmentation fault”。</p>
<p><img src="/assets/images/2021-05-03-19-35-51.png"></p>
<h2 id="tlb"><a aria-hidden="true" class="anchor-heading" href="#tlb"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>TLB</h2>
<p>快速重编址缓冲器（Translation-lookaside Buffer : TLB）</p>
<p>在每次虚拟内存访问时都会使用MMU，它会先从地址中提取出VPN，然后根据这个VPN查找TLB中是否有对应的VPN。如果命中（hit），它会直接返回TLB中记录的对应的物理地址，完成它的使命。如果没有命中（miss），那么它会查找进程的页表，如果对这个物理地址的访问是合法的，那么它会更新TLB，那么之后再访问这个虚拟地址，就会命中了。</p>
<p><img src="/assets/images/2021-05-03-19-36-10.png"></p>
<h2 id="multi-level-page-table"><a aria-hidden="true" class="anchor-heading" href="#multi-level-page-table"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>multi-level page table</h2>
<p><img src="/assets/images/2021-05-03-19-42-35.png"></p>
<h2 id="os"><a aria-hidden="true" class="anchor-heading" href="#os"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>os</h2>
<ul>
<li>不同进程共享同一个物理page</li>
<li>写时复制，一开始指向同一个，改变一个的时候copy另一个</li>
</ul>
<p><img src="/assets/images/2021-05-03-19-46-33.png"></p>
<h3 id="heap"><a aria-hidden="true" class="anchor-heading" href="#heap"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>heap</h3>
<p><img src="/assets/images/2021-05-03-19-47-09.png"></p>
<ul>
<li>malloc</li>
<li>free</li>
</ul>
<p>在头部和尾部都有a/f表示 上一个/下一个是不是allocate，常数时间合并空闲块</p>
<h3 id="垃圾收集"><a aria-hidden="true" class="anchor-heading" href="#垃圾收集"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>垃圾收集</h3>
<p>A garbage collector is a dynamic storage allocator that automatically frees allocated blocks that are no longer needed by the program.</p>
<p>有一些根节点可以到达堆节点</p>
<p><img src="/assets/images/2021-05-03-19-50-10.png"></p>
<hr>
<h2 id="children"><a aria-hidden="true" class="anchor-heading" href="#children"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Children</h2>
<ol>
<li><a href="/notes/da2027b2-1ea8-4a4a-a888-daa28f712b47">Namespace</a></li>
</ol></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-4"><div><div class=""><div class="ant-anchor-wrapper" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#phycical-memory" title="Phycical Memory">Phycical Memory</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#virtaul-memory" title="Virtaul Memory">Virtaul Memory</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#缓存的工具" title="缓存的工具">缓存的工具</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#swap" title="Swap">Swap</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#内存管理" title="内存管理">内存管理</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#内存保护" title="内存保护">内存保护</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#地址翻译-mmu" title="地址翻译 Mmu">地址翻译 Mmu</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#tlb" title="Tlb">Tlb</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#multi-level-page-table" title="Multi Level Page Table">Multi Level Page Table</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#os" title="Os">Os</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#heap" title="Heap">Heap</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#垃圾收集" title="垃圾收集">垃圾收集</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#children" title="Children">Children</a></div></div></div></div></div></div></div></div></div></main><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></section></section></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"723f785b-cdfa-43e1-ad13-785cf113e33d","title":"Memory","vault":{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},"type":"note","desc":"","links":[],"anchors":{"phycical-memory":{"type":"header","value":"phycical-memory","line":10,"column":0},"virtaul-memory":{"type":"header","value":"virtaul-memory","line":23,"column":0},"缓存的工具":{"type":"header","value":"缓存的工具","line":31,"column":0},"swap":{"type":"header","value":"swap","line":59,"column":0},"内存管理":{"type":"header","value":"内存管理","line":74,"column":0},"内存保护":{"type":"header","value":"内存保护","line":80,"column":0},"地址翻译-mmu":{"type":"header","value":"地址翻译-mmu","line":84,"column":0},"tlb":{"type":"header","value":"tlb","line":94,"column":0},"multi-level-page-table":{"type":"header","value":"multi-level-page-table","line":102,"column":0},"os":{"type":"header","value":"os","line":106,"column":0},"heap":{"type":"header","value":"heap","line":113,"column":0},"垃圾收集":{"type":"header","value":"垃圾收集","line":122,"column":0}},"fname":"development.computer.memory","updated":1620096611517,"created":1617687471994,"parent":"6cea4852-6e7c-4140-b476-85c07b48a642","children":["da2027b2-1ea8-4a4a-a888-daa28f712b47"],"data":{},"custom":{},"contentHash":"ca73bda81730d635bddf1e6407783441"},"body":"\u003ch1 id=\"memory\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#memory\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eMemory\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://gywbd.github.io/posts/2016/1/segmentation-fault.html\"\u003ereference\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"phycical-memory\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#phycical-memory\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003ephycical memory\u003c/h1\u003e\n\u003cp\u003estack（栈）是一块用于保存函数调用信息——传递的参数、每个函数的本地变量的内存区域\u003c/p\u003e\n\u003cp\u003eheap（堆）是一块程序可以任意使用的内存区域，程序员有完全自由的权限对这个区域进行任何想要的操作\u003c/p\u003e\n\u003cp\u003estack部分的大小在程序运行过程中是可变的。当函数调用发生时，stack就会扩大，当函数调用结束时：之前扩大的stack就会缩小为调用之前的样子\nheap同样也是一个大小可变的区域，当程序员从heap中请求内存（malloc()）时，heap就会扩大，当这些内存被释放后（free()），heap就会缩小。\nstack和heap都是可伸缩的区域，它们处于整个地址空间中的相对位置：stack会向下扩展（由高地址到低地址），而heap则会向上扩展（由低地址到高地址）。它们都是可以自由增长的区域，只是增长的方向刚好相反。操作系统只需要检查这两个区域不会出现重叠的情况，这是它们主要的使用限制。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/images/2021-04-05-23-02-01.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"virtaul-memory\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#virtaul-memory\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003evirtaul memory\u003c/h1\u003e\n\u003cp\u003eThe virtual memory abstracts the details of physical memory from the application software, allows to keep only needed information in the physical memory (demand paging) and provides a mechanism for the protection and controlled sharing of data between processes.\u003c/p\u003e\n\u003cp\u003e虚拟内存提供三个重要的能力，第一个把主存看作一个存储在磁盘上地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式高效的使用的主存，第二点，他为每个进程提供了一致的地址空间，从而简化了内存管理，第三它保护了每个进程地址空间，不被其他进程破坏。\u003c/p\u003e\n\u003cp\u003e虚拟内存其实是在磁盘上，需要用的时候放到主存里。每个虚拟地址指向一个PTE, 包含有效位以及物理页号或者磁盘地址。缓存不命中是缺页，调用缺页异常处理程序，选择一个页面换成需要的页面。之后重新启动缺页异常的指令。重新地址翻译。可以利用TLB加速地址翻译或者使用多级页表。\u003c/p\u003e\n\u003ch2 id=\"缓存的工具\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#缓存的工具\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003e缓存的工具\u003c/h2\u003e\n\u003cp\u003e每个字节有唯一的虚拟地址。\u003c/p\u003e\n\u003cp\u003evirutal page有三种类型\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e未分配的：VM系统中未分配的页，不占任何磁盘空间\u003c/li\u003e\n\u003cli\u003e缓存的：当前已缓存的在物理内存中的已分配页\u003c/li\u003e\n\u003cli\u003e未缓存的：未缓存在物理内存中的已分配页\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/images/2021-05-03-19-20-38.png\"\u003e\u003c/p\u003e\n\u003cp\u003eDRAM 比 SRAM(L1,L2,L3)慢10倍，虚拟页比较大。, DRAM caches always use write-back instead of write-through.\u003c/p\u003e\n\u003cp\u003eIn write through, data is simultaneously updated to cache and memory.\nwrite back: The data is updated only in the cache and updated into the memory in later time. \u003c/p\u003e\n\u003cp\u003e通过mmu, 页表(page table)判断一个虚拟页是否缓存在DRAM中的某一个地方，mmu把VP-\u003ePP\u003c/p\u003e\n\u003cp\u003ePTE(page table entry) 有效位表明当前VP是否缓存在DRAM\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/images/2021-05-03-19-25-39.png\"\u003e\u003c/p\u003e\n\u003cp\u003e页命中：如果有效，可以获得物理地址\u003c/p\u003e\n\u003cp\u003e缺页：page fault，调用内核缺页处理程序。程序选择一个牺牲页，修改DRAM，把磁盘里的VP复制到DRAM，重新启动缺页的指令，把导致缺页的虚拟地址重新发到MMU，命中。\u003c/p\u003e\n\u003cp\u003eThe activity of transferring a page between disk and memorf is known as swapping or paging. Pages are swapped in (paged in) from disk to DRAM, anct swapped out (paged out) from DRAM to disk\u003c/p\u003e\n\u003ch3 id=\"swap\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#swap\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eswap\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eWhat is swap, when will it be used?\nSwap space is located on hard drives for inactive pages in memory\nSwapping is the process whereby a page of memory is copied to the preconfigured space on the hard disk,\ncalled swap space, to free up that page of memory.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhat's the situation that a process will swap\nSwap space in Linux is used when the amount of physical memory (RAM) is full.\nIf the system needs more memory resources and the RAM is full,\ninactive pages in memory are moved to the swap space.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhat's the down side of swap?\nSwap space is located on hard drives, which have a slower access time than physical memory.\n\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"内存管理\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#内存管理\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003e内存管理\u003c/h2\u003e\n\u003cp\u003e不同进程里的VP可以共享一个PP。简化linking，loading，share，内存分配\u003c/p\u003e\n\u003cp\u003e两个进程将私有对象映射到它们的虚拟内存的不同区域，但是共享这个对象，统一个物理副本，对于每个应设是有对象的进程，相应的所有区域的业表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要没有进程，试图修改他们自己的私有区域，他们就可以继续共享物理内存对象的一个单独副本，但是只要有一个进程，试图写私有区域内的某个页面，他就会复制一个新的，在那个里面写。\u003c/p\u003e\n\u003ch2 id=\"内存保护\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#内存保护\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003e内存保护\u003c/h2\u003e\n\u003cp\u003e在page table有许可位，判定这个page的访问权限。\u003c/p\u003e\n\u003ch2 id=\"地址翻译-mmu\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#地址翻译-mmu\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003e地址翻译 mmu\u003c/h2\u003e\n\u003cp\u003eMMU memory management unit.\nThe mapping between virtual address and physical address.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/images/2021-04-05-22-38-37.png\"\u003e\u003c/p\u003e\n\u003cp\u003e当一个用户级进程想访问一些内存，它会产生一个访问请求，MMU会把请求的虚拟地址转换为对应的物理内存地址。但是如果这个地址访问存在错误：转换后的物理地址超出了物理段的界限，或者违反了段保护权限（例如请求向只读段中写入数据），此时默认情况下操作系统会产生一个表示需要进行错误处理的信号：SIGSEGV，对这个信号的默认处理行为（default handler）是杀死（kill）这个进程，并且输出一个消息：“Segmentation fault”。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/images/2021-05-03-19-35-51.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"tlb\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#tlb\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eTLB\u003c/h2\u003e\n\u003cp\u003e快速重编址缓冲器（Translation-lookaside Buffer : TLB）\u003c/p\u003e\n\u003cp\u003e在每次虚拟内存访问时都会使用MMU，它会先从地址中提取出VPN，然后根据这个VPN查找TLB中是否有对应的VPN。如果命中（hit），它会直接返回TLB中记录的对应的物理地址，完成它的使命。如果没有命中（miss），那么它会查找进程的页表，如果对这个物理地址的访问是合法的，那么它会更新TLB，那么之后再访问这个虚拟地址，就会命中了。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/images/2021-05-03-19-36-10.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"multi-level-page-table\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#multi-level-page-table\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003emulti-level page table\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/images/2021-05-03-19-42-35.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"os\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#os\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eos\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e不同进程共享同一个物理page\u003c/li\u003e\n\u003cli\u003e写时复制，一开始指向同一个，改变一个的时候copy另一个\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/images/2021-05-03-19-46-33.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"heap\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#heap\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eheap\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"/assets/images/2021-05-03-19-47-09.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emalloc\u003c/li\u003e\n\u003cli\u003efree\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在头部和尾部都有a/f表示 上一个/下一个是不是allocate，常数时间合并空闲块\u003c/p\u003e\n\u003ch3 id=\"垃圾收集\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#垃圾收集\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003e垃圾收集\u003c/h3\u003e\n\u003cp\u003eA garbage collector is a dynamic storage allocator that automatically frees allocated blocks that are no longer needed by the program.\u003c/p\u003e\n\u003cp\u003e有一些根节点可以到达堆节点\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/images/2021-05-03-19-50-10.png\"\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"children\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#children\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eChildren\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"/notes/da2027b2-1ea8-4a4a-a888-daa28f712b47\"\u003eNamespace\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e","noteIndex":{"id":"0f1b48c7-3a25-4016-83a5-15864d7803ad","title":"Development","vault":{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},"type":"note","desc":"","links":[{"from":{"fname":"root","vaultName":"my_note"},"type":"backlink","position":{"start":{"line":8,"column":3,"offset":63},"end":{"line":8,"column":21,"offset":81},"indent":[]},"value":"development"}],"anchors":{},"fname":"development","updated":1618381238346,"created":1612940782409,"parent":null,"children":["400115e9-30f7-4a13-9776-db059bc9cd42","xsX5v3ZsyJ0i6gf9","1bc3b45a-b6f4-4150-87d3-5bd5b6eb8c24","6cea4852-6e7c-4140-b476-85c07b48a642","a40ef849-d301-4d74-a778-e6d9469dfb5d","09d9081f-3dff-453d-8488-7d2344cc8895","92917ea3-452e-48dc-875e-5cd0002041db","2e151826-cb22-4d89-8ce0-71dad7204ce8","baa39444-0da9-4c55-8df7-2a6f8f787fa4","62daf50d-a39e-463f-aabd-be53790281fd","3524d0a7-be73-45d6-847e-c970f5c1c760","eac0f243-05b3-4b95-bec3-848e33edbc40"],"data":{},"custom":{"nav_order":0,"permalink":"/"},"body":"\n","contentHash":"38357962f5a50c6fd7d318dfa66bea90"},"collectionChildren":null,"customHeadContent":null,"config":{"version":4,"useFMTitle":true,"useNoteTitleForLink":true,"mermaid":true,"useKatex":true,"dev":{"previewV2Enabled":false,"enablePreviewV2":true},"site":{"copyAssets":true,"siteHierarchies":["development","life"],"siteRootDir":"docs","usePrettyRefs":true,"title":"my_note","siteUrl":"https://notes.tczhong.com","description":"Personal knowledge space","siteLastModified":true,"gh_edit_branch":"main","usePrettyLinks":true,"siteNotesDir":"notes","siteFaviconPath":"favicon.ico","gh_edit_link":true,"gh_edit_link_text":"Edit this page on GitHub","gh_root":"docs/","gh_edit_view_mode":"edit","writeStubs":true,"siteIndex":"development"},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true}},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"randomNote":{}},"workspace":{"dendronVersion":"0.70.0","vaults":[{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"graph":{"zoomSpeed":1},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableUserTags":true,"enableHashTags":true,"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"}},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"723f785b-cdfa-43e1-ad13-785cf113e33d"},"buildId":"FWMOU7HnIEvYhYu7_V-Vm","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>