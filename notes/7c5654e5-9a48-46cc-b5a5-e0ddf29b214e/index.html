<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Recovery</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Recovery"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://notes.tczhong.com/notes/7c5654e5-9a48-46cc-b5a5-e0ddf29b214e/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="4/12/2021"/><meta property="article:modified_time" content="4/12/2021"/><link rel="canonical" href="https://notes.tczhong.com/notes/7c5654e5-9a48-46cc-b5a5-e0ddf29b214e/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6b338472289fe290.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/2XI28xCTA7nnAuXRumXG6/_buildManifest.js" defer=""></script><script src="/_next/static/2XI28xCTA7nnAuXRumXG6/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="recovery">Recovery<a aria-hidden="true" class="anchor-heading icon-link" href="#recovery"></a></h1>
<p>Recovery algorithms are techniques to ensure database consistency, transaction atomicity, and durability despite failures. Recovery algorithm has two parts: actions during normal transaction, actions after a failure to recover the database.The key primitives are UNDO, the process of removing the effects of an incomplete or aborted transaction. REDO: the process of re-instating the effects of a committed transaction for durability.</p>
<p>Storage can be volatile storage, data will be lost after powering off. Non-Volatile have data persistent after powering off. Stable storage never lose data. It could achieve approximately by using multiple storages. </p>
<p>Failure can be transaction failure: transaction cannot complete due to some internal error and DBMS must terminate an active transaction due to an error condition. System failure is DBMS fails and system is crashed, non-volatile storage are not corrupted. Storage media failure is a disk failure and destroy parts of non-volatile storage. </p>
<p><strong>Buffer pool management steal policies</strong> will decide whether the DBMS allow an uncommitted transaction to overwrite the most recent committed value of an object in non-volatile storage. No-steal policy will not write uncommitted transaction value back to disk,  steal policy, allows the system to write modified blocks to disk even if the transactions that made those modifications have not all committed, could steal other transaction's memory. Force policy ensures that all updates made by a transaction are reflected on non-volatile
storage before the transaction is allowed to commit. No-force is not enforced to do this. NO-STEAL + FORCE means no redo: all committed transactions' changes are reflected in disk, no undo: all aborted transactions' changes are not written to disk. Limitation is memory because of no-steal policy.</p>
<p>Shadow paging means updates are only made in the shadow copy. When a transaction commits, atomically switch the shadow to become the new master. Disadvantages: Copying the entire page table is expensive and the commit overhead is high. Organize the database pages in a tree structure where the root is a single disk page. The root points to the master copy, updates are applied to the shadow copy. To install updates, overwrite the root so it points to the shadow, thereby swapping the master and
shadow. For undo, it remove the shadow pages. Leave master and the DB root pointer alone. Do not need redo.</p>
<p><strong>Write-Ahead Logging</strong> means DBMS records all changes made to the db in log file before changes is made to a disk page. The log contains information to perform undo and redo. It has fast runtime performance but slow recovery time. Log records are written to disk before update is allowed to be written on disk. Transaction is committed until all its log records have been written to stable storage.Write BEGIN in the beginning, COMMITTED to make sure all log records are flushed. Log records contains tid, object id, before value(UNDO), after value(REDO). If we use NO-STEAL policy, we don't need original value, but in that way we could not undo for aborted transaction.</p>
<p>DBMS can periodically takes a checkpoint where it flushes all buffers out to disk. The DBMS stops accepting new transactions and waits for all active transactions to complete. Flush all log records and dirty blocks currently residing in main memory to stable storage. Write a <checkpoint> entry to the log and flush to stable storage.</checkpoint></p>
<p>Logging schemes could be physical logging: record the changes made to a specific location in the database. Logical logging records the high operations executed by transactions. Physiological logging means log records target a single page but do not specify data organization of the page.</p>
<h2 id="aries">ARIES<a aria-hidden="true" class="anchor-heading icon-link" href="#aries"></a></h2>
<p>Algorithms for Recovery and Isolation Exploiting Semantics. </p>
<ul>
<li>WAL</li>
<li>Repeat history in redo</li>
<li>logging changes during undo</li>
</ul>
<p>In WAL, each log record has a global unique log sequence number. Each data page contains a pageLSN, the LSN of the most recent update to that page. prevLSN: The previous LSN for the transaction. System keeps track of flushedLSN: the max LSN flushed so far. Before page i can be written to disk, we must flush log at least to the point where <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>L</mi><mi>S</mi><msub><mi>N</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">pageLSN_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> ≤ flushedLSN.</p>
<p>Transaction commit will first write COMMIT record to log. All log records to to transaction’s COMMIT record are flushed to disk. When the commit succeeds, write a special TXN-END record to log. </p>
<p>Transaction abort just an UNDO operation. Use prevLSN to undo transaction. Compensation Log Record, CLR describes the actions taken to undo the actions of a previous update record. It has all the fields of an update log record plus the undoNext pointer. CLRs are added to the log like any other record but they never need to be undone.</p>
<ol>
<li>First write ABORT record to log.</li>
<li>Then play back updates in reverse order to remove their effects. For each update, write a CLR entry and restore old value.</li>
<li>At end, write a TXN-END log record.</li>
</ol>
<p>Blocking checkpoints will halt the start of any new transactions and wait until all active transactions finish executing, flush dirty pages on disk.</p>
<p>Better one will halt new transaction and just pause transactions while the DBMS takes the checkpoint. It uses
<strong>Active Transaction Table (ATT)</strong> to record active transaction and their lastLSN(most recent lsn written by transaction). Entry is removed when transaction commits or aborts. In <strong>Dirty Page Table (DPT)</strong>, it keeps track of pages in the buffer pool contain changes from uncommitted transactions. And there is <strong>recLSN</strong> field, the LSN of the log record that first caused the page to be dirty.</p>
<p>Fuzzy checkpoints allows other transactions to continue to run. Add new log records to track checkpoint boundaries, <checkpoint-begin>: Indicates the start of the checkpoint, <checkpoint-end>: Contains the ATT + DPT.</checkpoint-end></checkpoint-begin></p>
<p>There are three phases in ARIES.</p>
<p>Analysis: Read the WAL to identify dirty pages in the buffer pool and active transactions at the time of the crash.</p>
<ul>
<li>Scan log forward from the checkpoint.</li>
<li>If you find a TXN-END record, remove its transaction from ATT.</li>
<li>All other records, add transaction to ATT with status UNDO, and on commit, change transaction status to COMMIT.</li>
<li>For UPDATE records, if page P not in DPT, add P to DPT and set its recLSN=LSN</li>
</ul>
<p>REDO: repeat history to reconstruct state at the moment of the crash. Reapply all updates (even aborted transactions) and redo CLRs:</p>
<ul>
<li>Scan forward from log record containing smallest recLSN in PDT.</li>
<li>For each update log record or CLR with a given LSN, redo the action unless:
– Affected page is not in the DPT, or
– Affected page is in DPT but that record’s LSN is greater than smallest recLSN, or
– Affected pageLSN (on disk) ≥ LSN.</li>
<li>To redo an action:
– Reapply logged action.
– Set pageLSN to log records LSN.
– At the end of the redo phase, write TXN-END log records for all transactions with status “C” and remove them from the ATT.</li>
</ul>
<p>Undo Phase:</p>
<ul>
<li>Undo All transactions active at the time of crash</li>
<li>These are all transactions with “U” status in the ATT after the Analysis phase </li>
<li>Process them in reverse LSN order using the lastLSN to speed up traversal</li>
<li>Write a CLR for every modification</li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#aries" title="Aries">Aries</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"7c5654e5-9a48-46cc-b5a5-e0ddf29b214e","title":"Recovery","vault":{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},"type":"note","desc":"","links":[],"anchors":{"aries":{"type":"header","value":"aries","line":27,"column":0}},"fname":"development.database.concurrency.recovery","updated":1618208250606,"created":1618208198458,"parent":"c10c6c14-9f83-4681-8aef-74c7a20432b1","children":[],"data":{},"custom":{},"contentHash":"31f5321c72a08a7a80bcbfb2040afb8f"},"body":"\u003ch1 id=\"recovery\"\u003eRecovery\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#recovery\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003eRecovery algorithms are techniques to ensure database consistency, transaction atomicity, and durability despite failures. Recovery algorithm has two parts: actions during normal transaction, actions after a failure to recover the database.The key primitives are UNDO, the process of removing the effects of an incomplete or aborted transaction. REDO: the process of re-instating the effects of a committed transaction for durability.\u003c/p\u003e\n\u003cp\u003eStorage can be volatile storage, data will be lost after powering off. Non-Volatile have data persistent after powering off. Stable storage never lose data. It could achieve approximately by using multiple storages. \u003c/p\u003e\n\u003cp\u003eFailure can be transaction failure: transaction cannot complete due to some internal error and DBMS must terminate an active transaction due to an error condition. System failure is DBMS fails and system is crashed, non-volatile storage are not corrupted. Storage media failure is a disk failure and destroy parts of non-volatile storage. \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBuffer pool management steal policies\u003c/strong\u003e will decide whether the DBMS allow an uncommitted transaction to overwrite the most recent committed value of an object in non-volatile storage. No-steal policy will not write uncommitted transaction value back to disk,  steal policy, allows the system to write modified blocks to disk even if the transactions that made those modifications have not all committed, could steal other transaction's memory. Force policy ensures that all updates made by a transaction are reflected on non-volatile\nstorage before the transaction is allowed to commit. No-force is not enforced to do this. NO-STEAL + FORCE means no redo: all committed transactions' changes are reflected in disk, no undo: all aborted transactions' changes are not written to disk. Limitation is memory because of no-steal policy.\u003c/p\u003e\n\u003cp\u003eShadow paging means updates are only made in the shadow copy. When a transaction commits, atomically switch the shadow to become the new master. Disadvantages: Copying the entire page table is expensive and the commit overhead is high. Organize the database pages in a tree structure where the root is a single disk page. The root points to the master copy, updates are applied to the shadow copy. To install updates, overwrite the root so it points to the shadow, thereby swapping the master and\nshadow. For undo, it remove the shadow pages. Leave master and the DB root pointer alone. Do not need redo.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWrite-Ahead Logging\u003c/strong\u003e means DBMS records all changes made to the db in log file before changes is made to a disk page. The log contains information to perform undo and redo. It has fast runtime performance but slow recovery time. Log records are written to disk before update is allowed to be written on disk. Transaction is committed until all its log records have been written to stable storage.Write BEGIN in the beginning, COMMITTED to make sure all log records are flushed. Log records contains tid, object id, before value(UNDO), after value(REDO). If we use NO-STEAL policy, we don't need original value, but in that way we could not undo for aborted transaction.\u003c/p\u003e\n\u003cp\u003eDBMS can periodically takes a checkpoint where it flushes all buffers out to disk. The DBMS stops accepting new transactions and waits for all active transactions to complete. Flush all log records and dirty blocks currently residing in main memory to stable storage. Write a \u003ccheckpoint\u003e entry to the log and flush to stable storage.\u003c/checkpoint\u003e\u003c/p\u003e\n\u003cp\u003eLogging schemes could be physical logging: record the changes made to a specific location in the database. Logical logging records the high operations executed by transactions. Physiological logging means log records target a single page but do not specify data organization of the page.\u003c/p\u003e\n\u003ch2 id=\"aries\"\u003eARIES\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#aries\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAlgorithms for Recovery and Isolation Exploiting Semantics. \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWAL\u003c/li\u003e\n\u003cli\u003eRepeat history in redo\u003c/li\u003e\n\u003cli\u003elogging changes during undo\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn WAL, each log record has a global unique log sequence number. Each data page contains a pageLSN, the LSN of the most recent update to that page. prevLSN: The previous LSN for the transaction. System keeps track of flushedLSN: the max LSN flushed so far. Before page i can be written to disk, we must flush log at least to the point where \u003cspan class=\"math math-inline\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\"\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003ep\u003c/mi\u003e\u003cmi\u003ea\u003c/mi\u003e\u003cmi\u003eg\u003c/mi\u003e\u003cmi\u003ee\u003c/mi\u003e\u003cmi\u003eL\u003c/mi\u003e\u003cmi\u003eS\u003c/mi\u003e\u003cmsub\u003e\u003cmi\u003eN\u003c/mi\u003e\u003cmi\u003ei\u003c/mi\u003e\u003c/msub\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003epageLSN_i\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003ep\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003ea\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.03588em;\"\u003eg\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003ee\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003eL\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.05764em;\"\u003eS\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003eN\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t vlist-t2\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.3117em;\"\u003e\u003cspan style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mathnormal mtight\"\u003ei\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-s\"\u003e​\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.15em;\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e ≤ flushedLSN.\u003c/p\u003e\n\u003cp\u003eTransaction commit will first write COMMIT record to log. All log records to to transaction’s COMMIT record are flushed to disk. When the commit succeeds, write a special TXN-END record to log. \u003c/p\u003e\n\u003cp\u003eTransaction abort just an UNDO operation. Use prevLSN to undo transaction. Compensation Log Record, CLR describes the actions taken to undo the actions of a previous update record. It has all the fields of an update log record plus the undoNext pointer. CLRs are added to the log like any other record but they never need to be undone.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eFirst write ABORT record to log.\u003c/li\u003e\n\u003cli\u003eThen play back updates in reverse order to remove their effects. For each update, write a CLR entry and restore old value.\u003c/li\u003e\n\u003cli\u003eAt end, write a TXN-END log record.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBlocking checkpoints will halt the start of any new transactions and wait until all active transactions finish executing, flush dirty pages on disk.\u003c/p\u003e\n\u003cp\u003eBetter one will halt new transaction and just pause transactions while the DBMS takes the checkpoint. It uses\n\u003cstrong\u003eActive Transaction Table (ATT)\u003c/strong\u003e to record active transaction and their lastLSN(most recent lsn written by transaction). Entry is removed when transaction commits or aborts. In \u003cstrong\u003eDirty Page Table (DPT)\u003c/strong\u003e, it keeps track of pages in the buffer pool contain changes from uncommitted transactions. And there is \u003cstrong\u003erecLSN\u003c/strong\u003e field, the LSN of the log record that first caused the page to be dirty.\u003c/p\u003e\n\u003cp\u003eFuzzy checkpoints allows other transactions to continue to run. Add new log records to track checkpoint boundaries, \u003ccheckpoint-begin\u003e: Indicates the start of the checkpoint, \u003ccheckpoint-end\u003e: Contains the ATT + DPT.\u003c/checkpoint-end\u003e\u003c/checkpoint-begin\u003e\u003c/p\u003e\n\u003cp\u003eThere are three phases in ARIES.\u003c/p\u003e\n\u003cp\u003eAnalysis: Read the WAL to identify dirty pages in the buffer pool and active transactions at the time of the crash.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eScan log forward from the checkpoint.\u003c/li\u003e\n\u003cli\u003eIf you find a TXN-END record, remove its transaction from ATT.\u003c/li\u003e\n\u003cli\u003eAll other records, add transaction to ATT with status UNDO, and on commit, change transaction status to COMMIT.\u003c/li\u003e\n\u003cli\u003eFor UPDATE records, if page P not in DPT, add P to DPT and set its recLSN=LSN\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eREDO: repeat history to reconstruct state at the moment of the crash. Reapply all updates (even aborted transactions) and redo CLRs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eScan forward from log record containing smallest recLSN in PDT.\u003c/li\u003e\n\u003cli\u003eFor each update log record or CLR with a given LSN, redo the action unless:\n– Affected page is not in the DPT, or\n– Affected page is in DPT but that record’s LSN is greater than smallest recLSN, or\n– Affected pageLSN (on disk) ≥ LSN.\u003c/li\u003e\n\u003cli\u003eTo redo an action:\n– Reapply logged action.\n– Set pageLSN to log records LSN.\n– At the end of the redo phase, write TXN-END log records for all transactions with status “C” and remove them from the ATT.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUndo Phase:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUndo All transactions active at the time of crash\u003c/li\u003e\n\u003cli\u003eThese are all transactions with “U” status in the ATT after the Analysis phase \u003c/li\u003e\n\u003cli\u003eProcess them in reverse LSN order using the lastLSN to speed up traversal\u003c/li\u003e\n\u003cli\u003eWrite a CLR for every modification\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"0f1b48c7-3a25-4016-83a5-15864d7803ad","title":"Development","vault":{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},"type":"note","desc":"","links":[{"from":{"fname":"root","id":"c95dc4f5-23db-45e7-a15b-64582a183ccc","vaultName":"my_note"},"type":"backlink","position":{"start":{"line":8,"column":3,"offset":63},"end":{"line":8,"column":21,"offset":81},"indent":[]},"value":"development"}],"anchors":{},"fname":"development","updated":1618381238346,"created":1612940782409,"parent":null,"children":["400115e9-30f7-4a13-9776-db059bc9cd42","xsX5v3ZsyJ0i6gf9","1bc3b45a-b6f4-4150-87d3-5bd5b6eb8c24","6cea4852-6e7c-4140-b476-85c07b48a642","a40ef849-d301-4d74-a778-e6d9469dfb5d","09d9081f-3dff-453d-8488-7d2344cc8895","p11phg7nb10yw0wck1fyagq","92917ea3-452e-48dc-875e-5cd0002041db","2e151826-cb22-4d89-8ce0-71dad7204ce8","baa39444-0da9-4c55-8df7-2a6f8f787fa4","q4um3bc3st86ilkkvdjom6x","62daf50d-a39e-463f-aabd-be53790281fd","3524d0a7-be73-45d6-847e-c970f5c1c760","eac0f243-05b3-4b95-bec3-848e33edbc40","nc777xa48letazo00100hin"],"data":{},"custom":{"nav_order":0,"permalink":"/"},"body":"\n","contentHash":"38357962f5a50c6fd7d318dfa66bea90"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"previewV2Enabled":false,"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"randomNote":{},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"dendronVersion":"0.90.0","vaults":[{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableUserTags":true,"enableHashTags":true,"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"enableEditorDecorations":true,"enableHandlebarTemplates":true,"enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["development","life"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"my_note","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","enableMermaid":true,"siteUrl":"https://notes.tczhong.com","siteFaviconPath":"favicon.ico","siteIndex":"development"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"7c5654e5-9a48-46cc-b5a5-e0ddf29b214e"},"buildId":"2XI28xCTA7nnAuXRumXG6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>