<h1 id="graphsearch"><a aria-hidden="true" class="anchor-heading icon-link" href="#graphsearch"></a>Graphsearch</h1>
<h1 id="bfs"><a aria-hidden="true" class="anchor-heading icon-link" href="#bfs"></a>BFS</h1>
<pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">BFS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>
 
    <span class="token comment"># Mark all the vertices as not visited</span>
    visited <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>graph<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

    <span class="token comment"># Create a queue for BFS</span>
    queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token comment"># Mark the source node as </span>
    <span class="token comment"># visited and enqueue it</span>
    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>

    <span class="token keyword">while</span> queue<span class="token punctuation">:</span>

        <span class="token comment"># Dequeue a vertex from </span>
        <span class="token comment"># queue and print it</span>
        s <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span> <span class="token punctuation">(</span>s<span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">)</span>

        <span class="token comment"># Get all adjacent vertices of the</span>
        <span class="token comment"># dequeued vertex s. If a adjacent</span>
        <span class="token comment"># has not been visited, then mark it</span>
        <span class="token comment"># visited and enqueue it</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">False</span><span class="token punctuation">:</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
                visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
 

</code></pre>
<h1 id="dfs"><a aria-hidden="true" class="anchor-heading icon-link" href="#dfs"></a>DFS</h1>
<pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">DFSUtil</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> v<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">:</span>
 
    <span class="token comment"># Mark the current node as visited</span>
    <span class="token comment"># and print it</span>
    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>v<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
 
    <span class="token comment"># Recur for all the vertices</span>
    <span class="token comment"># adjacent to this vertex</span>
    <span class="token keyword">for</span> neighbour <span class="token keyword">in</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> neighbour <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>DFSUtil<span class="token punctuation">(</span>neighbour<span class="token punctuation">,</span> visited<span class="token punctuation">)</span>
 
<span class="token comment"># The function to do DFS traversal. It uses</span>
<span class="token comment"># recursive DFSUtil()</span>
<span class="token keyword">def</span> <span class="token function">DFS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token comment"># Create a set to store visited vertices</span>
    visited <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># Call the recursive helper function</span>
    <span class="token comment"># to print DFS traversal</span>
    self<span class="token punctuation">.</span>DFSUtil<span class="token punctuation">(</span>v<span class="token punctuation">,</span> visited<span class="token punctuation">)</span>

</code></pre>
<h1 id="最短路径算法"><a aria-hidden="true" class="anchor-heading icon-link" href="#最短路径算法"></a>最短路径算法</h1>
<p>单点最短路径算法： bellman-ford 算法，基本思路就是每次更新从起点到v的距离，如果起点到u再到v的路程短，那么就更新。</p>
<pre><code> for i from 1 to size(vertices)-1:
       for each edge (u, v) with weight w in edges:
           if distance[u] + w &#x3C; distance[v]:
               distance[v] := distance[u] + w
</code></pre>
<p>Dijkstra’s 算法，这也是单点最短路径算法，基本思路是每次从q中取最小的节点，之后更新从该点到其他的点的距离。</p>
<pre><code>function Dijkstra(G, w, s)
    for each vertex v in V[G]        // 初始化
           d[v] := infinity           // 將各點的已知最短距離先設成無窮大
    d[s] := 0                        // 因为出发点到出发点间不需移动任何距离，所以可以直接将s到s的最小距离设为0
     S := empty set
     Q := set of all vertices
     while Q is not an empty set      // Dijkstra演算法主體
        u := Extract_Min(Q)
        S.append(u)
        for each edge outgoing from u as (u,v)
            if d[v] > d[u] + w(u,v)  // 拓展边（u,v）。w(u,v)为从u到v的路径长度。
                d[v] := d[u] + w(u,v)  // 更新路径长度到更小的那个和值。
</code></pre>
<h1 id="a"><a aria-hidden="true" class="anchor-heading icon-link" href="#a"></a>A*</h1>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/notes/400115e9-30f7-4a13-9776-db059bc9cd42">Algo (my_note)</a></li>
</ul>