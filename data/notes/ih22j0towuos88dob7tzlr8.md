
1. Small is beautiful. Small things have tremendous advantages over their larger counterparts. Among these is the ability to combine with other small things in unique and useful ways, ways often unforeseen by the original designer.
2. Make each program do one thing well. By focusing on a single task, a program can eliminate much extraneous code that often results in excess overhead, unnecessary complexity, and a lack of flexibility.
3. Build a prototype as soon as possible. Most people would agree that prototyping is a valuable element of any project. But whereas prototyping is only a small part of the design phase under other methodologies, under Unix it is the principal vehicle for generating an effective design.
4. Choose portability over efficiency. When Unix broke new ground as the first portable operating system of any significance, it was big news. Today portability is taken for granted as a necessity in any modern software design, an example of a tenet that has gained wide acceptance on other systems besides Unix.
5. Store data in flat text files. The choice between portability and efficiency addresses the value of portable code. Portable data is at least as important as-if not more important than-portable code. Portable data is the often-neglected part of the portability formula.
6. Use software leverage to your advantage. Many programmers have only a superficial understanding of the importance of reusable code modules. Code reuse helps one take advantage of software leverage, a powerful concept that some Unix developers use to create numerous applications in a comparatively short time.
7. Use shell scripts to increase leverage and portability. Shell scripts are double-edged swords for enhancing both software leverage and portability in a design. Whenever possible, writing a script instead of a complete C program is the way to go.
8. Avoid captive user interfaces. Some commands have user interfaces known to Unix developers as "captive" user interfaces. These prevent the user from running other commands while the command is in use, effectively making the user a captive to the system for the duration of the command. In a graphical user interface world, such interfaces would be called "modal."
9. **Make every program a filter.** The fundamental nature of all software programs is that they only modify data; they do not create it. Therefore, they should be written to perform as filters since they are filters.
