{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Life","n":1},"1":{"v":"\n# 生活\n\n- [[亲密关系|life.love]]\n- [[人际沟通|life.communication]]\n- [[厨艺|life.cooking]]\n\n# 娱乐\n\n- [[摄影|life.photo]]\n- ","n":0.378}}},{"i":2,"$":{"0":{"v":"Music","n":1}}},{"i":3,"$":{"0":{"v":"Concept","n":1}}},{"i":4,"$":{"0":{"v":"Song_structure","n":1},"1":{"v":"\n![](/assets/images/2024-01-27-08-16-06.png)\n\n- 前奏\n- verse 1\n  - 歌词 人声为主\n- pre-chorus\n  - 承上启下 连接主干和高潮\n  - 歌词一致\n- chorus 1\n  - 高潮 每次歌词都一样\n- 间奏","n":0.229}}},{"i":5,"$":{"0":{"v":"Notes","n":1},"1":{"v":"\n大多数音乐都有特定的调。假设一首歌是C调，这意味着C音是这首歌最为稳定的“首要音”（也就是主音）。\n\n同样的，大多数音乐使用特定音阶 中的音 — 一组从低到高顺序排列的音符集合。\n\n## 大调 scales\n\nC调的音阶是C D E F G A B C，其中C是主音。这意味着C音是最稳定的音，而D音是第二稳定的音，以此类推。\n\n大多数人认为大调音阶听起来为“高兴的”或“明亮的”。\n\n你可以将音阶想象成画家的调色板。 它就好比是所有可选音符的子集，这些音符的选择基于它们相互联系的关系。 每一音阶都有着独特的声音气质，许多人甚至会对某一些音阶产生情感共鸣。\n\n你可以添加一些音符然后以一种特定的距离关系（音程）从主音往上排列来创建音阶。最常见的音阶种类为大调和小调 音阶。\n\n## 小调 minor scales\n\n小调音阶是由另一种音程关系排列而成的。\n\nC小调的音阶是C D Eb F G Ab Bb C，其中C是主音。这意味着C音是最稳定的音，而D音是第二稳定的音\n\n## 升调 和 降调\n\n钢琴键盘上的黑键同时也可以用♯（升号）符号来表示。\"A♯/B♭\"读作“升A”或“降B”。\n\n12 音 C C# D D# E F F# G G# A A# B C","n":0.152}}},{"i":6,"$":{"0":{"v":"Melody","n":1},"1":{"v":"\n# 旋律是如何形成的？\n\n这段旋律只使用了D大调中的音。但旋律从一个很长的E音开始，为整首歌铺垫了一种与主调相矛盾的紧张感。\n\n仔细观察一条旋律的形状或 contour（轮廓）。 在最一开始，旋律在音阶中的相邻音间起伏下落。 到结尾，旋律从B向上跳到D又向下跳到A。这样的级进 与跳进 的进行模式会产生强烈对比使得旋律有很强的表现力，容易让人记住。\n\n![](/assets/images/2024-01-27-08-09-49.png)\n\n![](/assets/images/2024-01-27-08-15-03.png)","n":0.378}}},{"i":7,"$":{"0":{"v":"Chord","n":1},"1":{"v":"\nhttps://learningmusic.ableton.com/zh-Hans/chords/mary-had-a-little-lamb.html\n\n# Chord\n\n和弦 \n\n现在让我们来看一看如何使用多个音符创建和弦。 一个和弦指的是一组不同音高的音符一起同时发声。\n\n三和弦 是最常用的和弦。它由起始音（或根音）以上叠加三音和五音而构成。 例如，在C大调中，C三和弦的构成包括：\n\nC（根音）\nE（C上方第三音；通常称为“三音”）\nG（C上方第五音；通常称为“五音”）\n这个和弦便称为C大三和弦。\n\n大调音阶通常给人以“快乐” 或 “积极”的听感。\n\n小三和弦\n在C小调中，C小三和弦的构建法相同：\n\nC（根音）\nE♭（C上方第三音；通常称为“三音”）\nG（C上方第五音；通常称为“五音”）\n这个和弦便称为C小三和弦。\n\n## 和弦进行\n\n![](/assets/images/2024-01-27-07-55-47.png)\n\n和弦进行指的是一组和弦按照特定的排列组合演奏。 在许多音乐类型中，和弦进行的运用通过离开主音又回到主音的过程营造出紧张和缓和的氛围。\n\n## 常见的和弦进行\n\n1-5-6-4: 最常见的和弦连接","n":0.289}}},{"i":8,"$":{"0":{"v":"Bass","n":1},"1":{"v":"\n贝斯旋律是如何创作的？\n\n这个贝斯的旋律走向比较有趣：先是如同“爬楼梯”一样重复三次，然后顺着音阶再“爬”下来。 使用三个重复变化的乐句之后提出一个新想法的思路是一种常见的作曲技巧。\n\n![](/assets/images/2024-01-27-08-02-13.png)\n\n\n\n![](/assets/images/2024-01-27-08-08-15.png)\n","n":0.707}}},{"i":9,"$":{"0":{"v":"Economics","n":1}}},{"i":10,"$":{"0":{"v":"Principles","n":1}}},{"i":11,"$":{"0":{"v":"Basinc","n":1},"1":{"v":"\n# 人们如何做出决策\n\n1. 人们面临权衡取舍\n   1. 社会面对的另一种权衡是效率和平等之间的取舍。效率（efficiency）是指社会从它的稀缺资源中获得最大收益。平等（equality）是说这些收益在社会成员之间平均分配。\n2. 某种东西的成本是为了得到它所放弃的东西\n   1. 机会成本（opportunity cost）是你为了得到它而放弃的其他东西\n3. 理性人考虑边际量\n   1. 理性人（rational people），在给定的可行选择前提下，有条理且有目的地尽自己所能来实现自己的目标\n   2. 理性人在决策时通常要比较边际收益（marginal benefits）和边际成本（marginal costs\n4. 人们会对激励做出反应\n\n# 人们如何相互交易\n\n5. 贸易可以使每个人的状况都变得更好\n   1. 贸易使得每个国家专业从事自己最擅长的产品的生产\n6. 市场通常是组织经济活动的一种好方法\n7. 政府有时可以改善市场结果\n   1. 政府出手的原因有两大类：促进效率或促进平等。也就是说大多数政策的目的，要么是扩大经济馅饼要么是改变馅饼的分割方法。\n\n# 整体经济如何运行\n\n\n8. 一国的生活水平取决于它生产物品与劳务的能力\n   1. 生产力（productivity）是指每单位劳动投入能生产的商品和服务数量。在生产力高的那些国家，大多数人都享有较高的生活水平；而在生产力低的国家，大多数人在贫困中挣扎\n9. 当政府发行了过多货币时，物价上升\n10. 社会面临通货膨账与失业之间的短期权衡取舍\n\n尽管在长期，较高的物价水平是由于货币数量增加引起的，然而短期的物价水平升高更为复杂和更富有争议。绝大多数经济学家是这样描述货币注入的短期效应的：\n- 经济中的货币量增加刺激支出总体水平提高，因此促进了商品和服务的需求。\n- 长时间较高的需求会促使企业提高商品价格，但与此同时，它也会激励企业多雇佣工人、多生产产品和服务\n- 多雇佣工人意味着低失业率\n\n\n根据这一推理过程可得到本章最后一个权衡，它是经济整体面临的权衡：通货膨胀和失\n业之间的短期权衡。","n":0.169}}},{"i":12,"$":{"0":{"v":"Writing","n":1}}},{"i":13,"$":{"0":{"v":"Story","n":1},"1":{"v":"\n故事是生活的比喻。\n\n# 故事设计术语\n\n\n**结构**是对人物生活故事中一系列事件的选择，这种选择将事件组合成一个具有战略意义的序列，以激发特定而具体的情感，并表达一种特定而具体的人生观。构思这些事件是为了什么？一个目的也许是为了表达你的情感，但如果这种表达不足以激发观众的情感，就变成了自我陶醉。第二个目的也许是为了表达你的思想，但如果观众跟不上你的想法，则会有孤芳自赏之嫌。\n\n**故事事件**创造出人物生活情境中富有意味的**变化**，这种变化是通过一种价值来表达和经历的。**故事价值**是人类经验的普遍特征，这些特征可以从此一时到彼一时，由正面转化为负面，或由负面转化为正面。例如，生 / 死（正面 / 负面）便是一个故事价值，同样的有爱 / 恨、自由 / 奴役、真理 / 谎言、勇猛 / 懦弱、忠诚 / 背叛、智慧 / 愚昧、力量 / 软弱、兴奋 / 无聊，等等。所有这种人类经验中，价值负荷可以随时走向反面的二元特质，便是故事价值。\n故事事件创造出人物生活情境中富有意味的变化，这种变化是用一种价值来表达和经历的，并通过冲突来完成\n\n**场景**是在某一相对连续的时空中，通过冲突表现出来的一段动作，这段动作至少在一个重要程度可以感知的价值层面上，使人物生活中负荷着价值的情境发生转折。理想的场景即是一个故事事件。没有不含转折的场景。如果一个场景不是一个真正的事件，就删掉它。\n\n在场景里面的便是最小的结构成分：**节拍**。节拍是动作 / 反应中一种行为的交替。这些变化的行为通过一个又一个节拍构筑了场景的转折\n\n**序列**是一系列场景 —— 一般两到五个，每一个场景的冲击力呈递增趋势，直到最后到达顶峰。\n\n一系列序列便构成下一个更大的结构，**幕**，一个表现人物生活中负荷价值情境里一个重大逆转的动态单位。幕是一系列序列的组合\n\n一系列幕便构成所有要素中最大的结构：故事。一个故事就是一个巨大的主事件。\n\n**故事高潮**：故事是一系列幕的组合，渐次构成一个最后的幕高潮，又称故事高潮，从而引发出绝对而不可逆转的变化。\n\n# 故事三角\n\n![](https://tczimg.s3.amazonaws.com/vscode/4daaaaee55184523b222ae9514810937.png)\n\n设计情节是指在故事的危险地形上航行，当面临无数岔道时选择正确的航道。情节就是作者对事件的选择以及对其在时间中的设计。因此，情节并不是指笨拙的纠葛、转折或高压的震惊和悬念。事件必须经过挑选，而且其设计型式必须通过时间上的排列来呈现。从“构思”或“设计”这个意义上而言，所有的故事都必须有情节编排。\n\n经典设计是指围绕一个主动主人公构建的故事，主人公为了追求自己的欲望，与主要来自外界的对抗力量进行抗争，通过连续的时间、在一个连贯而具有因果关联的虚构现实里，到达一个表现绝对、而变化不可逆转的闭合式结局。\n\n最小主义是指作者从经典设计的成分开始，对它们进行削减——对大情节的突出特性进行精炼、浓缩、删节或修剪。我把这一整套最小主义的变体称为小情节。小情节并不意味着无情节，其故事必须像大情节一样给予精美的处理。确切地说，最小主义的情节处理是要在简约、精炼的前提下保持经典的精华，使影片仍然能够满足观众，令他们走出影院时依旧暗自思忖：“多好的故事！”\n\n反情节是反小说（新小说）和荒诞派戏剧的电影翻版。反结构变体并没有削减经典，而是反其道而行，否认传统形式，以利用甚至嘲弄形式原理的要义。反情节的制造者对欲语还休的描写方法或暗度陈仓式的收敛几乎没有兴趣；相反，为了昭示他的“革命”雄心，他的影片倾向于过度铺陈和自我意识的大肆渲染。\n\n## 闭合式结局VS开放式结局\n\n大情节传达一种闭合式结局——故事提出的所有问题都得到了解答；激发的所有情感都得到了满足。观众带着一种完美收官的体验离开——没有疑虑，没有任何尚未阐明的东西。\n\n一个故事高潮如果留下一两个未解答的问题和一些没被满足的情感，则被称为开放式结局。\n\n## 外在冲突VS内在冲突\n\n大情节强调外在冲突。尽管人物常常具有强烈的内心冲突，但重点却落在他们与人际关系、社会机构或自然界力量的斗争上。相反，在小情节中，主人公也许与家庭、社会和环境具有强烈的外在冲突，但其重点却集结在他与自己思想情感有意或无意的角斗里。\n\n## 主动主人公VS被动主人公\n\n主动主人公在欲望追求中采取行动时，与他周围的人和世界发生直接冲突。\n\n被动主人公表面消极被动，而在内心追求欲望时，与其自身性格的方方面面发生冲突。\n\n## 线性时间VS非线性时间\n\n大情节开始于时间中的某一点，在大略连贯的时间中不无省略地运行，并终结于某一晚些的时日。如果影片采用了闪回，对闪回的处理也会让观众可以将故事的事件置于其时序里。另一方面，反情节却是不连贯的，将时序打乱或拆解，很难或不可能将发生的事件置于任何线性的时序之中。如果一个故事在时间中随意跳跃，从而模糊了时间的连续性，以致观众无从判断什么发生在前什么发生在后，那么这个故事便是按照非线性时间来讲述的。\n\n## 连贯现实VS非连贯现实\n\n连贯现实是确立人物及其世界之间互动模式的虚拟背景，在整个讲述过程中，这些互动模式一直保持着连贯性，从而创造出意义。非连贯现实是混合了多种互动模式的背景，其中故事章节不连贯地从一个“现实”跳向另一个“现实”，以营造出一种荒诞感。","n":0.177}}},{"i":14,"$":{"0":{"v":"Design","n":1}}},{"i":15,"$":{"0":{"v":"Scene","n":1},"1":{"v":"\n\n场景设计的各个组成部分：转折点、伏笔 / 分晓、情感转变和选择。\n\n# 转折点\n\n一个场景即是一个缩微故事 —— 在一个统一或连续的时空中，通过冲突而表现出来的、转折人物生活中负荷着价值的情境的一个动作。从理论上说，一个场景的长度或景点几乎没有任何限制。一个场景可以无限小。\n在每一个场景中，人物追求一个与其当前时空有关的欲望。不过，这个**场景目标**必须是他的超级目标或故事脊椎的一个方面。\n\n场景导致细微而又意义重大的变化。**序列高潮**是一个导致适中逆转的场景 —— 这种变化的冲击力要大于场景。幕高潮是一个导致重大逆转的场景 —— 这一变化的冲击力又大于序列高潮。因此，我们绝不会写一个平铺直叙，只是纯粹静态展示的场景；相反，我们都想努力达到这一理想：创造这样一个故事设计，让其中的每一个场景都成为一个细微、适中或重大的转折点。\n\n转折点的效果是四重的：惊奇、增加好奇心、见识和新方向。\n\n讲故事的人把我们引入期望之中，让我们以为自己一切都明白，然后将现实撕裂，制造惊奇和好奇，把我们一次又一次地往故事的前面部分送。\n\n讲故事就是许诺：如果你注意听我讲，我就给你惊奇，接下来便是发现生活的喜悦，在你从未想象过的层面和方向探知生活的喜怒哀乐。而且，最重要的是，这一切必须处理得那样轻松自然，以使观众不知不觉中就被引向了那些发现。一个漂亮的转折时刻起到的效果是，当观众突然获得了某种见解时，看起来就好像是他们自己做到了这一点。在某种意义上而言，他们也的确如此。见解是观众注意听故事所得到的奖励，而且一个设计漂亮的故事能够一个场景接着一个场景地激发出这种愉悦。我们最强有力的自我表达途径，就是我们转折故事的独一无二的方式。\n\n其次才是话语。我们生动而巧妙地运用我们的文学天才，于是，当写作精美的场景被演出时，观众会心悦诚服、满怀欣喜地随我们一起走过一个个转折点。语言固然重要，但它只是一个表象，我们通过它来捕捉读者，将他们带入故事的内在生活之中。语言是自我表达的工具，其本身绝不能成为一个装饰性的目的。\n\n# 伏笔和分晓\n\n为了一幕一幕地表达我们的视觉，我们将虚构现实的表皮破开，并把观众送到故事前面部分以获得见解。因此，这些见解必须以伏笔和分晓的方式进行构建。铺设伏笔是指，将知识一层一层铺垫好；分晓是指，将铺设的知识传达给观众以闭合鸿沟。当期望和结果之间的鸿沟把观众推到故事前面以寻找答案时，只有当作者预先在作品中准备了或埋植了这些见解时，观众才能找到。\n\n伏笔必须小心谨慎地处理。它们必须以这样的方式进行埋植：当观众第一次看到它们时，它们具有一种意义，但通过见解搜寻之后，它们却被赋予第二层更加重要的意义。事实上，一个单一的伏笔还可能具有隐藏于第三或第四个层面上的意义。\n\n伏笔必须埋植得足够牢固，当观众的记忆急速回溯时，他们还能找出那些伏笔。如果伏笔过于微妙，观众就会忽略其用意。\n\n一旦伏笔闭合了鸿沟，这一分晓又极有可能成为未来分晓的另一个伏笔。故事不同于生活，你可以随时回头对故事进行修补。你可以埋下一个看似荒谬的伏笔，并使它变得合乎情理。推理是第二位的，属于后创作范畴。想象是高于其他一切的第一位的先决条件 —— 你必须自愿地去想象任何疯狂的念头，让那些无论是否合乎情理的形象进入你的脑海\n\n# 情感转变\n\n我们是通过表现必要而精确的体验来促使观众在心中自然生出一种情感，然后带领观众经受那种体验。因为转折点不仅传达见解，它们还能创造出情感的动力。\n\n为了理解我们如何才能创造出观众的情感体验，我们首先必须明白，世上只有两种情感 —— 快感和痛感。每一种都有其不同程度的变异：前者如欢乐、爱情、幸福、狂喜、愉悦、销魂、刺激、极乐等等；后者有痛苦、害怕、焦虑、恐怖、悲伤、屈辱、萎靡、凄凉、紧张、悔恨等等。但是，在本质上，生活给予我们的只能是非此即彼\n\n作为观众，当故事的讲述过程带领我们经历一种价值的转变时，我们便会体验到一种情感。首先，我们必须移情于人物。其次，我们必须知道人物想要什么并希望他得到他想要的东西。第三，我们必须明白人物生活中，押上台面的价值。在这种情况下，一个价值的改变便能打动我们的情感。\n\n回报递减定理无论是在生活中还是在故事中，都同样成立：我们对某事的体验越多，它所产生的效果就会越少。换言之，情感体验若是来回重复，便不可能产生相应效果。\n\n在电影中，感情被称为基调。**基调是在影片的文本中创造出来的**：光和颜色的质量，动作和剪辑的速度，演员配置，对白风格，制作设计和音乐，这一切文本特性的总和创造出一种特定的基调。一般而言，基调就像伏笔一样，也是一种预示形式，准备或构建观众预期的方式。不过，当场景的动力一个瞬间接着一个瞬间地确定它所导致的情感到底是正面还是负面时，基调便使这种情感变得具体。场景、序列或幕的弧光决定了基本情感。基调使它具体化。但是，基调不能取代情感。\n\n# 选择\n\n人物在追求欲望的过程中会在压力之下选择采取一个或另一个行动，转折点则是以这种压力之下的选择为中心的。人类的本性决定了，我们每一个人永远会选择“善”，只要我们能够感知到“善”。除此之外，绝无其他可能性。如果一个人物被置于必须在明确的善和明确的恶之间，或在是与非之间做出选择的情境中，那么，观众由于明白人物的视点，将会提前知道人物将会如何选择。\n\n善恶或是非之间的选择根本不是什么选择。\n\n**真正的选择是两难之择**。它发生于两种情境。一是不可调和的两善取其一的选择：从人物的视点来看，两个事物都是他所欲者，他两者都要，但环境迫使他只能二选一。二是两恶取其轻的选择：从人物的视点来看，两个事物都是他所不欲者，而且他一个也不想要，但环境迫使他必须二者择一。在这种真正的两难之境中，一个人物如何选择便是对其人性以及他所生活的世界的一个强有力的表达。\n\n对立两方的冲突并不是两难之境，而只是正面和负面之间的摇摆。\n\n为了构建和创造真正的选择，我们必须勾勒出一个三面的框架。就像在生活中一样，有意义的决定都是涉及三方的。三角设计带来了结局。如果一个故事讲述只涉及两方，那么 A 只能在 B 和非 B 之间徘徊，结局是开放的。但是，如果选择是三方的，那么， A 就会在 B 和 C 之间取舍。 A 对一个或另一个的选择便可以提供一个满意的闭合式结局。无论 B 和 C 是代表两恶之轻还是不可调和的两善，主人公不可能二者兼有。而且还必须付出代价，为了得到一个，则必须损害或失去另一个。例如，如果 A 为了得到 B 而放弃 C ，那么观众便会感到，他做出了一个真正的选择。 C 被牺牲掉，而且这一不可逆转的变化便结束了故事。\n\n一部具有独创性的作品会展示独一无二而又不可调和的欲望之间的选择。这种选择可以是两个人之间，可以是一个人和一种生活方式之间，可以是两种生活方式之间，也可以是一个内心自我的两个方面之间 —— 亦即作家可能创造出来的，无论是想象的还是真实的，任何冲突层面上的任何冲突的欲望之间。但是，其原理是共通的：选择绝不是疑惑而必须是两难，绝不是处于是非或善恶之间，而必须是处于具有同等分量或价值的两种正面欲望或两种负面欲望之间。","n":0.149}}},{"i":16,"$":{"0":{"v":"Role","n":1},"1":{"v":"\n# 主人公\n\n一般而言，主人公是一个单一的人物。由两个或两个以上人物构成一个复合主人公，必须达到两个条件：第一，群体中的所有个体必须志同道合，共有同一个欲望；第二，在为了满足这一欲望的斗争中，他们必须同甘共苦，同舟共济，一荣皆荣，一损俱损。在一个复合主人公之内，动机、行为和结果都是共通的。\n\n另一方面，一个故事也可以是一个多重主人公。与复合主人公不同的是，这里的人物具有各自不同的欲望，各谋其利，各承其害。\n\n不过，无论故事的主人公是单一、多重还是复合，无论其人物塑造特征如何，所有的主人公都具有某种标志性特质，而其中的首要特质便是意志力。**主人公是一个具有意志力的人物**。其他人物也许冥顽不化，甚至麻木不仁，但主人公必须是一个具有意志力的人。\n\n主人公必须具有**自觉的欲望**。确切而言，主人公的意志驱动一个已知的欲望。主人公具有一个需要或目标，一个欲望对象，而且对此有清楚自知。如果你可以把你的主人公拉到一旁，在他耳边悄声问：“你需要什么？”他应该能明确回答：“我今天想要 X ，下周想要 Y ，但我最终要的是 Z 。”\n\n主人公还可以有**一个自相矛盾的不自觉欲望**。不过，最令人难忘、痴迷的人物往往不仅只有一个自觉的欲望，还会有一个不自觉的欲望。尽管这些复杂的主人公不知道其潜意识的需要，但观众却对此有所感知，并能察觉出他们的内心矛盾。一个多维度主人公的自觉和不自觉的欲望通常是互相矛盾的。他相信他所需要的东西与他实际上需要而自己并未觉察的东西相互对立。这是不言自明的。如果一个人物的潜意识欲望碰巧即是他所明确追寻的东西，那么这个潜意识欲望的设置便毫无意义。\n\n主人公**有能力令人信服地追求其欲望对象**。主人公必须至少有一次机会达成欲望。主人公有意志和能力追求其自觉和 / 或不自觉的欲望，一直到线索的终点，一直到背景和类型所确立的人类极限。故事必须构建出一个最后动作，让观众无从想象出另一个更好的可能。\n\n主人公必须具有**移情作用**。移情是指“像我”。在主人公的内心深处，观众发现了某种共通的人性。当然，人物和观众不可能在各方面都相像；他们也许仅仅共享一种素质。但是人物的某些东西能够拨动观众的心弦。在那一认同的瞬间，观众突然本能地希望主人公得到他所欲求的一切。\n\n观众的情感投入是由移情作用而黏合的。如果作者未能在观众和主人公之间接上一根纽带，那么我们就会坐在影片之外，感觉不到任何东西。情感投入与是否能唤起博爱和同情毫无关系。\n\n## 第一步\n\n当你坐下来写作时，冥思便开始了：“如何开始？我的人物该做什么？”\n你的人物，实际上所有的人物，在追求任何欲望的过程中，在故事的任何时候，总是会采取从他自己的主观视点来看最小的保守行动。人性从根本上而言都是保守的，实际上这是大自然的规律。任何有机体都只会去消耗必要的能量，绝不会冒不必要的风险或采取不必要的行动。\n\n故事和生活之间的重大差异是：在人类的日常生存状态中，人们采取行动时总是期望得到世界的某种有效反应，而且总能或多或少地得到他们所期望的东西，而在故事中，**这些日常生活的细枝末节则被扬弃**。在故事中，我们将精力集中于那一瞬间，且仅仅是那一瞬间，**人物在那一瞬间采取行动**，期望他的世界做出一个有益的反应，但其行动的效果却是**引发出了各种对抗力量**。人物的世界所做出的反应要么与他的期望大相径庭，要么比他期望的反应更为强烈，要么二者兼有。\n\n## 个人世界\n\n![](/assets/images/2022-03-19-10-16-06.png)\n\n一个人物的世界可以被想象为一系列同心圆，围绕着一个由本真身份或本真知觉所构成的圆心，这些圆标志着人物生活的各个冲突层面。最里面的圆或层面便是他的自我以及产生于其头脑、身体和情绪等自然要素的各种冲突。\n\n第二个圆表示个人关系，那种比社会角色更深层的亲密联盟。社会常规为我们分派了所扮演的外在角色。\n\n第三个圆标志着个人外冲突层面 —— 超出个人之外的所有对抗力量源：与社会机构和社会个体的冲突 —— 政府 / 公民、教会 / 教民、公司 / 客户；与个体的冲突 —— 警察 / 罪犯 / 受害人、老板 / 员工、顾客 / 服务员、医生 / 病人；以及与人为环境和自然环境的冲突 —— 时间、空间及其中的每一个物体。\n\n## 鸿沟\n\n主人公追寻一个不可企及的欲望对象。他自觉或不自觉地选择采取某一特定的行动，其动机来自这样的想法或感觉：这一行动将会导致世界做出相应的反应，从而成为达成其欲望的一个积极步骤。从这一主观的视点来看，他所选择的动作似乎是最小的、保守的，但足以产生他所需要的反应。但在他采取这一行动的瞬间，其内心生活、个人关系、个人外世界或这一切组合而成的客观领域，会做出一个与他的期望大相径庭或比他的期望更为强烈的反应。\n\n来自他世界的这一反应阻挡了他的欲望，使他遭受挫折，比在采取行动之前还要离欲望更远。他的行动不仅没有引出他的世界的合作，反而激发了诸多对抗力量，在其主观期望和客观结果之间、在他采取行动时以为会发生的事情和实际发生的事情之间，在他的或然性感觉和真正的必然性之间，开掘出一道鸿沟。\n\n![](/assets/images/2022-03-19-10-19-28.png)\n\n每一个人从此一时到彼一时采取的行动，都是自觉或不自觉地依据他对或然性的感觉，依据他期望在他采取行动时极有可能发生的情况而定的。\n\n我们还相信，我们可以自由地做出任何决定，采取任何行动。但是，我们所做出的每一个选择，采取的每一个行动，无论是自发的还是故意的，都植根于我们经验的总和，植根于迄今为止在现实中、在想象中或者在梦中发生在我们身上的东西。这一生活的积累告诉我们，来自我们世界的或然反应将会是什么，我们便据此来选择采取行动。也只有在当时，在我们采取行动的当时，我们才能发现其必然性。\n\n**必然性才是绝对的真理**。它是我们采取行动时实际发生的事情。只有当我们采取行动，广泛而深入地进入我们的世界并勇敢地面对其反应时 —— 而且也只有在这种时候，我们才能知道这一真理。这一反应便是在那一瞬间关于我们生存状态的真理，无论我们过去曾相信那一瞬间的情况应该如何。必然性是必须而且实际发生的东西，它与或然性是相对的，后者是我们希望或期望发生的东西。\n\n人物欲望的价值尺度与他为达成欲望而愿意承担的风险成正比；价值越大，风险便越大。\n\n![](/assets/images/2022-03-19-10-21-40.png)\n\n主人公的第一个行动已经激发了对抗力量，阻挡了其欲望的实现并在预期和结果之间横亘了一道鸿沟，挫败了他对现实的幻想，使他与其世界处于一种更大的冲突之中，并把他推向了更大的风险。但是坚韧不拔的人类大脑会迅速对现实进行重塑，将其模式放大，以包容这一挫败，即这一始料未及的反应。现在，他必须采取第二个行动，一个更困难更冒险的行动，一个与其变更了的现实观相一致的行动，一个基于他对世界的新期望的行动。但是，他的行动又一次激发对抗力量，在他的现实中裂开又一道鸿沟。所以他进行调整以适应这一意外，再一次加大赌注，并决定采取一个他觉得与其修改了的世界观相一致的行动。他更深地挖掘自己的潜能和意志力，使自己冒着更大的风险来采取第三个行动。\n\n期望和结果之间的鸿沟远远不只是因果关系的问题。从最深层的意义上而言，表面的原因和最终的结果之间的这一断裂，标志着人类精神和客观世界的交接点。一边是我们主观相信的世界，而另一边则是客观存在的现实。这一鸿沟便是故事的温床，是一口熬煮故事讲述手法的大锅。作家正是从中找到最有力度的生活转折瞬间。我们能够到达这一决定性交接点的唯一办法，就是从里面工作到外面。\n\n## 情感\n\n一个至关重要的维度我们却无法创造出来，这就是情感真理。情感真理唯一可靠的源泉就是你自己。如果你停留在人物的表面，将会不可避免地写出情感的陈词滥调。为了创造具有启迪意义的人类反应，你不但必须进入人物的内心，而且还要进入自己的内心。那么，怎样才能做到这一点？当你坐到写字台前时，怎样才能爬进你人物的脑子，感觉到自己的心跳、手心出汗、肚肠扭结、热泪盈眶、内心欢笑、性欲冲动、愤怒、暴躁、同情、悲哀、快乐或人类情绪图谱上不可胜数的各种反应中的任意一种。\n\n你已经决定某一特定的事件必须在你的故事中发生，一个将要进展和转折的情境。如何写出一个富有见地的情感场景？你可以问：一个人应该如何采取这一行动？但是，那容易导致陈词滥调和道德分析。或者你还可以问：一个人可能会如何处理这个动作？但这容易写成“花边”文章 —— 精巧有余而诚信不足。\n\n你问：“如果我是这个人物，在这种情况下，我会怎么做？”采用斯坦尼斯拉夫斯基的“魔术般的如果”，你会去扮演这个角色。","n":0.154}}},{"i":17,"$":{"0":{"v":"Bad_guy","n":1},"1":{"v":"\n反面人物塑造原理：主人公及其故事的智慧魅力和情感魄力，必须与对抗力量相适应。\n\n人性从根本上而言是保守的。我们绝不会去做不必要的事情，绝不会耗费不必要的能量，绝不会去冒不必要的风险，绝不会去做不必要的改变。\n\n因此，什么东西将会使一个主人公变成一个完全充分展现与发展的、多层面的，并具有高度移情作用的人物？什么东西将会把一个没有生命力的剧本激活？这两个问题的答案，存在于故事的负面。反对主人公的对抗力量越强大越复杂，人物和故事必定会发展得越充分。\n\n# 价值\n\n首先是矛盾价值，正面的直接对立。在这种情况下，则是非正义。有人犯了法。然而，在正面价值和矛盾价值之间还有相反价值：一种既有些许负面而又并非完全对立的情境。正义的相反价值是不公平，一种负面而又不是非法的情境：裙带关系、种族主义、官僚拖延、偏见，以及各种各样的不平等。不公平的肇事者们也许并没有违犯法律，但是他们既非正义也不公平。\n\n然而，相反价值也并不是人生体验的极致。在线索的终点还横卧着负面之负面（否定之否定），一种具有双重负面性的对抗力量。\n\n![](/assets/images/2022-03-20-22-07-59.png)\n\n一个在冲突的深度和广度上进展到人生体验极限的故事，必须依循以下型式来运行：这一型式必须包括相反价值、矛盾价值和否定之否定价值\n\n![](/assets/images/2022-03-20-22-08-55.png)\n\n![](/assets/images/2022-03-20-22-10-13.png)\n\n如果你的故事貌似令人满意但总觉有所欠缺，那么则需要找到恰当的工具洞穿其迷惑之处，找出它的瑕疵。一个故事虚弱时，不可避免的导因就是其对抗力量过于软弱无力。与其殚精竭虑试图发明主人公及其世界的可爱和迷人之处，不如构筑一道负面之墙，创造出一个连锁反应，自然而真实地作用于正面价值。\n\n第一步就是询问押上台面的价值及其进展过程。正面价值是什么？哪一个最卓著，足以转折故事高潮？对抗力量是否探究了负面性的所有层面？它们是否在某一个点上达到了负面之负面的力度？\n\n一般而言，进展过程在第一幕中从正面价值运行到相反价值，并在随后各幕中运行到矛盾价值，在最后一幕中最终运行到负面之负面，要么以悲剧告终，要么回到具有深刻差异的正面价值。","n":0.707}}},{"i":18,"$":{"0":{"v":"Peak","n":1},"1":{"v":"\n故事高潮是五部分结构的第四部分。这一登峰造极的重大逆转并不一定充满着噪音和暴力。相反，它必须充满意义。\n\n意义：从正面到负面，或者从负面到正面，或者有反讽或无反讽的价值剧变 —— 当价值处于最大负荷时所发生的绝对而不可逆转的价值摇摆。这一变化的意义便可以打动观众的心。\n\n最后一幕的高潮是你想象力的大跃进。没有它，你就没有故事。直到你实现这一点之前，你的人物都像是正在祈祷等待良医疗救的痛苦病人。\n\n如果逻辑许可，可以在主情节的高潮之内使次情节达到高潮。\n\n所有故事结局的关键就是给予观众他们想要的东西，但不是通过他们所期望的方式。\n\n首先，观众究竟想要什么？许多制片人都不假思索地说，观众想要的就是一个大团圆结局。他们之所以这样说，是因为上扬结局的影片要比低落结局的影片更赚钱。其原因是，一小部分观众不会去看一部可能会给他们带来不快体验的影片。一般而言，他们的借口是，生活中的悲剧已经够多的了。但是，如果我们仔细观察，我们会发现，他们不仅会在电影中回避负面情感，在生活中也回避。这种人认为，幸福意味着永无痛苦，所以他们对任何东西都不会去追求深刻感受。我们快乐的深度和我们所经受的苦难是成正比的。\n\n事实上，低落结局的影片常常获得巨大的商业成功。观众所需要的是情感的满足 —— 一个满足预期的高潮。\n\n用亚里士多德的话说，一个结局必须同时是“不可避免而又出乎意料”的。不可避免是因为，由于激励事件的发生，一切事情和任何事情似乎都成为可能，但在高潮处，当观众回溯讲述过程时，在他们看来，讲述过程所采取的路径似乎应该是唯一的路径。以我们所了解的人物及其世界，高潮便是不可避免和令人满足的。但与此同时，它必须是出人意料的，以一种观众不可能预期的方式发生。\n\n一个艺术家则会给予我们他所许诺的情感 …… 但是伴随着一种出人意料的见解，因为作者会一直把这种见解掩藏，直到高潮本身中的一个转折点。所以当主人公临时做出最后努力时，他可能会，也可能不会达成自己的欲望，但从鸿沟中喷涌而出的那种见解洪流却能传达一种观众所希望的情感，以一种我们绝不可能预见的方式。\n","n":0.378}}},{"i":19,"$":{"0":{"v":"Event","n":1},"1":{"v":"\n故事是一个由五部分组成的设计：激励事件，故事讲述的第一个重大事件，一切后续情节的首要导因，它使其他四个要素开始运作起来 —— 进展纠葛，危机，高潮，结局。为了了解激励事件如何进入作品并在其中发挥作用，让我们再回过头来更加全面地看一看背景 —— 激励事件所发生的物质和社会世界。\n\n# 故事中的世界\n\n1. 我的人物靠什么为生？我们生命三分之一以上的时间都是用在工作上，但在影片中却很少看到人们工作的场景。其原因很简单：大多数工作都是乏味的。对干工作的人来说，也许并不乏味，但观看他们工作却是一件乏味的事情\n2. 我的世界的政治是什么？这里的所谓政治不一定是指右翼 / 左翼、共和党 / 民主党那样的政治，而是指这一概念的真正含义：权力。政治是我们给予任何社会中权力分配的名称。人类只要聚集在一起做事，就永远会有权力分配的不平衡\n3. 我的世界的仪式是什么？在世界的各个角落，生活都包裹在仪式之中\n4. 类型或类型组合是什么？有什么常规？就像背景一样，类型为作家设定了诸多创作限制，对此作家要么忠实恪守，要么巧妙变更。\n5. 我的人物的履历是什么？从他们出生的那天起，一直到开篇场景，生活是如何塑造他们的？\n6. 幕后故事是什么？\n7. 我的角色设计是什么？每一个角色都必须适用于一个目的，而角色设计的首要原理就是两极分化。在不同的角色之间，我们编织出一张弥漫着对立或矛盾态度的网。\n\n\n## 激励事件\n\n一个在任何意义上都堪称决定性的事件发生了，彻底地打破了这种平衡，将主人公生活现实中的价值负荷钟摆推向负面或正面。\n![](/assets/images/2022-03-19-10-33-34.png)\n\n主人公必须对激励事件做出反应。因此，激励事件首先要打破主人公的生活平衡，然后在他心中激起恢复那一平衡的欲望。出于这种需要，主人公的下一步行动，通常是非常迅速地，偶尔也深思熟虑地，构想出一个欲望对象：一种物质的、情境的或观念的东西，而这正是他觉得要使生活航船稳步航行所缺乏或需要的东西。最后，激励事件推动主人公去积极追求这一对象或目标。对许多故事或类型而言，这便已经足够了：一个事件把主人公的生活推向混乱，激发起一个自觉的欲望，使他力图找寻他觉得能够整饬这种混乱的东西，并为得到它而采取行动。\n\n![](/assets/images/2022-03-19-10-34-51.png)\n\n## 故事脊椎\n\n主人公欲望的能量形成了故事设计中一个被称为故事脊椎的重要成分（又叫贯穿线或超级目标）。脊椎是主人公为恢复生活的平衡所表现出的深层欲望和所进行的不懈努力。它是第一位的统一力量，将故事的所有其他要素融为一体。\n\n![](/assets/images/2022-03-19-10-35-59.png)\n\n然而，如果主人公有一个不自觉的欲望，那么这个不自觉欲望便会成为故事的脊椎。不自觉欲望总是更强烈、更持久，其根基一直扎进主人公的内心。当不自觉欲望驱动故事时，它将允许作者创造出一个更为复杂的人物，他可以不断改变其自觉欲望\n\n![](/assets/images/2022-03-19-10-39-26.png)\n\n## 求索\n\n从本质上而言，我们从人类的黎明开始就这样或那样互相讲述的都是同一个故事，这个故事可以不无裨益地统称为求索故事。所有的故事都表现为一个求索的形式。一个事件打破人物生活的平衡，使之或变好或变坏，在他内心激发起一个自觉和 / 或不自觉的欲望，意欲恢复平衡，于是把他送上了一条追寻欲望对象的求索之路，一路上他必须与各种（内心的、个人的、个人外的）对抗力量抗衡。他也许能也许不能达成欲望。这便是亘古不变的故事要义。\n\n![](/assets/images/2022-03-19-10-40-30.png)\n\n## 激励事件的设计\n\n激励事件的发生无非通过下述两种方式之一：随机或有因，要么由于巧合，要么出于决定。若出于决定，那么这一决定可以由主人公来做出。如果是由于巧合，可以是天降横祸型，也可以是天赐洪福型。抉择或巧合，二者必居其一；舍此，便别无他途。\n\n主情节的激励事件必须发生在银幕之上 —— 不能发生在幕后故事之中，也不能发生在银幕之外的场景之间。当观众经历一个激励事件时，影片的戏剧大问题，诸如“这件事的结果将会如何”之类的问题，就会在脑海中涌现。亲眼目睹激励事件的发生，能在观众的想象中投射出必备场景的形象\n\n激励事件的定位在故事的总体设计中，应该把激励事件置于何处？根据行家的经验，主情节的第一个重大事件必须在讲述过程的前四分之一时段内发生。应该把主情节的激励事件尽快引入 …… 但务必等到时机成熟。\n\n激励事件的质量（严格说来，任何事件的质量）必须与世界、人物及其类型密切相关。事件一旦构思完成，作者必须将精力集中于它的功能。激励事件能否彻底打破主人公生活中各种力量的平衡？它能否激起主人公恢复平衡的欲望？它能否在心中激发出那一自觉的欲望，令其求索那一他认为能够恢复平衡的欲望对象 —— 无论是物质的还是非物质的。在一个复杂主人公心中，它是否还会激活一个不自觉的欲望，与其自觉的需要发生矛盾？它能否将主人公送上一条达成欲望的求索之路？它能否在观众脑中提出那一戏剧大问题？它能否投射出必备场景的影像？如果它能够做到这一切，那么它便可以小到一个女人把手放在桌子上，以“那种特别的方式”看着你\n\n## 如何创造\n\n最后一幕的高潮是所有场景中创作难度最大的：它是故事讲述的灵魂。如果它失败，整个故事终将失败。但是，写作难度居其次的则是主情节的激励事件。这个场景的改写率在所有场景中是最高的。所以，我在此提出一些问题，对激励事件的构思应该能有所助益。\n\n可能发生在主人公身上最坏的事情是什么？那一事件如何才能最终成为可能发生在主人公身上最好的事情？\n\n一个故事可以按照这一形式循环不止一圈。最好是什么？如何变成最坏？如何再次逆转，成为主人公的重生？或者：最坏是什么？如何变成最好？最后如何再次导致主人公的毁灭？我们之所以总是在“最好”和“最坏”之间伸展，是因为故事若要成为艺术，并不是讲述人类体验的中间地带。激励事件的冲击给我们创造了到达生活极限的机会。它是一种爆炸。\n","n":0.183}}},{"i":20,"$":{"0":{"v":"End","n":1},"1":{"v":"\n结局作为五部分结构的第五部分，是高潮之后所残留的任何材料，它有三种可能的用途。\n\n第一，故事讲述逻辑也许并没有提供一个机会来使次情节在主情节的高潮之前或之中达到高潮，所以它在故事的末尾需要一个属于它自己的场景。不过，这样做容易显得笨拙。故事的情感中心是在主情节中。而且，观众会想离开，但被迫坐下来看完这一不太感兴趣的场景。\n\n结局场景的第二个用途是，展示高潮效果的影响所及。如果一部影片通过向社会横向发展来表达其进展过程，那么其高潮也许会局限于它的主要人物，但是，观众已经知道许多配角人物的生活也会为这一高潮动作所改变。这便会引发一个社会事件，以满足我们的好奇心，使所有的人物都在同一景点亮相，利用跟拍镜头来向我们展示他们的生活发生了怎样的变化。\n\n即使前面两种用途都不适用，所有的影片都需要一个结局场景以表示对观众的尊重。因为，如果高潮已经打动观众，如果他们笑得不能自禁，被恐惧惊呆，充满着一种社会义愤，还在擦拭眼泪，那么银幕突然变黑，片尾字幕开始滚动，将是非常不礼貌的。在剧本的最后一页加上一行描写，把镜头慢慢送回或者跟拍几秒钟的形象，好让观众喘口气，定定神，从容得体地离开影院。\n\n","n":1}}},{"i":21,"$":{"0":{"v":"Crisis","n":1},"1":{"v":"\n危机是五部分结构的第三部分。**它是指决定**。人物每次张嘴说“这个”而不说“那个”时，都是在做出自发的决定。在每一个场景中，他们都做出一个决定采取一个行动而不是另一个行动。但是大写的危机却是一个终极决定。汉语中的表意文字“危机”实为两个概念：危险 / 机会 ——“ 危险”是因为在这千钧一发的时刻，一个错误决定将会使我们永远失去想要的东西；**“机会”是因为正确的选择将会使我们如愿以偿**。\n\n主人公的求索之路引导他通过进展纠葛，直到他用尽了能实现欲望的所有行动，只剩最后一个尚未完成。他现在发现自己已经到达故事主线的终点。他的下一个行动将会是他的最后行动。没有明天，没有第二次机会。这一“危险机会”的时刻是故事中最紧张的点，因为无论主人公还是观众都感觉到，“结果将会如何”这一问题将会由下一个行动得到回答。\n\n危机是故事的必备场景。从激励事件开始，观众就一直在期待这一场景，越来越热切地企盼着主人公与他生活中最强大、最集中的对抗力量进行面对面的斗争。\n\n危机必须是真正的两难之境 —— 是不可调和的两善之间或两恶之轻的选择，或同时面临两种情况的选择，将主人公置于生活中最大的压力之下。这一两难之境摆在主人公面前，当他与他生活中最强大、最集中的对抗力量进行面对面的斗争时，他必须做出一个决定，要么采取此一行动，要么采取彼一行动，为赢得自己的欲望对象做出最后的努力。\n\n主人公选择采取的那一行动成为故事的终极事件，将导致一个正面的、负面的，或者具有反讽意义的正面 / 负面的故事高潮。不过，当主人公采取高潮行动时，如果我们再一次撬开期望和结果之间的鸿沟，如果我们还能再一次割裂或然性和必然性 1 ，那么我们可能会创造出一个辉煌的结局，令观众铭记终身。因为一个构建于转折点周围的高潮是一种最令人满足的体验。\n\n高潮的位置取决于高潮动作的长度。一般而言，危机和高潮都是在最后的时刻才发生的，而且发生在同一场景。\n\n危机决定必须是一个有意而为的静态时刻。这是一个必备场景。不要把它放置在画外，或者对它轻描淡写。观众想要与主人公一起经受这一两难之境的痛苦。我们之所以要使这一刻定格，是因为最后乐章的节奏取决于这一时刻。情感的洪流已经汇集到这一点上，只是危机的大坝将它阻隔。当主人公做决定时，观众会欠起身子，自问：“他将会怎么办？他将会怎么办？”紧张不断加剧，然后当主人公做出行动选择时，那一被压缩的能量便会爆发为高潮。\n\n","n":0.302}}},{"i":22,"$":{"0":{"v":"Conversation","n":1},"1":{"v":"\n# 对白\n\n设计故事和人物所付出的一切创造性劳动，最终还必须在稿纸上得到体现。本章将探讨文本，即对白和描写，以及指导写作的手艺\n\n对白不是对话。\n\n首先，银幕对白要求压缩和简约。银幕对白必须以最少的词句表达最多的内容。第二，它必须具有方向。对白的每一次交流都必须将场景中的节拍向一个或另一个方向转折，表达出变化的行为，而且没有重复。第三，它应该具有目的。每一行台词或对白的交流都要执行设计中的一个步骤，使场景围绕其转折点构建并形成弧光。这一切严密的设计，听起来又必须像日常谈话，采用非正式和自然的词汇，充满俗话俚语，必要的话，甚至还可以用脏话。正如亚里士多德所忠告的：“言如常人，思若智者。”\n\n记住，电影不是小说，对白说完就过去了。如果话语在离开演员之口的那一刻还不能让人明白，恼怒的观众会马上嘀咕：“他说什么？”电影也不是戏剧。电影是看的，戏是听的。电影美学百分之八十属于视觉，百分之二十属于听觉。我们想要看，而不是去听，由于我们的能量都集中于眼睛，对其声音仅仅是半听。戏剧是百分之八十的听觉，百分之二十的视觉。我们的注意力是集中在耳朵，对舞台只是半看。戏剧作家可以编织精巧而华丽的对白 —— 但银幕剧作家却不能。银幕对白要求结构简单的语句 —— 一般而言，语序应为主语、谓语和宾语或者主语、谓语和补语。\n\n## 长话短说\n\n银幕对白的精髓就是古典希腊戏剧中被称为 stikomythia 的东西 —— 简短对白的快速交流。大段对白和电影美学是对立的。把长段对白分解成动作 / 反应的型式，用以构建说话人的行为。用默默的反应把对白分割成片断，让说话者改变节拍。\n\n## 悬念句\n\n优秀的电影对白倾向于采用掉尾句来构建：“如果你不想让我干，那你为什么要给我那个 ……” 眼神？枪？吻？掉尾句就是“悬念句”。其语义被延缓到最后一个字，迫使演员和观众听到台词的末尾。再读一遍彼得 · 谢弗上面的精彩对白，你会注意到几乎每一行台词都是一个悬念句。\n\n## 无言的剧本\n\n写作电影对白的最好忠告就是不写。只要能够创造出一个视觉表达，就绝不要写对白。写作每一个场景需要攻克的第一道难关应该是：我如何才能以一种纯视觉的方式写出这个场景，而并不要诉诸对白？遵循回报递减定理：你写出的对白越多，对白的效果就会越小。如果你连篇累牍的全是讲话，让人物走进房间，在椅子上坐下，不停地说呀说呀说，精美的对白时刻就会被掩没在这些雪崩般的话语中。但是，如果你为眼睛而写作，当对白在必须出现的时候到来时，它就会激发兴趣，因为观众已经在饥渴地等着它。凸现于大片视觉形象中的简约对白更具有力度和分量。\n\n形象是我们的第一选择，对白是令人遗憾的第二选择。对白是我们加在剧本上的最后一个层面。不要搞错，我们都喜欢精彩的对白，但是，少即是多。当一部高度形象化的影片转入对白时，观众会豁然兴奋，洗耳恭听。\n\n# 描写\n\n银幕的本体论是处于连续不断的生动运动之中的绝对现在时。我们用现在时来写银幕剧本是因为，和小说不同，电影处于现在的刀锋上 —— 无论是闪回还是闪进，我们都会跳跃到一个新的现在中。而且银幕表达是不间断的动作。即使是静止的镜头也有一种生动感，因为，尽管形象也许不动，观众的眼睛却在银幕上不停地运动，赋予静止形象以活力。而且，和生活不同的是，电影是生动的。我们的日常事务也许偶尔会为窗外的浮光掠影、商店橱窗的花朵或人群中一个女人的脸所打断。但当我们走过我们的生命历程时，我们更多地是把自己藏在脑海里，对外面的世界只是半视半听。然而银幕，却是一连两个多小时从不间断地活灵活现。\n\n在稿纸上，生动性来源于事物的名称。名词是物体的名称；动词是动作的名称。要生动写作，应回避采用泛指名词和带修饰语的动词，努力寻找事物的具体名称","n":0.213}}},{"i":23,"$":{"0":{"v":"Context","n":1},"1":{"v":"\n解说是指事实 —— 有关场景、人物经历和人物塑造的信息，观众需要了解这些信息才能跟上并理解故事的事件。\n\n“展示，不要告诉”这一著名的原理便是问题的关键。千万不要将话语强行塞入人物的口中，令他们告诉观众有关世界、历史和人物的一切。而是要向我们展示出诚实而自然的场景，其中的人物以诚实而自然的方式动作言谈 …… 而与此同时，却间接地将必要的事实传递给观众。换言之，将解说戏剧化。\n\n戏剧化的解说能达到两个目的：首要目的是推进直接冲突，次要目的是为了传达信息。急于求成的新手会颠倒这一顺序，将解说职能置于戏剧必要性之前。\n\n为了将解说戏剧化，我们可以采用这一助记原理：把解说转化为弹药。你的人物对他们自己的世界、他们自己的历史、他们彼此之间的关系以及他们本人，都十分了解。让他们把自己所知道的东西用作弹药来进行斗争，以得到他们想要的东西。\n\n**只需披露观众绝对必需而且想要知道的解说信息**，仅此而已。\n\n遵从亚里士多德的忠告，从“事情的中间”开始讲故事。在确定了主人公生活中高潮事件的日期之后，我们便尽量贴近这个时间开始我们的故事。这种设计压缩了故事讲述的期限，并延长了在激励事件发生之前人物的生活经历\n\n# 使用幕后故事\n\n我们只能采用以下两种方法之一来转折场景：要么通过**动作**，要么通过**揭示**。舍此，别无他法。\n\n强有力的揭示来自幕后故事 —— 人物以前生活中的重大事件，作者可以在危机时刻来披露这些事件，以此创造转折点。\n\n## 闪回\n\n闪回不过是另一种形式的解说。就像其他一切因素一样，这种手法也是用好即好，用坏即坏。换言之，与其用冗长、毫无动机而且充满解说的大段对白来令观众厌倦，倒不如用毫无必要、索然寡趣而且充满事实的闪回来令观众厌烦。或者我们可以把它用好。如果我们遵循常规解说的严格规则，闪回便可以创造奇迹。\n\n首先，将闪回戏剧化。与其闪回到过去平淡的场景，不如在故事中插入一个微型剧，其中有它自己的激励事件、进展过程和转折点\n\n第二，不要采用闪回，除非你已经在观众中创造出想要知道的需要和欲望\n\n## 蒙太奇\n\n在美国人的语汇中，蒙太奇这个术语是指一系列快速剪接的形象，它们可以从根本上浓缩或扩展时间，而且常常采用光学效果，如划出、圈入、分裂银幕、渐隐或其他多画面手法。这种序列的高度能量被用于掩盖其目的：传达信息这一颇为世俗的任务。就像梦境序列一样，蒙太奇的采用也不失为一种努力，它可以通过忙碌观众的眼睛来减轻非戏剧化解说的乏味程度。除了个别特例之外，蒙太奇只不过是一种懒惰的企图，试图用装饰性摄影和剪辑来取代戏剧化展示，因此必须尽量避免采用\n\n## 画外音解说\n\n画外音解说又是另一个披露解说信息的方法。就像闪回一样，它同样用好即好，用坏即坏。对画外解说的检验是这样的：问你自己，“如果我将画外解说从剧本中删除，故事是否还能讲好？”如果答案是肯定的，那么就将它留在画内。一般而言，“少即是多”的原理通常适用于此：技巧越少，效果越强烈。因此，任何可以删除的都应该删除。不过，也有特例。如果画外解说可以删除，而且故事还能自圆其说，讲得很好，那么你之所以还要采用画外解说，唯一合理的原因就是可以将它用作对照或衬托。","n":0.302}}},{"i":24,"$":{"0":{"v":"Connect","n":1},"1":{"v":"\n布局谋篇是指对场景进行整合和连接。\n\n# 进度\n\n如果我们慢慢地转动螺丝，一点一点地，一点一点地，一个场景接着一个场景地，一个场景接着一个场景地增加其紧张度，那么远在影片结束之前我们就会把观众的兴致耗尽了。观众会变得疲软，再也没有精力投入到故事高潮之中。因为故事是生活的比喻，我们期望它感觉就像生活，具有生活的节奏。这一节奏在两个相互矛盾的欲望之间脉动：一方面，我们欲求恬静、和谐、和平和轻松，但是日复一日，这种东西如果太多的话，我们就会倦怠无聊，并需要进行心理治疗。同时我们还欲求挑战、紧张、危险甚至恐惧，但是日复一日，这种东西如果太多，我们也会最终被锁闭在一个橡皮房间内。所以，生活的节奏就是在这两个极端之间摇摆\n\n我们利用我们的幕结构，以紧张作为开始的基点，然后通过场景和序列提升到第一幕高潮。当我们进入第二幕时，我们便构思出一些削弱这一紧张度的场景，转换成喜剧、言情，一种可以相应降低第一幕紧张程度的基调，好让观众喘口气并蓄积更大的能量。我们引导观众像一个长跑运动员一样运动，不是以匀速奔跑，而是时而加速，时而减速，然后再加速，创造出一个周期，允许他达到其潜能的极限。在放慢进度之后，我们再加快下一幕的进展速度，直到我们在强度和意义上超越前一幕的高潮。我们一幕接着一幕地时而紧张，时而松弛，直到最后一幕的高潮将观众的情感倾泻一空，令他们在情感上精疲力竭而又快慰无穷。然后，再来一个简短的结局场景恢复元气，最后高高兴兴地回家。\n# 节奏和速度\n\n节奏是由场景的长度决定的。在一个讲得好的故事中，**场景和序列的进展能够增加进度**。当我们奔向幕高潮时，我们利用节奏和速度渐次缩短场景，使其中的活动变得越来越轻快有力。就像音乐和舞蹈一样，故事也是一种活动艺术。我们要利用摄影机的感觉力把观众抛向幕高潮，因为，事实上，具有重大逆转的场景一般都很漫长、徐缓而紧张。“高潮”并不是指短促的爆发，它是指深刻的变化。这样的场景不可能一掠而过。所以我们把它们展开，让它们呼吸；我们放慢进度，让观众屏住呼吸，思忖下一步将会发生什么。此处，回报递减律同样成立：我们停顿得越频繁，停顿的效果就越小。如果重大高潮之前的场景漫长而迟缓，那么我们想要制造紧张感的大场景则会流于平淡。因为我们已经在不太重要的弛缓场景中过多地消耗了观众的精力，伟大时刻的事件所得到的反应只是耸耸肩而已。相反，我们必须通过缩短节奏，螺旋式地提升速度，来“挣得停顿的资格”，当高潮来临时，我们可以踩住刹车，拉长放映时间，令紧张感长留不去。\n\n# 表现进展过程\n\n当一个故事真诚进展时，它要求投入越来越强的人物能力，要求越来越强的意志力，在人物的生活中产生越来越大的变化，并把他们推向越来越大的危难之中。我们如何才能表达出这一点？如何才能让观众感觉到进展过程？有四个主要技巧。\n\n## 社会进展\n\n扩大人物动作对社会的影响范围。让你的故事从私下开始，仅仅卷入几个主要人物。但当故事讲述过程向前进展时，允许他们的行动向外分岔，扩展到他周围的世界，触动并改变越来越多人的生活。并不是一次性完成，而是通过进展过程渐次扩散其效果。\n\n## 个人进展\n\n将动作深深楔入人物的私人关系和内心生活之中。从一个需要找到平衡而且似乎比较容易解决的个人或内心冲突入手，然后，随着作品的进展，向下捶打故事 —— 从情感上、心理上、身体上、道德上 —— 一直深入到隐藏在公共面具后面的阴暗秘密，和不可告人的真相。\n\n## 象征升华\n\n将故事意象的象征负荷从个别发展为普遍，从具体发展为原始模型。\n\n象征性进展的工作原理如下：首先我们从那些只能代表它们自己的动作、景点和角色入手，然后，随着故事的进展，我们选择那些意义不断加强的形象，一直到故事讲述结尾时，人物、场景和事件能够代表普遍性的思想。\n\n## 反讽升华\n\n以反讽方式转折进展过程。反讽是故事愉悦的最微妙表现形式，那是一种这样的快慰感觉：“啊，生活正像是那样。”它一分为二地看待生活；它拿我们充满悖论的生存状况大做文章，知道事物的表象和事物的真相之间存在着一条无底裂罅。语言反讽见于话语本身及其意义之间的分歧 —— 这是笑话的主要源泉。但在故事中，反讽却表现在故事能量的主要源泉 —— 动作和结果之间，表现在真理和情感的主要源泉 —— 外表和现实之间。\n\n以下是六个反讽故事模式\n\n1. 他终于得到了他一直想要的东西 ……但是已经太晚，他不可能拥有它。\n2. 他被推到离他的目标越来越远的地方 …… 结果却发现事实上他已被引导到他的目标。\n3. 他抛弃了他事后才发现的对他的幸福不可缺少的东西。\n4. 为了达到某一目标，他不知不觉地采取了一些背道而驰的步骤。\n5. 他采取行动想要毁灭某一事物，结果却适得其反，搬起石头砸了自己的脚。\n6. 他得到了某种他坚信会给他带来厄运的东西，想方设法要摆脱它 …… 结果却发现那是一份幸福的厚礼。\n\n# 过渡原理\n\n因此，在两个场景之间，我们还需要一个第三要素，一条使场景 A 和场景 B 首尾相接的纽带。\n\n第三要素是用于过渡的铰链；是两个场景中共有的东西或两个场景中互成反对的东西。\n\n例如： \n1. 一个人物塑造特征。共有：从一个顽皮小孩切入到一个孩子气的成人。反对：从笨拙的主人公切入到优雅的反面人物。 \n2. 一个动作。共有：从做爱的前戏到享受高潮之后的余欢。反对：从热烈的闲聊到冷漠的沉默。 \n3. 一个物体。共有：从温室的内景到丛林的外景。反对：从刚果到南极。 \n4. 一句话。共有：从一个场景到另一场景重复的短语。反对：从恭维到谩骂。 \n5. 光的质感。共有：从黎明时的阴影到日落后的余晖。反对：从蓝色到红色。\n6. 声音。共有：从拍打海岸的波浪到酣睡者呼吸的起伏。反对：从轻抚肌肤的丝绸到声音刺耳的齿轮。 \n7. 一个想法。共有：从一个婴儿的新生到一部音乐的序曲。反对：从画家空白的画布到垂死的老人。","n":0.146}}},{"i":25,"$":{"0":{"v":"Conflict","n":1},"1":{"v":"\n进展纠葛：这是故事的一个更大的抛物线状主体，从激励事件一直横跨到最后一幕的危机 / 高潮。纠葛是指，为人物的生活制造磨难。进展纠葛是指，当人物面对越来越强大的对抗力量时，产生越来越多的冲突，从而创造出一系列逐次发生的事件，经过一个个无法回归的点。\n\n当鸿沟裂开时，观众意识到，这是一个不归之点。最小的努力无济于事。人物不可能通过采取较小的行动来恢复生活的平衡。从此以后，一切类似于人物第一次努力的行动，一切这种力度和性质的轻量级行动，都必须从故事中排除。主人公意识到自己所冒的风险，表现出更大的意志力和能力，奋力越过这一鸿沟并采取第二个难度更大的行动。其结果是，再次引发对抗力量，在期望和结果之间开掘出第二道鸿沟。\n\n故事绝不能退隐于轻量级性质或力度的行动，而必须循序渐进地朝着观众无从想象出更好替代的一个最后行动向前运行。\n\n# 冲突法则\n\n当主人公走出激励事件，他便进入了一个由冲突法则统领的世界。亦即：若无冲突，故事中的一切都不可能向前进展。故事是生活的比喻，活着就是置身于看似永恒的冲突之中。\n\n为了让故事产生纠葛，作者必须循序渐进地制造冲突，一直到线索的终点。这是一项足够艰难的任务。但是，如果我们要把纯粹的纠葛完全复杂化，那么这一任务的难度便会呈几何级数增加。如我们所见，冲突可以来自对抗力量的任何一个、两个或所有三个层面。简单的故事纠葛是指，将所有冲突置于这三个层面的仅仅一个之上。\n\n![](/assets/images/2022-03-19-11-31-02.png)\n\n![](/assets/images/2022-03-19-11-31-09.png)\n\n# 幕设计\n\n一系列场景构建成一个序列，并以一个对人物造成适中打击的场景作为顶点，以甚于同一序列中任何场景将其价值向更好或更坏方向改变的程度。一系列序列构建成一个幕，以一个场景作为高潮，在人物的生活中创造出一个重大的逆转，其强度甚于任何已经完成的序列。\n\n根据亚里士多德的原理：一个故事可用一个幕讲述—— 一系列场景构筑成几个序列，最后进展为一个重大逆转，结束故事。不过，如果是这样，则必须简短。这就是所谓的短篇小说、独幕剧，抑或也许只有五到二十分钟的学生电影习作或试验电影。\n\n一个故事可用两幕讲述：两个重大逆转之后，便告结束。但是，这同样要求比较简短：情境喜剧、中篇小说或一小时戏剧，如安东尼·谢弗的《黑色喜剧》和奥古斯特·斯特林堡的《朱丽小姐》。\n\n但是，当故事达到一定的长度——故事影片、一小时一集的电视剧、全长戏剧、长篇小说—— 时，则起码需要三幕。这并不是因为人为的常规，只是为了达到故事的深层目的。\n\n## 幕节奏\n\n重复是节奏的死敌。故事的动感取决于正面价值与负面价值的交替变更。例如，一个故事中两个最强烈的场景往往是最后两幕的高潮。\n\n当情感体验重复时，第二个事件的力度将会减半。如果故事高潮的力度被减半，影片的力度也会随之减半。\n\n次情节较之主情节，所获的强调和银幕时间要少。次情节可以用于与主情节的主控思想构成矛盾，从而以反讽丰富影片。次情节可以用于与主情节的主控思想构成回响，从而以同一主题的多种变异来丰富影片。当主情节的激励事件必须推迟时，则可能需要一个伏笔式次情节来开始故事的讲述。","n":0.354}}},{"i":26,"$":{"0":{"v":"Type","n":1},"1":{"v":"\n1.爱情故事。\n\n子类型：哥们救赎\n\n以友谊取代浪漫的爱情：如《穷街陋巷》、《激情之鱼》、《阿珠与阿花》。\n\n2.恐怖片。这一类型可分为三个次类型：离奇恐怖，恐怖源令人震慑，但尚可进行“理性”解释，如外太空生物、科学制造出来的怪物，或疯子；超自然恐怖，恐怖源为幽灵世界的“非理性”现象；超级离奇恐怖，留待观众在以上两种可能性中进行猜测——《怪房客》、《狼之时刻》、《闪灵》。\n\n3.现代史诗（个人对抗国家）。《斯巴达克斯》、《史密斯先生到华盛顿》、《萨巴达万岁》、《1984》、《公诉拉里·弗兰特》。\n\n4.西部片。这一类型及其次类型的演变在韦尔·莱特的《六支枪和社会》一书中得到了精彩的记叙。\n\n5.战争类型。尽管战争常常是另一类型的背景，如爱情故事，但战争类型却具体描写战斗本身。拥战和反战是其主要次类型。当代电影一般都是反战的，但几十年来，大多数也都在暗暗地讴歌战争，哪怕是以其最残酷的形式来表现。\n\n6.成熟情节或曰成长故事。《伴我同行》、《周末夜狂热》、《乖仔也疯狂》、《飞越未来》、《小鹿斑比》、《穆丽尔的婚礼》。\n\n7.救赎情节。此处的电影弧光为主人公内心从坏到好的道德变化：《江湖浪子》、《吉姆老爷》、《迷幻牛郎》、《辛德勒的名单》、《一诺千金》。\n\n8.惩罚情节。好人变坏，并受到了惩罚：《贪婪》、《浴血金沙》、《靡菲斯特》、《华尔街》、《怒火风暴》。\n\n9.考验情节。保持坚强意志抵御屈服诱惑的故事：《老人与海》、《铁窗喋血》、《陆上行舟》、《阿甘正传》。\n\n10.教育情节。本类型的弧光闪烁于主人公人生观、他人观或自我观的深刻变化，从负面（天真、不信任、宿命论、自暴自弃）到正面（明智、信任、乐观、沉着）：《哈洛与慕德》、《温柔的怜悯》、《冬日之光》、《邮差》、《这个杀手将有难》、《我最好朋友的婚礼》、《谈谈情跳跳舞》。\n\n11.幻灭情节。世界观由正面到负面的深刻变化：《帕克夫人的情人》、《蚀》、《鬼火》、《了不起的盖茨比》、《麦克白》。\n\n有些类型属于超大类型，庞大而复杂，其次类型的变体几乎数不胜数：\n\n12.喜剧。次类型从恶搞喜剧到讽刺喜剧到情景喜剧到浪漫喜剧到荒诞喜剧到闹剧到黑色喜剧，其差异表现在喜剧攻击的焦点（官僚的愚蠢、上流社会礼仪、早恋等）和嘲讽的程度（温和、尖刻、致命）。\n\n13.犯罪。次类型主要根据对以下问题的不同回答来分类：我们是从谁的视点来看待这一犯罪？神秘谋杀（侦探大师的视点）、罪行（犯罪大师的视点）、侦探（警察的视点）、黑帮（匪徒的视点）、惊悚或复仇故事（受害人的视点）、法庭（律师的视点）、报纸（记者的视点）、谍战（间谍的视点）、监狱戏（囚犯的视点）、黑色电影（一个兼罪犯、侦探和荡妇受害者为一身的主人公的视点）。\n\n14.社会剧。这一类型指出社会问题——贫穷、教育体制、传染病、弱势群体、反社会暴乱，以及诸如此类的问题——然后构建出一个故事，展示其疗救方法。它有一系列焦点清晰的次类型：家庭剧（家庭内部问题）、女性电影（诸如事业对家庭、爱人对孩子之类的两难之境）、政治剧（政治腐败）、生态剧（挽救环境的斗争）、医药剧（与身体病痛的斗争）、精神分析剧（与精神病的斗争）。\n\n15.动作/探险。本类型经常会借助其他类型（如战争或政治剧）的某些方面作为火爆动作和探险行为的动机。如果动作/探险包含了命运、狂妄或精神等观念，便为高端探险：《霸王铁金刚》。若大自然是对抗力量之源，则成灾难/生存电影：《天劫余生》、《海神号历险记》。\n\n从一个更广的视点来看，超大类型还可以创始于那些本身便孕育着诸多自发类型的背景、表演风格或电影制作技巧。它们就像是一座座具有许多房间的庄园，每一种基本类型、次类型及其任意组合都能在其中找到自己的居所：\n\n16.历史剧。历史是取之不尽的故事源泉，包含任何你能想象出的故事类型。然而，这个历史的宝库却贴着这样的封条：唯古为今用者方能开启。银幕剧作家并不是希望死后才被人发现的诗人，他必须在今天找到观众。因此，对历史最好的使用方法，而且也是把一部影片设置在过去，从而使其预算陡然增加千百万美元的唯一合法借口，就是时代置换——即利用过去作为一面明亮的镜子来向我们展示现在。\n\n17.传记。这是历史剧的表弟，其焦点对准一个人而不是一个时代。然而，传记绝不能成为一部简单的编年史。某人的生卒年月及其生平事迹只具有学术价值，仅此而已。传记作家必须把事实当作小说来演绎，找出主体的生活意义，并把他树立为这种生活类型的主人公：《青年林肯》在法庭剧中为无辜者辩护；《甘地》成为一部现代史诗中的英雄；《绝代美人》沦为一个幻灭情节的苦主；而《尼克松传》在惩罚情节中一筹莫展。\n\n18.纪实剧。这是历史剧的二表弟。纪实剧集中于最近而不是过去的事件。真实电影3曾令这一类型生机勃勃（《阿尔及尔之战》）。现在它已成为一个颇为流行的电视类型，有时力量强大，但常常缺乏应有的文献价值。\n\n19.嘲讽纪录片。这一类型假装根植于现实或记忆，以纪录片或自传片的形式出现，但却纯属虚构。它颠倒了基于事实的电影制作，用以嘲讽伪善的社会体制：《摇滚万万岁》中摇滚音乐的后台世界；《罗马风情画》中的天主教堂；《西力传》中的中产阶级道德观念；《人咬狗》中的电视新闻业；《天生赢家》中的政治；《不惜一切》中纯粹的美国价值观。\n\n20.音乐片。这个类型是歌剧的后裔，它提供一个“现实”的舞台，令人物或唱或跳，演绎他们的故事。它常常是一个爱情故事，但也可能是一部黑色电影：如根据舞台剧改编的《日落大道》；社会剧：《西区故事》；惩罚情节：《爵士春秋》；传记片：《贝隆夫人》。实际上，任何类型都可以用音乐片的形式来表达，且一切都可在音乐喜剧中进行嘲讽。\n\n21.科学幻想。在假想的未来，科学幻想作家常常将个人对抗国家的现代史诗与动作/探险糅合在一起，创造出由于科学技术的异化而导致独裁和混乱的非理想社会：《星球大战》三部曲和《全面回忆》。然而，就像历史一样，未来也只是一个背景，其间任何类型都可以有用武之地。如影片《飞向太空》，安德烈·塔科夫斯基利用科幻表现了一个幻灭情节的内在冲突。\n\n22.体育类型。体育是人物变化的熔炉。这个类型是以下类别的天然家园——成熟情节：《达拉斯猛龙》；赎罪情节：《回头是岸》；教育情节：《百万金臂》；惩罚情节：《愤怒的公牛》；考验情节：《烈火战车》；幻灭情节：《长跑者的寂寞》；哥们救赎：《黑白游龙》；社会剧：《红粉联盟》。\n\n23.幻想。在此，作者把玩着时间、空间和物质世界，曲解和混淆着自然和超自然的法则。幻想的超级现实吸引着动作类型，同时也欢迎其他类型的加入，如，爱情故事：《时光倒流七十年》；政治剧/寓言：《动物农场》；社会剧：《如果……》；成长情节：《爱丽丝梦游仙境》。\n\n24.动画。“世间万物都是在发展变化的”这条法则对这一类型非常适用：任何事物都可以变成另一事物。像幻想和科幻一样，动画偏向于卡通闹剧的动作类型：《兔八哥》；或高端探险：《石中剑》、《黄色潜水艇》；由于青少年观众是其自然市场，所以也有许多成熟情节：《狮子王》、《小美人鱼》；不过，即如东欧和日本动画家所展示的那样，这一类型没有限制。\n\n最后，由于有些人坚信，类型及其常规只是“商业片”作家所关心的事，严肃艺术无所谓类型。为此，请让我在上述清单上再加上最后一个名字：\n\n25.艺术电影。脱离类型而写作的先锋派观念是很天真的。没有人能在真空中写作。经历了几千年的故事讲述之后，没有一个故事会完全与众不同，以至于与其他已写过的故事毫无相似之处。艺术电影已成为一个传统类型，并可分出两个次类型，最小主义和反结构，每一个都有它自己一整套复杂的宇宙论和结构常规。就像历史剧一样，艺术电影也是一个超大类型，将爱情故事、政治剧等其他基本类型兼收并蓄。\n\n\n## 类型常规\n\n每一个类型都给故事设计制定了常规：高潮时的常规价值负荷，如幻灭情节的低落结局；常规背景，如西部片；常规事件，如爱情故事中的男女邂逅；常规角色，如犯罪故事中的罪犯。观众知道这些常规，并期待着看到它们一一实现。其结果是，类型的选择明确地决定并限定了一个故事中什么是可能的，因为它的设计必须将观众的知识和预期考虑在内。\n\n**类型常规**是界定各个类型及其次类型的具体背景、角色、事件和价值。\n\n\n每一个类型都有独一无二的常规，但在某些类型中，它们却并不复杂，且具有很强的可塑性。**幻灭情节**的首要常规就是主人公在故事开始时充满乐观，怀抱崇高的理想或信念，他的人生观是正面的。第二常规是一系列挥之不去的负面故事转折，刚开始也许会提升他的希望，但最终却毒化他的价值观和梦想，使他变得愤世嫉俗、万念俱灰。例如，《对话》中主人公刚开始的生活稳定有序，最后却陷进了一种令人发狂的噩梦里。这套常规非常简单却能提供不可胜数的可能性，因为生活认识一千条通往绝望之路。这一类型有许多不朽佳作，如《乱点鸳鸯谱》、《甜蜜的生活》和《列尼传》。\n\n其他类型相对而言则不太灵活，充满了整套复杂而严密的常规。**犯罪类型**中必须有一项犯罪，且必须在故事讲述的早期发生。必须有一个侦探人物，发现线索，提出疑问，无论他/她专业还是业余。在**惊悚片**中罪犯还必须将事情“个人化”。尽管故事可以以一个收黑钱的警察作为开始，但为了深化剧情，在某一点上，我们必须让罪犯超越底线。而陈词滥调就像真菌一样围绕着这一常规孳生：罪犯恐吓警察的家庭，或把警察本人变成嫌疑犯；又或者，作为陈词滥调中的陈词滥调，罪犯把侦探的搭档杀死——这种常规的根源可追溯到《马耳他之鹰》。而最后，警察必须查明真相，拘捕罪犯并将其绳之以法。\n\n**喜剧**也包含无数次类型，且每一种都有自己的常规。同时，一个最高常规统领着这一超大类型，并将它与正剧区分开来：无人受到伤害。在喜剧中，观众必须感到，无论人物怎样从墙上摔下，无论他们是怎样在生活的鞭笞下痛苦呻吟或辗转反侧，都不会造成真正的伤害。大楼可能会倒在劳雷尔和哈迪4身上，但他们还是会从瓦砾中站起来，掸掉身上的尘土，喃喃地说：“瞧，身上脏成这样……”然后继续走他们的路。\n\n\n为了预知观众的预期，你必须精通你的类型及其常规。创作限制的原理讲求在一个障碍圈内获得自由","n":0.707}}},{"i":27,"$":{"0":{"v":"Role","n":1},"1":{"v":"\n人物塑造是一切可以观察到的人的素质总和，一切通过仔细考察便可获知的东西：年龄和智商；性别和性向；语言和手势风格；房子、汽车和服饰选择；教育和职业；性格和气质；价值和态度 —— 我们可以通过日复一日地记录某人的生活而获知关于人性的所有方面。这种各种特质的独一组合便是人物塑造 …… 但这不是人物。\n\n## 压力\n\n人物性格真相 1 在人处于压力之下做出选择时得到揭示 —— 压力越大，揭示越深，其选择便越真实地体现了人物的本性。压力是根本。在没有任何风险的情况下做出的选择意义甚微。\n\n对照或反衬人物塑造来揭示人物性格真相，是所有优秀故事讲述手法中的基本要素。生活教给我们这一宏大原则：看似如此其实并非如此。人不可貌相。表面特征下掩盖着一个深藏的本性。无论他们言说什么，无论他们举止如何，若要了解深层的人物性格，唯一的途径就是通过他们在压力之下做出的选择。\n\n## 人物弧光\n\n把这一原则再推进一步：最优秀的作品不但揭示人物性格真相，而且还在其讲述过程中展现人物内在本性中的弧光或变化，无论变好还是变坏\n\n## 结构和人物\n\n结构的功能就是提供不断加强的压力，把人物逼向越来越困难的两难之境，迫使他们做出越来越艰难的冒险抉择和行动，逐渐揭示出其真实本性，甚至直逼其无意识的自我。\n\n人物的功能是给故事带来人物塑造所必需的素质，让选择可以令人信服地表演出来。简言之，一个人物必须可信：以适当的比例，足够年轻或年老，强壮或虚弱，世故或天真，学识渊博或目不识丁，慷慨大方或自私自利，聪颖机智或顽固不化。每一种搭配都必须给故事带来合理的素质组合，以令观众相信，这个人物能够做到而且很可能会做他所要做的事情。\n\n","n":0.289}}},{"i":28,"$":{"0":{"v":"Idea","n":1},"1":{"v":"\n故事是一种设备，通过它你可以随心所欲地创造出这种领悟，这种现象便是人们所熟知的审美情感。\n\n一切艺术都源自人类心灵对以下各方面最原始的、先于语言的需求：通过美与和谐来解决压力与不和，通过创造力的使用来复活被日常事务搞得死气沉沉的日子，通过我们对真理的本能感知来寻求与现实的联系。就像音乐和舞蹈、绘画和雕塑、诗词和歌曲一样，故事是审美情感最初的、最后的和永恒的体验 —— 与思想和感情同时接触\n\n# 前提和主控思想\n\n有两个概念支撑着整个创作过程：一是前提，即激发作家创作欲望的灵感；二是主控思想，即通过一幕高潮中，动作和审美情感所表达的故事终极意义。\n\n最后，我们还要认识到重要的一点，无论激发写作的灵感是什么，都不一定要保留在作品之中。前提并非稀世珍宝。如果它有助于故事的进展，则可保留，如若故事讲述意图偏转，则应舍弃那一原始灵感，顺应故事的发展轨迹。关键问题并不是如何开始写作，而是如何保证能够继续写下去并不断刷新灵感。我们很少知道我们到底会趋向何方；写作即是一种发现。\n\n主控思想不但像主题一样，指出了故事的根本或中心思想，同时还隐含了其功能：主控思想确立了作者的关键性选择。它是又一条创作戒律，为你的审美选择提供向导，助你确定：在你的故事中，什么适宜，什么不适宜；什么能表达你的主控思想并可以保留，什么与主控思想无关而必须删除。\n\n主控思想可以用一个句子来表达，描述出生活如何以及为何会从故事开始时的一种存在状况转化为故事结局时的另一种状况。\n\n主控思想具有两个组成部分：**价值加原因**。它明确鉴定出最后一幕高潮中故事重大价值的正面或负面负荷，并同时鉴定出这一价值何以转化为现在这一最后状态的主要原因。\n\n## 思想\n\n故事进展通过在故事中押上台面的各种价值的正面负荷和负面负荷之间的动态移动而构建起来。\n\n同一思想的正反两面在整个影片中循环往复地较量，紧张度不断加强，直到危机转折点处，它们在最后的绝境中迎头相撞。这一碰撞便产生了故事高潮，至此，交战双方胜负已决。胜者也许是正面思想：“正义战胜邪恶。”因为主人公坚忍不拔、足智多谋且英勇无畏（《黑岩喋血记》、《生死时速》、《沉默的羔羊》）；也可能是负面反思想：“邪恶战胜正义。”因为反面人物的残酷无情和显赫权势无人能敌（《七宗罪》、《问答》、《唐人街》）。这两种思想中，无论哪一个在最后的高潮动作中得到戏剧性的表现，都将成为价值加原因的主控思想，成为对故事结论性和决定性意义的最纯粹陈述。\n\n创造故事“论战”的维度时，必须万分小心谨慎地给予交战双方同样的火力。在构思那些与你最后陈述相矛盾的场景和序列时，必须像构思那些强化你最后陈述的场景和序列时一样，赋予等量的真理和能量。\n\n# 理想主义者、悲观主义者和反讽主义者\n\n![](/assets/images/2022-03-19-09-57-38.png)\n\n“上扬结局”故事表达的是乐观主义、希望和人类的梦想，对人类精神的一种具有正面负荷的观点；我们所希望的生活图景。\n\n“低落结局”故事表达的是我们的愤世嫉俗、失落感和时运不济之叹，是对文明堕落和人性阴暗面的一种具有负面负荷的观感；是我们所害怕发生而又明知它会时常发生的人生境遇\n\n“上扬 / 低落结局”故事表达的是我们生存状况的复杂性和两面性，是一种同时具有正面和负面负荷的视觉，是最完整和最现实的生活。\n\n以下是两种反讽主义主控思想的典型例子，其中表达出来的反讽意味帮助我们界定了当代美国社会的伦理和心态。第一个是正面反讽：对当代价值 —— 成功、财富、名誉、性、权力的过分追求 —— 将会摧毁你，但你只要能及时看清这一真理并抛弃你的执着，便能使自己得到救赎。\n\n第二个是负面反讽：如果你一味地痴迷于你的执着，你无情的追求将会满足你的欲望，然后毁灭你自己。\n\n反讽对观众的作用就是那种美妙的反应：“噢，生活就是这样”。我们认识到，理想主义和悲观主义是经验的两个极端，生活很少完全充满阳光和草莓，也并非全是厄运和惨痛，它二者兼有。从最坏的经历中，我们总能得到一些正面启迪，最丰富的经历总要付出巨大代价。无论我们如何设计生活的直通航道，总免不了要在反讽的潮汐上航行。现实总是充满无情的反讽，因此，以反讽结局的故事往往最能经久不衰，远播世界，博取观众最大的热爱和敬仰","n":0.289}}},{"i":29,"$":{"0":{"v":"Background","n":1},"1":{"v":"\n\n故事的背景是四维的——**时代、期限、地点和冲突层面**。\n\n第一个时间维是时代。故事发生在当今世界、历史时期还是假想的未来？时代是故事在时间中的位置。\n\n期限是第二个时间维。在人物的生活中，故事的时间跨度有多长？几十年？几年？几个月？几天？期限是故事在时间中的长度。\n\n地点是故事的物质维。故事的具体地理位置是什么？在哪座城镇？在哪些街道？在哪些街道的哪些楼房里？在哪些楼房的哪些房间里？上了什么山？穿越了什么沙漠？旅行到哪个星球去了？地点是故事在空间中的位置。\n\n冲突层面是人性维。一套故事背景不仅包括物质域和时间域，还包括社会域。这是一条垂直的维：你是在什么冲突层面上讲述你的故事？无论外化于机构还是内化于个体，各种政治的、经济的、意识形态的、生物的以及心理的社会力量，都会像时代、风景和服装一样，对事件的塑造发挥着同样的作用。因此，人物设置，包括其各不相同的冲突层面，也是故事背景的一部分。\n\n你的故事是否聚焦于人物内心的、即使是不自觉的冲突？或提高一个层面，聚焦于人际之间的冲突？或者更高更广，聚焦于与社会机构的斗争？甚至再广泛一些，聚焦于与环境力量的争斗？从个人潜意识到天上的浩瀚星辰，穿越生活的所有多重体验，你的故事可以定位于这些层面的任意一个或任意组合。冲突层面是故事在人类斗争的层级体系中的位置。\n\n故事必须遵守其自身内在的或然性法则。因此，作家的事件选择局限于他所创造的世界内的可能性和或然性。\n\n**背景**对故事的反讽表现在：世界越大，作者的知识便越被稀释，其创作选择也就越少，故事便越发充满陈词滥调。世界越小，作者的知识便越完善，其创作选择也就越多。结果是一个完全新颖的故事，以及对陈词滥调作战的胜利。\n\n## how\n\n打赢这场仗的关键就是研究，花时间和精力去获得知识。我建议采用以下具体方法：记忆研究、想象研究、事实研究。\n\n- 记忆\n  - 舒展一下你伏案的腰板，问问自己：“我个人经验中的什么东西能触动我人物的生活？”\n- 想象\n  - 自问：“如果日日夜夜、时时刻刻地过着我人物的生活会是什么样子？”\n  - 记忆可以给予我们整块的生活，而想象则会为我们提供碎片，那些看上去毫无联系、支离破碎的梦境和体验之间的隐藏关联将被想象搜寻出来，并融合为一个整体。\n- 事实\n  - 才华必须靠事实和思想激发。所以你必须做研究，给你的才华补充营养。研究不但能帮你打赢这场与陈词滥调的战争，而且还是战胜恐惧及其表弟消沉的关键。\n\n\n尽管研究能够提供素材，但它绝不能取代创作。对背景和人物所进行的传记的、心理的、物质的、政治的和历史的研究固然不可或缺，但这种研究如果不能导向事件的创作，则毫无意义。故事并不是由一堆累积的信息串联而成的叙事体，而是一种对事件的设计，将我们引入一个有意味的高潮。\n","n":0.277}}},{"i":30,"$":{"0":{"v":"Video","n":1}}},{"i":31,"$":{"0":{"v":"Title","n":1},"1":{"v":"\n# 封面\n\n## 唤起好奇心\n\n1. 简单直接的悬疑\n2. 熟词生义 ： 对熟悉的东西做了不寻常的操作\n3. 没见过、这辈子也不一定见的\n\n## 唤起情绪\n\n- 搞笑\n- 向往\n- 感动\n- 归属感\n- 恐惧\n- 焦虑\n- 愤怒\n- 震撼\n\n# 标题\n\n关键词+冲突 而不是总结\n\n- 兴趣关键词\n- 数字\n- 权威锚定\n- 最强刺激：[广告法禁止的词](https://www.sohu.com/a/444587068_726692)\n- ip加成\n- 高效收益\n- 挑战观众\n- 颠覆认知","n":0.192}}},{"i":32,"$":{"0":{"v":"Shots","n":1},"1":{"v":"\n# 广角\n\n拍自己，容易让观众感到亲近\n\n## tip\n\n1. 静止不动让观众专心听自己讲的内容\n\n# 中焦\n\n拍别人，POV视角\n\n# 长焦\n\n拍自己和环境的关系\n\n# tip\n\n1. 可以多次拍同一个事件，用不同的焦距来拍摄\n2. 拍摄之前确定mic有没有打开","n":0.333}}},{"i":33,"$":{"0":{"v":"Idea","n":1},"1":{"v":"# 爆款五要素\n## 选题\n- 快乐\n- 有用的信息，激励和榜样\n- 提供知识\n- 热点\n- 价值共鸣\n\n![](/assets/images/2022-03-21-20-45-52.png)\n\n![](/assets/images/2022-03-21-20-46-10.png)\n\n## 制造共鸣\n\n价值观上你想表达的中心主旨让观众买账\n\n![](/assets/images/2022-03-21-20-49-06.png)\n\n![](/assets/images/2022-03-21-20-49-45.png)\n\n情绪\n\n![](/assets/images/2022-03-21-20-50-07.png)\n\n共鸣就是感受到相同的情绪\n\n## 幽默与快乐\n\n视频=娱乐，看视频就是找乐子的\n\n![](/assets/images/2022-03-21-20-55-50.png)\n\n不太认真、荒谬、背理。 ==> 打破惯性\n\n- 段子\n- 歇后语\n- 成熟的反转剧本\n- bgm\n- 声效\n- 画面\n- 表情包\n\n## 获得感和价值\n\n人是有获得感的需求的\n\n## 节奏与信息密度\n\n持续吸引观众注意力很重要。\n\n30s留存率很重要。掌握自己的节奏\n\n试着删掉某句话或某段话，如果这句话不影啊全文\n那之大概率是废话。\n\n# casey\n\nAny small idea would work. 在生活中我们所有想分享的内容都可以。重点是如何将自己的想法沟通出去，思考最有趣的方式是什么，如何证明自己的想法。\n\n让观众看到自己的想法，了解我想分享的东西。我感觉有趣的东西对于观众来说可能也是有趣的。引起共鸣","n":0.192}}},{"i":34,"$":{"0":{"v":"Followers","n":1},"1":{"v":"\n- 点赞：喜欢你的视频\n- 投币：感谢\n- 收藏：干货\n  - 教育意义\n  - 资料\n  - 技巧成长\n  - 工具类\n- 转发\n  - 用户互动成本最高\n\n点赞率>10%很重要\n\n# 弹幕和评论\n\n1. 有些容易引发讨论的话题是能吸引弹幕，这对于增加高质量弹幕数量是有好处的。\n2. 用口播和弹幕投票引导观众发弹幕，不要不好意思.因为它很有效。\n3. 一些带节奏的弹幕可以适当删除，因为节奏往往就是蝴蝶效应。\n\n对视频内容的讨论和指正是优质评论。和优质评论互动，顶上去。删除负面带节奏的评论\n\n# 视频创作\n\n留气口，加入互动的窗口。\n\n- 知道这个冷知识的扣个1\n- 你们有什么想法可以发在评论区\n- 你们觉得呢？\n- 你们是不是也这样？\n\n# b站的社区属性\n\n去其他up底下增加曝光","n":0.2}}},{"i":35,"$":{"0":{"v":"Edit","n":1},"1":{"v":"\n# 蒙太奇理论\n\n总的来说，蒙太奇理论将多个镜头的拼接看作一个整体，因此每个镜头都是构成这个整体的一部分。单独看每一个镜头，都不构成讲述一个完整时间，或表达一种完整情感，看似毫无关联的镜头通过不同的拼接，完全可以达到不同的艺术表现效果。\n\n## 叙事式蒙太奇\n\n叙事式蒙太奇由美国电影大师格里菲斯等人首创，是影视片中最常用的一种叙事方法。这种蒙太奇主要是为了叙事而服务的，根据因果关系，剧情发展，将不同景别的镜头有机地结合在一起，拼凑出一个具体详实的故事。这种叙事手法逻辑思维连贯，观众对于剧情易于理解。\n\n## 平行式蒙太奇\n\n在影视作品中，往往会出现这样一种情况：在剧情发展过程中，存在两条或两条以上的故事线索，它们可能存在于不同的时空、同时空异地，或同时同地并列发展着，彼此形成一种并列关系，彼此有呼应、存在联系，又相互发展、彼此推进，这种叙事方式就是平行式蒙太奇（或称并列式蒙太奇）\n\n## 交叉式蒙太奇\n\n这种蒙太奇多属于一种剪辑技巧，但整体目的还是为了推动剧情的发展。交叉式蒙太奇也称为交替式蒙太奇，它的特点就是同一时间，有两条或两条以上故事线交叉发展。这种剪辑手法能营造出紧张的气氛和强烈的节奏感，在当今的影视创作中也极受推崇。\n\n## 梦幻式蒙太奇\n\n梦幻式蒙太奇，通过精心安排的镜头组接，展示出人物的心理活动、精神状态，例如想象、梦境、思索、闪念、回忆以及潜意识活动，这种构成方式就是梦幻式蒙太奇。这种表现形式的特点就是成片段式的，叙述是不连贯的，节奏是跳跃式的，具有强烈的主观意识。我自编自导的微电影作品《ET恐慌》中就运用了这种手法和这样的剪辑技巧。\n\n# 三点编辑\n\n- 覆盖。覆盖编辑从源剪辑中用新的帧来取代序列中的帧。\n- 插入。插入编辑将剪辑添加到序列，并将现有的素材向右移动（序列的后边）为插入的剪辑腾出空间。\n\n三点编辑可以让你定义放到序列中某个特定位置的剪辑的片段，或者定义序列中需要用剪辑来填充的一个特定的范围。\n\n当你在源剪辑设置三点中的两个——一个入点和一个出点，然后在序列中设置一个入点或出点作为第三个点时，很可能你就会执行一个插入编辑。\n\n也许有时你需要在序列中定义一段持续时间并用素材进行填充。这种情况下，在时间轴中要设置两个点，还有一个点标记在源剪辑中，无论是入点还是出点。这是将B卷素材放在序列音频片段之上的最常用技巧。当这种类型的三点选择设置后，你通常会执行覆盖编辑。","n":0.333}}},{"i":36,"$":{"0":{"v":"Pr","n":1},"1":{"v":"\n# 快捷键\n\n- c cut\n- v view Selection Tool\n- b  Ripple Edit Tool, 剪辑中间没有空隙\n- g 音频增益\n- Cmd+R Speed/Duration\n- Shift+Cmd+/ Duplicate\n- R Rate Stretch Tool\n- cmd+L 取消链接\n- \t,(comma) insert\n- . overwrite\n- ripple trim pervious edit\n- shutter right/left \n- ripple delete\n- rolling edit\n- pen tool \n- ctrl 箭头变加号可以单独调整速度\n\n# fast idea\n\n1. 自动增加audio增益\n2. 点击时间轴move到那里\n3. 点击clip自动ripple delete\n\n# 自动化序列\n\n在素材箱中为这些剪辑设置入点和出点，然后用自动化到序列将几个镜头一次性地编辑到时间轴中。这是我使用序列自动化的主要原因。","n":0.139}}},{"i":37,"$":{"0":{"v":"Effect","n":1},"1":{"v":"\n# presets\n\n2.4 limiter 限制颜色范围\n\n# 视频效果\n\n- 亮度键\n- 高斯模糊","n":0.378}}},{"i":38,"$":{"0":{"v":"Music","n":1},"1":{"v":"\n反复思考如何让观众感觉舒服\n\n思考音乐让人有什么感受，选择合适的音乐很难\n\n音乐可以帮助你的过渡。思考怎么使用这些音乐+画面\n\n利用一些小的音乐来进行场景切换","n":1}}},{"i":39,"$":{"0":{"v":"Travel","n":1}}},{"i":40,"$":{"0":{"v":"Visa","n":1}}},{"i":41,"$":{"0":{"v":"Japan","n":1},"1":{"v":"\nhttps://piao.tips/japan-visa-in-the-us-consolidated/#%E5%AE%9E%E7%94%A8%E4%BF%A1%E6%81%AF\n","n":1}}},{"i":42,"$":{"0":{"v":"Canada","n":1},"1":{"v":"\nhttps://clegc-gckey.gc.ca/j/eng/l?ReqID=s2d006d9d45406e812523d29338ae09fe57156e38a","n":1}}},{"i":43,"$":{"0":{"v":"Coupon","n":1},"1":{"v":"\n\n# Travel\n\n## 租车\n### National\n\nlegacy.enterprise.com/car_rental/deeplinkmap.do?bid=028&refId=FACEBOOK\nXZ23956\n### Sixt\n\nsixt.com/fond\n### Enterprise\n\nhttps://partners.rentalcar.com/fond/\nXZ23548\n\n### Budget\nhttps://www.budget.com/en/association/A772700\n\n### Zipcar\n​\n​Go to zipcar.com/facebook\nSelect if you’re an Employee or Intern Age 18+\nCreate your profile and use your @fb.com email\nIf you already have a Zipcar account and want to get the annual membership at no cost to you, you can update your current account with your @fb.com email. Then email business@zipcar.com to have your account moved to the Facebook group.\n\n### Alamo\n\nhttps://partners.rentalcar.com/fond/\n\n### Avis\n\navis.com/fond\nU294300\n\n### Hertz\n\nprks.io/2ytm4dV\nFor Hertz Getaway Great Rates, promo code should already be applied, if not, enter \"2052200\" under promo code. During the reservation process, join the Gold Plus Rewards Club in order to skip the counter. CDP#2052200\nFor Hertz Car Sales: use promo code, \"R2BCA044\".\n\n\n\n## 飞机\n### Delta\nDelta Vacations offers you an exclusive travel discount program for use when purchasing a flight and hotel vacation to hundreds of Delta Vacations destinations. Please use your Facebook email address and corporate code 6SC60 when registering.\n\n\n### Ua\n\nBook online at the dedicated corporate account’s United Vacations webpage: prks.io/334Xzll, the promo code is already applied on the webpage. Or call United Vacations Customer Care at 888-854-3899. When calling mention promo code \"UACLP600\".\n\n## 酒店\n\n### Hyatt\n\n55468\n### 万豪\nExclusives Rates:\n￣￣￣￣￣￣￣￣\nVisit Marriott.com & when filling out your trip details, click on Special Rates & select \"Corporate/Promo/SET#\" & enter promo code \"FSF\".\nEarn Marriott Bonvoy Platinum Elite Status - Faster:\n￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣\nVisit prks.io/3gJATin to register. Enjoy Platinum Elite status & benefits at all participating hotels & resorts for 3 months. Stay 15 paid nights within 3 months of registering for the offer to keep your Platinum Elite status for up to one year.\nMarriott Bonvoy & Uber Partnership:\n￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣\nVisit uber.marriott.com/en-us & follow the instructions to link your accounts.\nWorkanywhere.marriott.com\n\n\nAdditionally, Facebook employees can receive substantial weekend discounts on leisure travel using the BreakAway program\n\n\n\n\n### 四季\n\nFourseasons.com\n\nFACE8\n\n### Hilton\n \nIn the Americas: \"0002705746\"\nOutside of the Americas: \"000027973\"\n\n### OYO\nprks.io/3wAubSk\nOYOFOND\n\n### Booking \nprks.io/3dzgWdn\n\n### Accor\t\n\n\nCompany name: FACEBOOK\nCompany code: SC196337864\nAccess code: FA564US684\n15% chainwide discount – see Accor Chainwide Discount flyer for the link and global codes\n\n\n\n### Trip\nhttps://prks.io/3xE8l20\n\n### citizenM\nCorp ID: cu-fbk\n\n### IHG\n100270748\n\n\n# Fun\n\n- Amc black e-ticket： https://fond.co/facebook.com#/perk/3417\n- Cinemark\nhttps://fond.co/facebook.com#/perk/3410\n- Museum\nprks.io/3jnYTut\n- Concert ticket\n1. Click on the 'Special URL' (shown below) to receive a coupon code.\n2. Once you've received your code, visit ticketclub.com and create an account.\n3. From your account, click on the 'My Membership' tab.\n4. Enter your voucher code in the section labeled 'Redeem a prepaid membership voucher' and apply.\nYour Premier Membership will be activated. Through this, you will have access to ticket prices below average market rates for free for the first year. Select your desired ticket(s) and make your purchase.\n\n- Hidden\nVisit explorehidden.com/home & select your city & experience. Upon checkout, enter the promo code, shown below.\nRedemption Code(s)\npb394920021\n\n\n","n":0.049}}},{"i":44,"$":{"0":{"v":"Introverted","n":1}}},{"i":45,"$":{"0":{"v":"Personality","n":1},"1":{"v":"\n# 优点\n\n谈到作为一个内向的人的优点，你可能会从一种倾向中受益。\n\n→ 深度思考者。深度思考在很多方面都有好处，包括促进解决问题的能力和进行令人着迷的对话。\n\n→ 领导者是天生的。因为他们倾向于在采取行动或做出决定之前进行反思，所以内向的人可以成为伟大的领导者。\n\n→ 谨慎：内向的人在做决定之前往往会慢慢来。在了解另一个人、建立业务关系或权衡决定的风险和收益时，这可能非常有用。\n\n→ 创造性。内向的人往往有很强的想象力，这可能导致对工作项目和约会等事情产生创造性的想法。\n\n→ 观察力强。因为内向的人经常坐下来观察环境或情况，他们可能会注意到一些快速反应的外向者所忽略的小细节。\n\n→ 知识渊博。如果你是一个善于思考的内向者，那么你可能喜欢学习。学习导致更多的知识，这可以产生更多的谈话，也有能力教导他人。这也会使你成为一个伟大的小品队友!\n\n→ 寻求有意义的联系。由于内向的人在互动和关系方面喜欢质量而不是数量，他们经常花时间去了解他人，无论是商业伙伴还是约会伙伴。\n\n\n# 缺点\n\n当谈到低谷时，你可能有挣扎的倾向。\n\n→ 为了适应环境而过度补偿的人。因为内向的人被期望适应外向的世界，他们可能无意中过度补偿，以适应规范。例如，为了参与谈话，内向的人可能会过度说话而不听，导致所有人都不满意的经历。\n\n→ 容易被淹没。太多的刺激会使内向的人的神经系统不堪重负。这可能导致注意力分散或无法集中--当你试图了解一个新的人时，这不是最好的特征。\n\n→ 沟通速度较慢。内向的人往往需要时间来处理信息，然后再对他人作出回应。\n\n→ 谨慎：正如这是一个高点，它也可能是一个低点。如果一个内向的人在考虑一段关系或一个决定时时间太长，他们可能会错过一个机会。\n\n→ 有时被忽视。内向的人可能倾向于远离人群，而不是混在人群中。在课堂上，当你不想被要求在别人面前说话时，这可能是可行的，但对于工作晋升或试图获得约会来说，这并不理想。\n\n→ 不总是被邀请参加活动。因为内向的人不需要那么多时间与他人相处，朋友或家人可能在无意中忘记邀请内向的人参加自发的聚会。\n\n→ 被视为有缺陷。由于我们的社会可能期望内向者适应理想化的外向世界，许多内向者被视为有缺陷，其他人试图修复他们，而不是拥抱他们自己。\n","n":0.243}}},{"i":46,"$":{"0":{"v":"Dating","n":1},"1":{"v":"\n# questions to ask myself\n\n→ 你希望约会能导致关系吗？\n\n希望获得长期关系\n\n→ 你想从这段关系中得到什么？\n\n一起出游的伙伴，互相支持的人生伴侣\n\n→ 你是否在寻找一个具有类似性格特征的人，他也欣赏独处的时间，只需要每周见你几次或每月见几次？\n\n我希望还是有自己的独处的时间，40%独处，60%一起玩。多见见\n\n→ 你想找一个有类似价值观和生活目标的伴侣吗？\n\n是的 兴趣可以不同，价值观要一致，可以玩到一起去。\n\n# 挑战\n\n忽视你的界限\n\n由于内向的人在约会时面临的挑战，你可能试图把自己塑造成你认为伴侣希望你成为的人。\n\n内向的人往往重视深入的联系和隐私。是否可以说，在建立真正的联系之前，你不经常向他人展示自己？你是否不愿意与多人约会，因为认识新朋友的能量很低，而且渴望深度联系而不是肤浅的接触？如果这些描述听起来是对的，我敢打赌，你更有可能一次只关注一个约会对象，这可以导致深入的联系。\n\n\n对内向者来说，另一个挑战可能是放手那些没有进展或已经结束的关系。同样，内向的人倾向于只向那些与他们有深刻联系的人透露自己的脆弱部分。这可以培养出对他们所交往的人的强烈依恋感，甚至在约会的早期阶段。虽然这是一种令人钦佩的品质，但当事情没有成功时，它可能会导致强烈的失望，难以放手和继续寻找新的人。\n\n请记住，你需要大量的精力来形成深刻的联系，当事情没有像你希望的那样发展时，你会觉得好像你失败了或浪费了你的时间。事实并非如此!是的，建立关系可能需要大量的精力，但结果可能是美好的。\n\n# 优势\n\n- 我的内向的朋友，倾向于更多的选择，由于你有能力放慢脚步，仔细思考问题。而距离允许清晰的思考和深思熟虑的决策。\n- 内向的人在进入主题和开始真正的谈话之前不会把时间浪费在闲聊上。直奔主题并不是不可取的，不过我建议要注意它可能会给另一个人带来的影响。试试这个。请一位与你关系密切的朋友与你进行角色扮演。让他们为你表演你与他们或其他人开始谈话的方式。注意观察，你就会知道别人与你交谈时可能会有什么感受。这个活动可以表明你是否需要调整你的沟通方式。或者你可以只做你自己。\n- 可以计划创造性的和有趣的时间\n- 分歧后不轻易下结论\n- 内向的人有一种自然的倾听倾向。这有些来自于内向者的自然安静，这使他们能够在关注说话者的同时，静静地坐着。与外向者不同的是，外向者可能在谈话中占主导地位，或在别人发言时插话，内向者为别人创造空间，直到他们发言完毕。这给了说话者空间，也给了内向者时间来接受别人对他们说的话。这不仅有助于在约会时形成更有意义的互动，还可以帮助你的约会对象感到更加自在。\n\n## 沉默\n\n沉默也可以是许多其他的东西，包括耐人寻味的和诱人的--这可以使内向的人在约会中获得乐趣并增进关系。外向的人经常用语言和声音来填补任何安静的空间。内向的人不仅可以拥抱沉默，而且可以享受沉默，并可以利用这种沉默来发挥他们的优势，特别是在关系的开始阶段。在这一章中，我们将探讨如何在约会时靠拢到位的安静，而不是试图跟上健谈的伴侣。我们还将研究当一段关系开始形成时，孤独的作用，以及你如何能在互动中取得平衡。\n\n\n# 保持约会\n\n做法\n\n→ 每周至少抽出时间见你的伴侣一到两次。\n\n→ 享受共同的爱好或兴趣。\n\n→ 享受彼此间的互动，不涉及其他人或物品（如电脑或手机）的干扰。\n\n→ 每天至少分享一件关于自己或自己一天的有趣事情。\n\n→ 在你的一天中留出只属于你自己的时间，并让你的伴侣知道这一点。\n\n→ 从在线零售商那里购买一套对话卡，看看你们对对方有什么了解。(请看我在资源部分的建议）。\n\n→ 为亲密关系创造时间和空间，即使你必须为亲密时间计划一个具体日期。\n\n\n\n不要\n\n→ 谈论关系中的 \"洗衣清单\"，例如你们的分歧、财务或家务事。\n\n→ 谈论其他人，如朋友或家人。\n\n→ 给自己打双份电话，使你的注意力从你的伴侣或关系上移开。\n\n→ 跳过约会之夜或计划中的相处时间。如果有重要的事情发生，重新安排时间。\n\n→ 认为你们的关系有太多的距离是片面的；维持一段关系总是需要两个人。\n\n# 和内向的人\n\n如果你发现自己和一个内向的人在一起，记得在关系中培养自己的个性，包括安排好彼此的时间和离开对方的时间。伴侣双方都应该努力。\n\n→ 与你自己的社会团体保持联系。\n\n→ 与自己的朋友保持单独的朋友时间，定期进行朋友约会。\n\n→ 在没有对方的情况下享受爱好，以便有时间分开，就你们的个人生活进行新的有趣的谈话。\n\n→ 安排定期的关系检查，看看事情是否停滞不前。\n","n":0.164}}},{"i":47,"$":{"0":{"v":"Online","n":1},"1":{"v":"\n# profile\n\n要真实。不要试图把自己表现成一个不是自己的人。在你的简介中展示真实的自己，而不是你认为你应该是谁，包括一个外向的人。人们会发现你的虚伪和不真实。也许你是一个巨大的游戏玩家，照顾一个由36盆植物组成的家庭，或者是一个获奖的排舞者。不管是什么让你心动，通过分享你的激情，你更有可能吸引那些欣赏你的人。这也延伸到你在个人资料上张贴的照片。不要觉得你需要张贴最讨人喜欢的照片。真实性是有吸引力的，一张展示真实微笑或不经意的时刻的照片很可能比 \"完美 \"的摆拍更能展示你的真实个性。\n\n描述你自己，让别人以一种积极和耐人寻味的方式看待你。你希望别人把你看成是胆小、害羞的人，还是有思想、善于表达的人？你是把自己描述成 \"沉迷于...... \"还是对新事物的狂热学习者？想一想你希望别人有足够的兴趣与你交谈的原因，并写下这些品质。\n\n让一个朋友阅读你的资料并给予反馈。朋友会从外部角度阅读，并分享另一个人如何看待你的资料。他们可以指出什么地方听起来很讨人喜欢，或者什么地方听起来不像是你。他们也可能指出你没有考虑到的特征或特性。\n\n你想与陌生人分享哪三到五个事实？如果你目前有一个约会档案，看看是否列出了这些事实。\n\n","n":0.408}}},{"i":48,"$":{"0":{"v":"Meet_people","n":1},"1":{"v":"\n将它放入游戏中\n\n与其在你知道自己会感到不舒服而无法发挥你的最佳水平的情况下受到压力，不如考虑如何在现实生活中以对你来说更舒服的环境来认识他人。有许多方法可以让内向的人保持自我，保持他们的能量，并在现实生活中与人会面时获得乐趣。\n\n## 与人会面的想法\n\n与有共同兴趣的人见面的好处是，你已经有了共同的东西，可以跳过相亲或试图与陌生人找事做的尴尬局面。作为一个内向的人，通过做一些你感兴趣的事情，而不是仅仅为了找一个约会而参加活动，你更有可能感到参与和精力充沛，而不是疲惫不堪。这里有一些在国际上认识人的好方法。(在下一章中，我们将探讨在现实生活中与人见面时如何改进你的小谈话）。\n\n→ 参加一个课程。你是否一直想提高你那破旧的高中法语？也许你一直对掌握墨西哥烹饪感兴趣。不管是什么，上课是提高自己的一个好方法，同时也可以在一个低压力的环境中认识其他人。\n\n→ 为你关心的事业做志愿者。无论是在当地的动物收容所或社区花园，志愿服务可以是一个很好的方式来满足那些与你有共同兴趣并与你的价值观一致的人。\n\n→ 举办一个晚宴或烧烤，让你的朋友邀请一个单身朋友。这是另一种认识新朋友的非恐吓性方式。有你的朋友在身边意味着你不必只和陌生人说话，再加上有一个共同的朋友意味着你们已经有共同的东西。\n\n→ 到户外活动。无论是徒步旅行团、跑步俱乐部，还是每周在公园里的冥想或瑜伽聚会，到户外去都是认识志同道合者的好办法，而不必在豪饮的酒吧或俱乐部里在嘈杂的音乐中交谈。\n\n## 注意点\n\n保持约会的低调和简短。在本书的前面，我鼓励你建立一个第一次约会的地方的清单。我还建议让这些地方保持低调--活动较少的地方，不太可能拥挤。此外，保持短暂的约会，选择一个能支持短暂约会的地方。下班后的咖啡或饮料可以是简短的约会，或者不那么简短。你可以根据情况决定多快喝完你的饮料。\n\n不要把约会安排在你已经有社交活动的日子。如果你在与朋友、家人或同事应酬的日子里与你的约会对象见面，你已经筋疲力尽，可能不期待这次约会。你也可能在约会时投射出你的疲惫，而不能成为最好的自己。\n\n不要同时和太多的人约会，但也不要觉得你需要只和一个人约会。太多的人可能会导致约会倦怠。太少的人可能导致片面的经验，如果对方在和其他人约会，并在你没有约会的时候分担他们的时间和精力。这可能会导致你在这段关系结束时感到受伤和被打败，然后才会有更多的进展。我不能告诉你一个确切的数字，因为每个人都是不同的。我确实建议尝试与两到三个人约会，看看情况如何。\n","n":0.378}}},{"i":49,"$":{"0":{"v":"Chat","n":1},"1":{"v":"\n- 大多数内向的人都有天生的好奇心\n- 有一个关于你自己的话题清单，并查看对方的资料，以寻找可以问他们的话题。\n- 不要过早地跳入深渊。不要透露太多，也不要过早地问个人问题。坚持当前的目标，如训练马拉松或购买新房。这可以导致更深入的对话，你可以更多了解这个人。\n- 要有表现力。肢体语言也是一种交流形式。它可以表达诸如兴趣或兴奋的信息，或提出问题。它也可以表达相反的意思。有一次，在观看自己的视频时，我记得这个话题让我非常感兴趣，我对谈话非常兴奋。然而，我却面无表情，没有任何情绪。这不是我想发出的信息试着与朋友进行对话，并征求对你身体语言的反馈意见，或者观看自己的视频，看看你可能在向别人传达什么。\n- 顺其自然。内向的人可能容易过度思考问题。","n":0.408}}},{"i":50,"$":{"0":{"v":"Belief","n":1}}},{"i":51,"$":{"0":{"v":"Bazi","n":1},"1":{"v":"\n# 八字\n\n## 八字的组成\n\n八字由年月日时四个部分组成，每个部分都有一个天干和一个地支，天干和地支组合起来就是一个八字。\n\n## 阴阳\n\n“阴阳”最初的含义很简单，朝向日光的为“阳\"，背日光者为“阴”。\n\n## 五行\n\n五行是古代中国人对自然界万物的分类，是中国古代哲学的重要组成部分。五行包括金、木、水、火、土五种元素，五行之间相生相克，相生的关系是：木生火，火生土，土生金，金生水，水生木；相克的关系是：木克土，土克水，水克火，火克金，金克木。\n\n![](/assets/images/2023-06-14-22-31-33.png)\n\n## 命运\n\n人，作为天地之间的一个实体，存在于天地之间，跟天地是息息相通的。天地是个大宇宙，人是一个小宇宙。在“气一阴阳一五行”的框架下，字宙生生不息的运动过程，可以表现为气的运动。而气的运动状态又可以通过阴阳的消长、五行的流行来予以认识和描写。\n\n命:出生时所对应的宇宙状态\n运:命的外部环境一不流断变的宇宙状态\n命理学:以人的出生时间为依据，去描写和预测其生命过程的学说\n","n":0.408}}},{"i":52,"$":{"0":{"v":"Symbol","n":1},"1":{"v":"\n# 干支\n\n## 天干\n\n“干”，古人最初仅用来纪日。每天的计算以日出、日没为准，日出一次就是一天，所以“干”又\n叫“天干\"。天干有十个，按序为:甲、乙、丙、丁、戊、己、庚、辛、壬、癸。\n这样，用十个天干纪日，正好为一旬。\n\n## 地支\n\n“支\"，最初是用来纪月的。每一个月是用月亮的盈亏来计算。月亮盈亏一次，就是一月。地支有十二个，古时也称十二辰，按序为:子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥。\n\n## 模型\n\n![](/assets/images/2023-06-14-22-37-29.png)\n\n## 藏干\n![](/assets/images/2023-06-14-23-11-02.png)\n\n各支所藏的第一位是这个地支的本气，如寅中第一位所藏是甲木，为其本气，其他是附属之气。如果对照五行生旺死绝历程，地支实、申、已、克为“四长生\"。辰戌丑未四墓库，各藏三物，谓之杂气。。子、午、卯、酉为“四专气”(也称“四仲”、“四正”)，因为各藏一物。\n至于午中之己，是附丁而生。\n\n## 刑冲会合系统\n\n### 合\n\n天干五合:甲与已合;乙与庚合;丙与辛合;丁与壬合;戊与癸合。\n地支六合:子与丑合;寅与亥合;卯与戌合:辰酉合;已与申合;午与未合。\n\n\n### 冲\n\n相冲也有相克的含义。从方位看，都是两方处于相互敌对的位置(如甲在东，庚在西;卯在东，酉在西)，就五行而言，都是相克的(康如金克甲木;子水克午火)，就阴阳而言，都是阳克阳、阴克阴《如甲、庚都为阳，卯、丁都为阴，阴阳不能配合，故发生冲突。因为相克是无情的表现，相冲一般不以吉论。\n\n### 害\n\n六害”的形成原因是“五行所恶，其在破冲。今之相害，以与破冲合。和比如，子与午相冲，而午与未相合，所以子与未之间就构成了相害的\n关系\n\n### 刑\n\n### 会方\n\n东方木: 寅卯辰\n南方火: 巳午未\n西方金: 申酉戌\n北方水: 亥子丑\n\n\n## 三合\n\n木局: 亥卯未\n火局: 寅午戌\n金局: 巳酉丑\n水局: 申子辰\n土局: 辰戌丑未\n\n会方的力量最大，会局的力量次之，六合又次之，半会局再次之。\n\n![](/assets/images/2023-06-14-23-09-03.png)","n":0.213}}},{"i":53,"$":{"0":{"v":"Strong","n":1},"1":{"v":"\n一般的原则是观察日主是否:(1)得令，(2)得地，(3)得助。\n所谓“得令“，就是指八字中月令地支属于日主旺相的季节。比如，日主\n甲木生于春冬，就是得令。得令自然强盛。\n\n所谓“得地\"，是指日主在年、日或时的地支上有根基。比如，日主甲木\n在年、日或时的地支上见到寅、卯或亥，\n所谓“得助，是指四柱多帮扶。比如日主甲木，四柱干支多见水和木。\n因为水可以生扶甲木，木可以比助甲木。\n一般来说，\n(1)既当令，又多帮扶，视为“最强”;\n(2)失令但多帮扶，可视为“中强”;\n(3)虽不当令，也少帮扶，但年、日、时支得根基，可为“次强”，\n(4)虽当令，但年、日、时地支无根基，为“次弱”;\n(5)虽当令，但四柱多克泄，则为“中弱”，\n(6)既失令，又多克泄，是为“最弱”。\n对于日主强弱比较明显的八字，这样的观察已经可以得到基本的强弱\n\n![](/assets/images/2023-06-14-23-17-02.png)\n\n","n":1}}},{"i":54,"$":{"0":{"v":"Shishen","n":1},"1":{"v":"\n# 十神\n\n所谓的“十神”，是指日干与其他成分的阴阳五行之间关系的代名词。具体来说，当我们确定了八字结构中日柱天和干为日主，也就确定了日主的阴阳五行属性。日主是十个天干中的一个。那么，它与可能遇上的其他十个天干之间将构成怎样的关系呢？\n\n前文已经谈过，由于有地支藏遁，地支可以表述为不同的天和干成分。因此，要讨论日主与结构中其他七个干或支的关系，都可以统一到天和干符号上来。\n\n所以确定它们之间的关系，并冠以一定的名称，是分析工作的开始，也是进一步剖析的必要前提。因为有十种关系，就有了十种名称，统称为“十神”。它们是：比肩、劫财、伤官、食神、正财、偏财、正官、七杀、正印、偏印。\n\n![](/assets/images/2023-08-11-19-57-28.png)\n\n- 「生我」者，指的是正印、偏印。\n- 「我生」者，指的是伤官、食神。\n- 「克我」者，指的是正官、七杀（也称偏官）。\n- 「我克」者，指的是正财、偏财。\n- 「同我」者，指的是比肩、劫财。\n\n![](/assets/images/2023-08-11-19-59-43.png)\n\n","n":0.378}}},{"i":55,"$":{"0":{"v":"Geju","n":1},"1":{"v":"\n# 格局\n\n这些格局是八字学中的一种分类方法，用于描述一个人的命盘特点和命运。它们是：\n\n- 傷官格\n- 食神格\n- 正財格\n- 偏財格\n- 正官格\n- 七殺格\n- 正印格\n- 偏印格\n- 建禄格\n- 劫刃格\n\n\n每一种格局都有特定的含义和对应的人生特质，可以帮助我们深入了解一个人的性格、才能、运势等方面。\n\n选择八字格局并不是一个随意的过程，而是要根据八字结构中存在的各种势力来进行。简单来说，你需要比较八字结构中的各种势力，从中选择最能影响此结构的主导力量，以此（十神）为格局。\n\n\n月令地支在八字学中起着提纲挈领的作用。它代表了命造主人出生当时当地的天地之气，因此结构中的主导势力往往发生在月令的主气或附属之气中。\n\n换句话说，月令地支反映了一个人出生时特定月份和地区的气候和自然环境，这些因素对个体的性格和命运有着深远的影响。\n\n因此，在选择格局时，从月令地支之气中寻找透出天和干的十神，将其作为格局，也成了命理学中一般的选择格方法。这一方法有助于确定命造的主要方向和趋势。\n\n## 建禄格\n\n![](/assets/images/2023-08-11-20-32-23.png)\n\n“建禄”格是指当八字的月令地支与日主的“禄”相符合时的格局。这是一个很吉利的格局，通常代表着日主在月令地支中能够得到强大的支持和助力。\n\n## 劫刃格\n\n“劫/阳刃格”是指当日主是四个阳干（甲、丙、庚、壬）中的一个，并且生于各自的阳刃地支时，构成的特殊格局。\n\n\n\n# 用神\n\n[[life.belief.bazi.shen]]\n\n# 格局高低\n\n构成格局的主要因素：\n\n单纯：格局应该是“单纯”或“清”的，不要“混杂”或“浊”。比如，如果主导势力是七杀，就不要再混入正官。正官和七杀混杂，尤其是在天干上，就变得“浊”了。单纯的格局就像没有瑕疵的钻石。\n有力：格局还要有力量。比如，毛泽东的命造，七杀通根于月支子水，是月令当旺之气，十分有力。这个七杀，作为主导势力，是非常有力量的。\n\n\n评价格局的标准：\n\n有力：一个优秀的格局应该是有力的，这意味着主导势力在结构中占据了重要地位，并能对其他元素产生影响。\n\n","n":0.25}}},{"i":56,"$":{"0":{"v":"Detail","n":1},"1":{"v":"\n# “正官格”特点\n\n职业与性格：正官格的人往往与政府、官职、社会地位等有关，代表尊贵、律己、保守、洁身自爱、温文尔雅等特质。\n领导与管理：具有领导资质和管理才华，行事稳重，情感理智，按照上级领导指示努力推行，容易受到群众的信任和尊敬。\n“正官格”成格条件：\n日主本身须健旺：日主健旺才能享受正官的尊贵和福气。如果日主太弱，则可能无法发展，甚至可能因受到过度的“约束”而变得庸俗无能、优柔寡断、缺乏魄力和决断。\n官星须“纯”，只许“一位”，多则不宜：过多的官星可能导致空有名位但无实权的情况，表示“约束”过度，政治上可能无法成就大业。\n\n# “七殺格” 特点：\n象征意义：七殺代表暴力之气，象征不服输、好勇斗狠、權威、勢力、威刻、權柄等。在古代，与偏官联系的是“异途功名”，即通过非传统途径晋升仕途的官吏，多为武职。\n性格特点：七殺对日主是同性相敬，非常激烈和无情，因此人们在看八字时非常重视七殺。\n\n“七殺格”成格条件：\n\n命局身强殺星亦旺：如果七殺强旺但对日主无害，而且难为日主所用，此时如果命有食神来制殺，则殺星可以为自己所用。这就是“食神制殺”格局，这样的命局往往能大富贵。\n\n逢殺看印：如果命局中殺旺而遇印星，特别是日主弱而殺旺的情况下，见到印星显得更为重要。因为印星可以化殺，同时生身，一举两得。这种配置也称为“殺印相生”格，也是大富贵之人的特征。\n\n总结：\n“七殺格”是一个充满战斗力和魄力的格局，它与权力、地位、勇气和酷劲有关。成功的七殺格的人可能非常富有，掌有实权，文武兼备。\n\n# 正财格特点\n\n象征意义：正财一般代表正常收入，固定的钱财，或辛勤赚来的钱财等。 \n\n性格特点：\n刻苦耐劳：具有正财格的人比较刻苦耐劳，勤劳节俭，爱惜金钱。\n重视家庭：他们重视家庭生活，对妻儿负责任。\n现实诚实：性格上比较现实、诚实，性情温和，脚踏实地。\n容易被视为守财奴：由于他们对钱财的重视，容易被人视为守财奴。\n缺乏戏剧性：正财格的人比较安守本分，因此人生旅途相对平稳、平淡，缺乏戏剧性表现和成就。\n\n成功的正财格条件\n\n得时乘星：正财通根月令，才能叫“得位”；“得位”才能“乘旺”；“乘旺”才能“有力”。\n日主有力：日主有力，财通“门户”，是正财格成功的基本条件。\n不偏正混乱：正财格不宜偏正混乱，不重叠多见。\n身强之财格喜官星透露：身强之财格，喜欢官星透露，一方面，财可以生官以求贵；另一方面，官星可以制比劫以护财，使财源无损。\n\n\n正财格的人通常是实际、诚实和有责任感的人。他们可能在金钱方面比较谨慎，但这可能是因为他们珍视家庭和稳定的生活。正财格可以被视为一种追求稳定和安全的格局，但也可能缺乏冒险和创造力。\n\n\n\n\n# 偏财格特点\n\n\n- **象征意义**：偏财代表流动性较高的钱财，非常容易来去，也代表众人的财富。\n- **性格特点**：\n  - **慷慨豪爽**：偏财格的人通常慷慨、豪爽，乐观进取。\n  - **机智灵活**：他们机智、灵活，擅长利用时机，赚取金钱。\n  - **樂於助人**：他们乐于助人，因此常能获得好的人缘。\n  - **不太在意金钱**：由于偏财来去容易，他们对金钱并不那么在意，往往一掷千金。\n  - **善用计谋**：偏财格的人懂得权变，手段灵巧，善用计谋。\n- **事业方面**：\n  - **事业心重**：他们事业心重，做事干净利落，速战速决。\n  - **容易白手起家**：善于利用时机，容易白手起家，独创事业，成为工商界之风云人物。\n- **感情方面**：\n  - **常有喜剧性的离合**：在金钱和异性方面，常有喜剧性的离合得失。\n\n### 总结\n\n偏财格的人通常活力四射，充满魅力，他们擅长利用时机，对金钱的态度也较为豁达。这种格局可能会让人觉得非常迷人和富有吸引力。人们可能会被他们的机智、乐观和进取的精神所吸引。不过，这种格局也可能让人觉得他们在金钱方面有些随意，甚至可能在感情方面有些复杂。٩(◕‿◕｡)۶\n\n\n# 正印格特点\n\n- **象征意义**：正印无论在男女命中，代表母亲、长辈、师长、贵人。也象征印鉴、权柄、文书、名誉等。\n- **性格特点**：\n  - **高雅人情**：具有正印格的人气质高雅，内外向适中，富有人情味。\n  - **追求学问**：他们追求学问，重视精神生活，为人慈祥、有耐心。\n  - **不计较是非**：他们不计较是非，有长者之风，但过旺时可能略有自私自利之嫌。\n  - **得长辈照顾**：常得长辈照顾，也容易造成依赖性，理想容易脱离现实。\n- **生活方面**：\n  - **知足常乐**：由于知足常乐，飲食正常，平生少病灾，纤遇风险也能逢凶化吉。\n  - **不喜亲自动手**：有时会因爱惜颜面而打肿脸充胖子。\n- **职业方面**：\n  - **清高廉洁**：正印格内若能官印相生，其为人则清高廉洁，多为好官。\n  - **有官有印**：地位和权柄方能得以固定。\n  - **不易贵显**：正印格遇到身旺而不见官星的情况下，不易贵显。\n\n## 总结\n\n正印格的人具有一种高雅和温文尔雅的气质，他们对学问和精神生活有着强烈的追求。他们通常享受长辈的恩惠和庇护，性格上表现出慈祥、耐心和人情味。这样的人可能在职业上表现出清高廉洁，成为受人尊敬的好官。不过，正印格也可能让人过于依赖他人，理想容易与现实脱节。\n\n\n# 偏印格特点\n\n- **象征意义**：偏印代表继母或偏母，也代表亲族长辈，象征偏业之权柄、智慧，文书印鉴、创造发明等。\n- **性格特点**：\n  - **内向怪僻**：偏印格的人比较内向，有点儿怪僻、脱俗、人怪异、忧郁。\n  - **强幻想力**：他们的幻想力较强，有相当高的领悟能力，喜欢奇门异术，善于创造发明。\n  - **善保密**：做事讲究技巧，喜怒哀乐不显于形。\n  - **学艺不足耐心**：虽好学艺，但耐心不足，常半途而废。\n  - **孤独性格**：为人孤独，常会离群索居。\n- **生活与职业方面**：\n  - **不喜见食神**：有偏印时就不喜见到食神，否则可能出现个性暴戾、求谋不顺等问题。\n  - **可能损子**：无论男女，都可能损子；行运崎岖之时，也会灾祸连连。\n  - **可用财制印**：在身强的情况下，可以用财来制偏印，反而能获得成功，但可能会“弃祖业”，自行创业。\n\n### 总结\n\n偏印格的人通常具有一种内向、怪僻的性格，他们的幻想力较强，善于创造和发明。在职业上，他们可能追求偏业的权柄和智慧，但也可能出现求谋不顺、灾祸连连的情况。偏印格与正印格的主要区别在于对财星的态度和对食神的忌讳。(｡･ω･｡)ﾉ♡\n\n\n# 伤宮格的特点\n\n- **象征意义**：伤宮代表对“正官”的伤害，也代表了聪明和才华的流露。\n- **性格特点**：\n  - **聪明才智**：伤宮格的人内心充满才智和活力，因此具有较高的聪明才智。\n  - **好胜强出**：他们喜欢表现，好胜心强，鋒芒毕露。\n  - **不满现实**：容易不满现实，厌恶传统的约束，具有叛逆性。\n  - **一意孤行**：常侍才傲物，一意孤行。\n- **生活与职业方面**：\n  - **务要伤尽**：成功的伤宮格要求“务要伤尽”，即四柱不见一点官星。\n  - **宜见财**：伤宮格最宜见财，这样可以流通伤官的秀气，用伤宮的才智去生出财富来。\n  - **伤官生财格**：伤宮格与财的组合称为“伤官生财”格，虽不明见官星，但财暗中还是能生出官来。\n  - **伤官佩印格**：伤宮格与印的相互配合称为“伤宮佩印”格，是贵格。\n\n### 总结\n\n伤宮格的人具有鲜明的个性和独特的才智，但也可能带有叛逆和一意孤行的倾向。在生活和事业方面，他们需要避免官星的出现，而与财和印的组合则可能带来成功和贵气。总的来说，伤宮格的人可能在职业和社交方面表现出色，但也需要注意性格上的缺陷和挑战。\n\n# 食神格的特点\n\n1. **象征意义**：食神一般被认作是善神。它有助于生财，为我们提供财富的源头；同时，食神能制七杀，帮助我们避免危险和灾害。\n2. **身体与性格特点**：食神格的人通常身体肥大，风采飘逸，优游自在，个性温和。\n3. **家庭与生活**：食神格的人常常享有子孙满堂的幸福，有着较长的寿命，生活安稳。\n4. **工作与事业**：食神格的人在谋事方面往往比较容易，能够安享成功和财富。\n5. **格局要求**：食神格要求身、食俱旺。如果出现身印（偏印），则为破格，因为偏印会削去食神，称为“身印夺食”。\n\n### 总结\n\n食神格是一个代表着富饶、优雅、安享和谋事容易的命格。具有食神格的人常常能在生活中享受到丰富的物质和精神财富，同时也享有家庭的温暖和幸福。\n\n但是，食神格也有其特定的要求和限制，如需要避免出现偏印等。因此，理解和运用食神格的人需要注意平衡各方面的因素，才能充分发挥其潜能。\n","n":0.1}}},{"i":57,"$":{"0":{"v":"Shensha","n":1},"1":{"v":"\n# 神煞系统\n\n日干\n\n![](/assets/images/2023-06-14-22-52-19.png)\n\n天乙贵人:吉神，主聪敏智慧，易近贵人。\n文昌:吉神，主聪明过人，凡事估凶化吉。\n干禄:吉神。禄是傣禄，是养命之源。禄在年支，叫做光禄，禄在月支，叫做建禄，禄在日支，叫做专禄，禄在时支，叫做归禄。一律均怕入空亡或犯冲。\n羊刃:羊，有时写作“阳\"，是刚的意思。丸即刀刃，是空割的意思。羊刃比禄更强旺有力，主刚烈招祸，属凶黎。有的书主张，五阳干有刃，五阴干无刃。\n红艳煞:主浪漫、色情。\n\n日支\n\n![](/assets/images/2023-06-14-22-54-19.png)\n\n将星:主有领导能力，可掌权柄。\n华盖:主性情恬淡，资质聪颖，但难免孤独，易倾向哲学、宗教\n驿马:主迁动。古代又为传送官府文书的机关，驿马是传递官文书的交通工具。所以又马通常代表动态。驿马可吉可凶，视与原局五行配合论断。\n桃花:又名咸地，主风流酒色。\n劫煞:劫者，夺也。自外夺之谓之劫。多是非破财。\n亡神:亡者，失也。自内失之谓之亡。易是非官讼。\n\n年支\n\n![](/assets/images/2023-06-14-22-55-33.png)\n\n![](/assets/images/2023-06-14-22-56-03.png)\n\n## 三奇\n\n天上三奇：甲戊庚\n地上三奇：乙丙丁\n人中三奇：壬癸辛","n":0.577}}},{"i":58,"$":{"0":{"v":"Shen","n":1},"1":{"v":"\n## 扶抑用神\n\n它的功能是帮助命局恢复平衡。因为它涉及命局的日主强弱问题，这类“用神”也就称为“扶抑用神。\n\n扶抑策略:衰者宜扶，强者宜抑，过强者宜泄\n\n\n## 调候用神\n\n![](/assets/images/2023-08-11-19-44-17.png)\n\n## 格局用神\n\n看这个用神怎么和格局联系起来，帮助日主。\n\n如何处理七杀：对于七杀这个“凶神”，最好的方法是“制”或“化”。如果日主自身较强而七杀旺，最宜用食神来制约七杀；如果自身弱而七杀旺，则应见印星（正印或偏印），用印来化杀而生身，即用“化”的手段，让七杀生印，印生自身，从而取得平衡。\n\n在水（七杀）和日主火之间的木（正印、偏印）可以担任“化”杀功能。\n\n![](/assets/images/2023-08-11-20-22-47.png)\n\n### 什么是“顺用”？\n\n“顺用”是指在八字分析中，选择与主导格局相生的五行作为用神，而不主张采取制约的手段。这是一种顺应格局内在性质的方法，强调和谐和平衡。\n\n### 如何应用“顺用”？\n对于正官格、正财格、偏财格、印格（主要是指正印格）和食神格，在选择用神时，主要寻找顺生的五行。\n不主张采取制约的手段。如果出现制约，常被认为是“破格”。\n\n\n### 什么是“逆用”？\n\n“逆用”是指在八字分析中，选择与主导格局相制约（烈制）的五行作为用神。与“顺用”强调和谐相生不同，“逆用”采取的是制约的手段。\n\n### 如何应用“逆用”？\n\n对于七杀格、伤官格、偏印格和劫刃格，在选择用神时，可以采取“制约”的手段。\n\n\n![](/assets/images/2023-08-11-20-30-16.png)","n":0.354}}},{"i":59,"$":{"0":{"v":"Liunian","n":1},"1":{"v":"\n# 流年","n":0.707}}},{"i":60,"$":{"0":{"v":"Life","n":1},"1":{"v":"\n![](/assets/images/2023-06-14-23-15-09.png)\n\n生死旺衰历程分成了十二个阶段，并配和十二个月中。这十二阶段是:长生、沐浴、冠带、临官、帝旺、衰、病、死、墓、绝、胎、养。它们各自的含义是:\n长生一一犹如遇儿之初生。\n沐浴一一犹出生后沐浴去垢，指幼儿阶段。\n冠带一一犹人渐长而需冠带。\n临官一一好像人由长而壮，可以出仕做官了。\n帝旺一一好像人的体力、智力都到达最旺的时候了。\n衰一一盛极而衷，开始走下坡路了。\n病一一由衰败而生病。\n死一一由病而死。\n曹一一死而埋匡入墓。\n绝一一前气已绝，后气将续。\n胎一一后气继续结气成胎。\n养一一好像人养胎于母腹之中。","n":1}}},{"i":61,"$":{"0":{"v":"History","n":1},"1":{"v":"\n# History\n\n## 徐子平\n\n明朝\n\n- 徐子平首先确立了四柱论命的框架 。\n- “专主五行，不主纳音\"\n- 十分重视“财官\"。\"财”指钱财,“官”即官贵。\n\n## 徐大升\n\n渊源\n\n- 完成十神体系\n- 在关系层面定义六亲的关系。\n- 也提出了“中和”的原则。\n- 用神\n- 格局\n\n## 万民英《三命通会》\n作为命理学形成时期的集大成著作，是明朝中叶出现的《三命通会》。","n":0.267}}},{"i":62,"$":{"0":{"v":"Time_management","n":1},"1":{"v":"\n时间管理，精力管理的第一原则：比做什么更重要的是决定不做什么。\n\n","n":1}}},{"i":63,"$":{"0":{"v":"Sport","n":1}}},{"i":64,"$":{"0":{"v":"Rockclimb","n":1},"1":{"v":"\n\n# 如何攀岩\n\n- 一定要穿专业的鞋子。\n- 攀岩的重点是把重心都放在脚趾上。\n- 在向上爬的时候要先思考好你的手怎么放。\n- 手是支点和引导点，帮助你往上爬的。脚帮你站起来\n","n":0.408}}},{"i":65,"$":{"0":{"v":"Social","n":1},"1":{"v":"\n\n# 核心的社会动机\n\n## 归属\n\n在支配社会生活的所有动机中，最重要的是归属：我们渴望与他人建立稳定、有意义的联系。 51 在与两个彼此看不见的陌生人玩网络球时，即使是轻微的排斥也会在我们的大脑中触发类似于身体疼痛的警报。那些回忆起被排除在外的事件，或者在实验室的一场短暂的游戏中被排除在外的大学生，后来评价自己比那些没有被排除在外的人更差。\n\n长时间的非自愿隔离不仅会令人感到不愉快，而且在心理上是有害的，会产生抑郁、焦虑和自我毁灭的冲动。\n\n## 理解他人和准确预测\n\n人类有强烈的动机来准确地感知和理解周围的人和情境，准确地把握人生的航向，并确保我们的人际关系得以优化。我们期盼能够预测将会发生什么，并对所发生的事情做出解释。\n\n## 控制\n\n确定性甚至是不幸的确定性，满足了第三种强烈的社会动机：控制的需要。我们希望拥有指导我们行动的自主感和能力并确保事情成功。控制感会让我们体验到幸福，因为它让我们感到自己可以主动且有能力去完成事情。缺乏控制的感觉会令我们不愉快，从长远来看，也是不健康的。\n\n对许多人而言，控制感是幸福的核心。当他们不能进行控制的时候，他们的行为却在显示仿佛他们仍然具有控制的能力。\n\n\n## 被重视需要\n\n人类具有让自己感到有价值的强烈动机，希望自己在所在社区中有社会地位、有积极的声誉。信任作为社会性动物，我们不相信别人就无法生存。尽管进化赋予了我们消极的偏见，出现“坏事比好事更有威力”的效果，但我们有强烈的动力去相信世界是安全的、仁慈的和公平的。\n\n信任别人会使互动更简单、更愉快；它让我们不用担心别人会来找我们麻烦；或者不用担心如果我们暴露了真实的自我，会招致他们的非议。\n\n\n# 狩猎 — 采集者思维\n\n## 社交人数\n\n邓巴发现，我们的大脑容量似乎可以容纳大约 150 人，我们可以与他们建立起稳定、有意义的关系；当人类群体的数量不超过 150 人时，他们的功能会达到最佳状态。事实证明，很少有人能与超过 150 人进行双向通信。了解 150 人限制的一个有用的含义是，当人类组织不再变得更大时，其功能会更好 —— 他们可以像社区那样运作，而不会像行政机构那样运作。小型学校的暴力和旷课率较大型公立学校要低，人际关系会更好，学习质量会更高。 注意到我们进化中狩猎 — 采集者思维的性质和局限，可以优化我们的生活和制度。\n\n## 我们 — 他们”的部落心态\n\n进化将我们的思想塑造成部落心态，巧妙地将所有人归类为我们的一部分或他们的一部分。最后，我们要问：他是我们中的一员还是他们中的一员？\n\n泰菲尔的研究揭示，一旦把人们分成了不同的类别，我们的头脑就会自动地夸大我们和他们之间的差异，而不是注意那些相似之处。我们倾向于把我们群体中的人“群中人”视为一个独特个体的集合，而倾向于把那些“群外人”看作更为相似的人 ——“ 他们都是一样的”，人们经常说，或者“他们看起来都很像”。事实上，“他们”看起来的确很像。这是一个常见的感知缺陷：如果一组照片是亚洲人的或者黑人的脸，那么评价这组照片的白人要比他们是白人时要更难分辨。亚洲人在区分黑人和白人的面孔时也存在同样的困难。你可以想象这种偏见会如何影响对目击证人的准确辨认：白人目击证人更有可能错误地将一个黑人和另一个黑人混为一谈。\n\n我们对自己部落中成员的评判也比对“他们”的评判要宽容得多。我们不仅认为我们部落中的人更加多样化，而且我们认为我们部落更优秀、更值得。这种偏见带来了骄傲和尊重的感觉：我们扭曲了自己对世界的看法，这样我们的部落看起来比其他人更好，我们感觉会更好，因为我们是它的一部分。\n\n为什么我们倾向于基于如此细微的差别作出如此巨大的区分？原因在于我们的 DNA 。对于狩猎 — 采集者来说，他们需要对自己部落成员之间的差异保持警惕，这些成员可能是竞争者，而对于局外人，则可能是攻击者。当一个共同的目标对每个成员也都有利时自然会形成联盟，将个人组合成团队。我们自己的部落或团队之间的凝聚力是高度适应性的，因为我们共享资源，享受团队的保护以抵御来自外部持续不断的威胁。\n\n","n":0.171}}},{"i":66,"$":{"0":{"v":"Pursuade","n":1},"1":{"v":"\n说服一个人有多容易？答案在一定程度上取决于我们所要面对的是人们的看法还是态度。看法指的是一个人认为是真的.它们是短暂的；它们可以通过很好的证据来加以改变。\n\n包含情感和评价成分的观点被称为态度。与看法相比，态度是极难改变的 —— 正如我们在讨论称为偏见的复杂态度时所看到的。当你阅读本章中关于影响策略的讨论时，你可能会记住看法和态度之间的区别。对某个人而言容易改变的看法，对另一个人则可能是根深蒂固的态度。\n\n# 现代科技的影响\n\n人们容易因为手机分心。与先前的研究一样，手机具有破坏性；当它出现在房间里时，人们认为他们的同伴不太容易沟通且值得信赖，并且认为花更多的时间在一起也不太可能成为朋友。其他类似的研究发现，在社交互动过程中使用手机会减少眼神交流、参与度、对同伴的同理心关怀以及谈话的乐趣。\n\n除了剥夺我们发展社交技能的机会外，深入社交网站还可以促使人们变得更加自我中心和自恋，并相信名声、财富、人气比友谊、慷慨、社区更重要。\n\n通过我们在线时的积极参与，以及对我们所使用的操作终端可能上瘾保持警觉和超然，我们可以获得巨大的好处和乐趣，而不会挤出或分散我们对宝贵的离线体验的注意力。\n\n## 媒体\n\n获取信息是一件好事，媒体在让我们了解情况方面发挥着至关重要的作用。然而，这种媒体曝光也可能存在不利因素。无论是有意还是无意，这种栩栩如生的画面塑造了人们的态度和意见。\n\n**强烈的情绪**，例如新闻媒体唤起的情绪，常常会妨碍理性的决策。人们总是被教导要听从领袖们的命令 …… 你必须做的只是告诉人们，他们正面临着攻击，而去指责那些主张和解的人缺乏爱国心并可能会将国家置于危险之中。在任何一个国家这一招都会奏效。”\n\n媒体感染媒体也通过一种称为情绪感染的现象发挥其力量，这种现象发生在一个人的情绪行为引发观察者的类似情绪和行为之时。\n\n## 广告\n\n在面对许多消费品的情况下，假如没有铺天盖地的广告，公众会倾向于购买某个特定的品牌。当我们处理相同或非常相似的产品时，仅仅熟悉品牌名称就会带来巨大的差别对待。在所有其他条件相同的情况下，项目越被人们所熟悉，它就越有吸引力，即使该项目只是一个愚蠢的无意义单词。我们接触得越多，就会越喜欢它。\n\n和那些不容易想到的品牌相比，某种广告品牌的易得性足以向我们暗示其优越性。当然，一旦我们购买了产品并发现我们喜欢它，我们就培养了品牌忠诚度。因此，尽管我们很少意识到自己接受了广告的影响 —— 我们不会在看过广告之后立刻从椅子上跳起来，冲到超市去买艾德熊乐啤露 —— 但它可以启动一个长期的过程，在我们今后进行选择的时候，间接地促使我们购买大量的广告产品。\n\n# 说服\n\n如果我们具备所需的专业知识，我们倾向于深入思考一个与自己相关的问题。在这种情况下，我们会对论点进行认真的审查。但有时，即便这个问题很重要，我们也可能不会认真地面对某个观点，因为我们会分心或疲倦，我们缺乏对它进行批判性评估的知识，或者交流会以一种诱使我们接受的方式进行。\n\n说服的中心途径（ the central route to persuasion ）指的是对观点加以权衡，对相关的事实或数据加以考虑，在对问题进行系统思考的基础上作出决定。相比之下，说服的外围路径（ the peripheral route to persuasion ）则没有经过多少深思熟虑；人们并非依据对观点说服力的权衡和思考过程，而是不做过多思考地依据那些简单的、往往不太相关的线索对观点做出正确与错误或者是否有吸引力的反应。\n\n如果您的目标是为了说服，您需要知道问题对您的受众有多重要以及他们的知情程度。如果他们知识渊博且积极主动，那么您需要在有说服力的诉求中加入强有力的逻辑论证。如果他们不关心问题或无法完全理解它，您便需要使用附加到信息的高质量外围线索来说服他们。这可能短时内奏效，但如果你需要有说服力的信息，实验表明，让人们得到系统的论证说服比仅基于边缘线索的说服更容易达到目的。\n\n它们可以提高沟通或说服尝试的有效性：（ 1 ）沟通的来源（谁说的）；（ 2 ）沟通的性质（他或她如何说的）；（ 3 ）听众（他或她对谁说的）的特点和心态。换句话讲：谁对谁说什么？我们将分别对这些要素进行考察。\n\n## 沟通者的可信度\n\n传播者如何让自己看起来值得信赖呢？一种方法是反对自己的自身利益。如果人们在说服我们时没有得到任何好处（也许还会失去一些东西），我们便会信任他们，他们的说服会更有效。\n\n另一种提高可信性的方法是创造一种人们认为你没有试图说服他们的情境。\n\n首先，我们倾向于喜欢和信任自己认为有吸引力的人，所以除非我们认真评估有人为自己所认可的产品支付报酬的事实，否则我们很可能会被外围信息所说服。我们将沟通者的吸引力与信息的可取性联系起来。我们受我们喜欢的人的影响，也受我们感知相似性的人的影响。当我们喜欢沟通者时，我们的行为就好像我们试图通过改变自己的观点来取悦那个人\n\n在大多数情况下，人们信任自信的演讲者，而不是那些支支吾吾的人；人们将自信作为专业知识和真实性的指标。然而，如果我们怀疑受到了欺骗 —— 如果我们意识到有人试图说服我们相信某件事或诱导我们购买某件产品并从中获利的可能性（“这种神奇的补药一定能够提高你的成绩！”） —— 这种极端的自信则会引起我们的怀疑。\n\n## 沟通的性质\n\n- 逻辑诉求还是情感诉求, 情感诉求 —— 尤其是那些引起恐惧的诉求 —— 将比理性诉求更有效。\n  - 对自己评价很高的人最有可能在恐惧的时候立即采取行动。然而，对自己评价不高的人最不可能立即采取行动，但是（有趣的是）如果延迟一段时间，他们知道可以稍后采取行动，那么他们的行为就很像那些具有高度自尊心的被试。自尊心低的人可能难以应对威胁，这就解释了为什么唤起高恐惧的沟通会压垮他们\n  - 我们的大脑会因明显的和当前的危险（如老虎、蛇或携带武器的敌人）受到惊吓并被激怒 —— 而不是之后可能发生的渐进性危险（如干旱、流感或更频繁的飓风）。我们倾向于应对人类的威胁（如恐怖主义），这些威胁是蓄意而为的，因此会在我们心中引起一种道德上的愤慨。\n- **道德情感** 是一种具有规范性判断的情感 —— 你所做的是错误的、令人厌恶的或邪恶的。\n  - 在推特上，含有与道德情感相关词语的推文（如无耻的、恶心的或坏的）往往比非道德情感词语更容易被转发。\n  - 成为具有高度说服力的修辞手段 —— 它们往往会激发行动，团结志同道合的群体 —— 而且它们往往具有传染性\n  - 我们也可以通过道德提升来诱发人们更多的“天使举动”，即人们的亲社会动机，这是我们在他人身上看到美德时所感受到的情感。\n- 统计与个别案例\n  - 一般来说，人们会利用他人的经验和意见来决定什么是一种好的行为准则。这就是为什么，作为一般规则，我们会相信群体而不是个人，并且与标新立异的人相比，我们更倾向于追随人群。但是，当我们面对一个令人信服的故事或案例时，这种合理的逻辑往往会失效。\n  - 因为大多数人受到一个个具体案例的影响要比接受大量统计数据的影响更大\n- 认同诉求\n  - 如果这些事情与我们的自我认同产生共鸣，说服者便可能促使我们去行动。\n  - 唤起一个人的身份认同可以产生微妙但强大的效果\n  - 通过让人们从他们更高的身份角度去思考某个行为是好是坏，他们会把这一行为看作是“自己是谁”的核心，而不是一个偶然的行为。这就是身份的力量\n- 单向与双向观点\n  - 如果听众对这个话题越了解，那么他们被单向观点说服的可能性就越小，此时提出重要的对立观点然后继续反驳这些观点，则会提高说服的可能性。\n  - 一个见多识广的人更有可能知道一些对立的观点。当沟通者避免提及这类观点时，知识渊博的听众很可能会得出这样的结论：沟通者要么不公平，要么无法反驳他们。相反，一个事前不了解的人，对对立的观点知之甚少或一无所知，因此他们很可能被他们所听到的一方观点所说服；如果听到了相反的观点，他们则可能会对自己到底赞同哪一种观点感到困惑。\n  - 另一个因素是听众最初的观点。如果观众已经倾向于相信传播者的观点，那么单向的陈述对他们的观点产生的影响要大于双向陈述。然而，如果听众倾向于相反的观点，那么双面驳斥就会更有说服力\n- 沟通者和听众之间的差异程度假\n  - 当传播者具有很高的可信度时，如果传播者的观点与听众的观点存在很大的差异，那么他们更有可能说服听众。但是，当沟通者的可信度很低时，他们唯一能让听众接受的条件，就是他们的观点与听众的观点只有适度差异。\n\n## 接受者的特征\n\n- 人格与政治\n  - 与说服力最为相关的一个人格特征是自尊。自我评价低的人比自我评价高的人更容易被说服性的沟通所影响。\n  - 保守自由主义会在促进稳定、传统、秩序和等级制度方面维护我们的利益，而自由主义则会在促进求异、变革、灵活性和平等方面维护我们的利益。保守主义者更喜欢熟悉的人；自由主义者更喜欢与众不同的人。\n- 接受者的情绪与心态\n  - 另一个影响接受者对沟通信息反应的因素是他们的心态\n  - 他认为，如何让人们准备好接受说服性信息，是说服是否有效的一个关键因素：“通过策略性地引导接受者从一开始便加以关注，沟通者有可能在接受者接触信息之前便促使他们与信息达成一致。\n  - 假如听众吃饱喝足、放松、快乐、自我感觉良好，他们也更容易接受有说服力的交流。\n  - 听众的接受度和说服力也可能被降低。有一种方法就是简单地警告他们即将发生的事情。这样的预警似乎是在说：“当心，我将试图说服你。”人们往往会通过对消息进行防御来作出反应。\n\n## 说服的抗拒\n\n抗拒理论，当我们的自由感受到威胁时，我们会努力去恢复它。当人们认为某个人传递的信息过于明目张胆或者具有强制性，从而侵犯了他们的选择自由时，他们很可能会激活防御来抵抗它\n\n接种效应（ inoculation effect ）：如果让人们先接触某一简短的宣传，而且接着他们能够对其加以反驳，人们就会对后来大规模出现的同样观点产生“免疫”，这就如同在人体内注入少量经过稀释的病毒可以帮助人们对这种病毒的大规模进攻产生“免疫”\n\n相反，如果人们对某个问题没有太多的思考 —— 也就是说，如果他们通过外围路径形成了自己的态度，比如通过情感、熟悉度或同龄人 —— 他们特别容易受到对自己观点的全面攻击。他们在捍卫自己的观点时将缺乏现实依据。\n\n在我看来，这里值得强调的一点对于教育目的的实现至关重要：如果我们想减少单纯宣传的影响，就没有什么可以替代对各种思想的自由探索。最容易被洗脑的人，是那些信仰基于从未受到过严重挑战的口号的人","n":0.096}}},{"i":67,"$":{"0":{"v":"Follow_others","n":1},"1":{"v":"\n\n# 从众\n\n从众可以定义为一个人的行为或意见的改变，受到了来自另一个人或一群人的真实或想象的压力的结果。\n\n当人们互相交谈时，他们会经常模仿对方的非语言行为和举止，这种现象被称为变色龙效应（ chameleon effect ）\n\n镜像系统的主要功能之一是促进社会学习（ social learning ），即人们通过观察来学习的过程。\n\n只要其他人在笑，就可以起到这样的效果。很多从众行为都是这样产生的；环境中的社会暗示告诉我们其他人的感觉、想法或行为，而这些又会反过来影响我们的感觉、想法和行为\n\n## 动机\n\n从众的主要原因有两个：因为别人是有价值信息的来源，或者因为与别人相差太大令人感到不适；\n\n从众通过表达我们的相似性和思想上的亲近关系，来确保我们在某个群体中的地位。前一个原因基于丰富的信息：人们面对采取一致意见的多数人，会认为自己的观点因某种原因而出现了错误。后一个原因则基于规范：人们会“随大流”，但内心相信他们最初的判断是正确的，以求被大多数人所接受或避免因意见不同而被他们所厌恶。坚持正确意见与迎合群体之间的这种基本困境，是导致我们一些最大失败的核心所在。\n\n为了获得有关适当行为的信息而观察他人所产生的从众，往往比为了被接纳或避免处罚所产生的从众具有更强大的力量。我认为，如果我们发现自己处于一种模棱两可的境地，我们必须使用他人的行为作为自己行为的模板，我们很可能在随后的类似场合重复我们新学到的行为，而没有任何暗示\n\n## 榜样\n\n榜样的声望与受欢迎程度 当我们不清楚在某种情况下究竟发生了什么事情时，我们最有可能同那些行为可以提供最可靠信息的人保持一致。当受人尊敬、关系密切的人恰巧在正确的时间出现在正确的地点时，主要的社会趋势往往会通过从众机制突然发生戏剧性的变化。\n\n## 一致同意\n\n一致同意 当群体成员面对面时，像阿希研究的情况一样，决定一个人是否会从众的关键因素之一是其他人是否都持有相同的意见。“其他所有人”的群体中实际人数不需要太多，但需要获得最大程度的一致性；当达成一致的群体规模只有3人时，人们会像群体规模达到16人时一样顺从于群体压力。表态 通过诱导一个人对他（她）最初的判断作出某种承诺，也可以减少对群体压力的顺从。\n\n担责 假设你正在参与一个解决问题的小组讨论，而其他人正在向你施加压力，让你同意他们的决定。另外，假设你知道，在会议结束时，你必须向小组的其他成员证明你的决定是正确的。你觉得这对你的判断会产生什么影响？研究表明，在大多数情况下，这样的责任会增加你从众的倾向\n\n## 自尊\n\n一般来说，自尊心较低的人比自尊心较高的人更容易屈服于群体压力。如果让人们相信自己手头的任务根本不需要什么能力（比如判断直线的长度），他们的从众倾向就会增加。如果人们有机会在完成一项任务之前已经获得成功，从而对自己的能力充满自信，那么他们会比那些误打误撞的人更不容易从众。\n\n## 年龄 \n\n正如我们所看到的，即便是幼儿也会本能地顺应同龄人的行为。这是我们学习很多东西的途径，包括我们的说话方式和口音类型。39而对于10到25岁的年轻人来说，从众压力最为强烈。在此之前，大脑的自我控制系统——控制计划、思考未来、评估风险和抑制冲动——仍在发育。\n\n## 认同的群体\n\n我们所归属以及所认同的群体（即我们的参照群体，reference groups）既反映又塑造我们的身份和行为。通常，当我们改变参照群体时，我们也会改变我们的行为和态度以与之相符。总而言之，当人们偏离自己所属群体的规范、特别是当他们对所属群体重视或认同时，他们会从别人那里得到暗示，并且通常会体验到不适。\n\n## 不同的水平\n\n由此而区分出从众的三种水平：依从、认同和内化\n\n- 依从（compliance）这一术语能够最恰当地用来表示一个人为了获得奖励或者避免惩罚而做出某种行为\n- 认同（identification）一词描述了一个人渴望成为他们所钦佩的群体或角色榜样所带来的从众水平\n- 最后，基于价值或信念的内化（Internalization）是最持久的从众。将特定信念内化的动机，是希望自己正确。因此对这种信念的奖赏是内在的","n":0.204}}},{"i":68,"$":{"0":{"v":"Bias","n":1},"1":{"v":"\n这里的偏见是社会心理学的偏见和歧视。\n\n偏见定义为对一个可区分的群体中的所有成员的一种消极态度 —— 仅仅依据的是他们是该群体的成员。偏见是复杂的，就像任何态度一样，它部分是认知的，部分是情感的，部分是行为的。他（她）对他们有先入为主的看法，对他们有负面的情感，并且倾向于带着成见或敌意来对待他们\n\n# 刻板印象\n\n刻板印象（ stereotype ）反映了这样一种信念：一个特定的属性是群体整体的特征，而不管群体成员之间的实际差异如何。\n\n因为这个世界太复杂了，我们不能对任何事物和任何人都有高度分辨性的态度，所以我们对我们自己的群体以及我们所看到的其成员的所有变化进行优雅、准确的叙述，同时对其他群体形成简单、粗略的想法。刻板印象往往是准确的，因此可以是一种适应的、简短的处理复杂问题的办法\n\n一旦我们掌握了关于某个人的明确的和具体的信息，我们就会轻易地抛弃用那些刻板印象来引导对这个人的看法。\n\n## 刻板印象、性别歧视和性别\n\n每个人都持有对男性和女性的刻板印象 —— 有些是积极的，有些是消极的。女性被认为更有同情心、更为健谈，男性更具能力和攻击性。\n\n在 1950 年至 2012 年间，在以女性命名的飓风中死亡的人数是以男性命名的飓风中死亡人数的两倍。\n\n## 刻板印象与归因\n\n刻板印象是一种特殊的归因形式。我们是能够进行解释的物种；我们一直在通过归因来解释我们自己和他人的行为。在模棱两可的情况下，人们倾向于按照自己的偏见来构建叙事逻辑。\n\n不仅偏见会影响他的归因和结论，而且他的错误结论也会证明和加剧他的负面情绪。因此，整个归因过程得以螺旋式上升。\n\n### 归因模糊性\n\n解释别人的行为往往充满了不确定性。那个人喜欢我还是他们想从我这里得到什么？偏见使这个问题复杂化，因为我们的社会身份为一个特定个体的行为设定了更多的潜在原因。它给少数派群体成员解释自己得到的工作反馈带来了困难。\n\n那些被告知是因为性别（而非成绩）而被选中的女性后来贬低了自己的能力 —— 更糟糕的是，她们不再像那些相信自己是根据成绩被选中的女性一样，努力地在一项艰巨的任务上取得成功。\n\n### 自证预言\n\n我们对他人的刻板印象不仅影响我们对他们的行为，而且使我们的行为方式能够从其他人那里获得我们所期望的特征和行为。想象一下你和我从未见过面，但是我对你所属群体的偏见让我怀疑你会充满敌意或冷漠。当我们终于有机会见面时，我可能会保持距离，不愿尝试和你进行生动的交谈。\n\n### 刻板印象的威胁\n\n具有讽刺意义的是，自证预言的一个意想不到的结果是，那些消极刻板印象的目标人群最终会通过试图让偏见落空反而将这些偏见坐实。\n这就是刻板印象的力量；当人们认为自己的行为可能证实他们自身或他们所属团队的负面声誉时，由此产生的焦虑会影响他们的表现。\n\n\n### 指责受害者\n\n对于从未经历过偏见的人来说，完全理解成为偏见的目标并不是一件容易的事情。那些占多数的相对安全的成员，并不容易产生同情心。\n自相矛盾的是，把受害者的困境归因于受害者的个性和缺点，这种倾向往往是受到一种将世界视为公平公正愿望的驱使。人们倾向于将任何不公平的结果归因于个人责任，否则便很难解释。\n\n当一个人伤害另一个人时，攻击者倾向于责怪攻击目标，将受害者非人化并再次对其伤害。现在我们看到，如果一个人注意到另一个人是仇恨信息和其他偏见表达的接受者，他（她）不知何故觉得受害者一定做了他们值得受惩罚的事情。\n\n# 偏见的情感成分：直觉和仇恨\n\n偏见的第二个成分是情感，植根于抵制理性论据的直觉。这就是为什么试图说服人们摆脱偏见往往是徒劳的。事实上，偏见的情感根源往往导致刻板印象和相互矛盾的归因\n\n因此，刻板印象可以被认为有两个截然不同的目的：它们提供快捷的信息渠道，并在事实发生后对偏见情绪加以合理化。\n\n# 偏见的行为\n\n偏见往往会导致对受鄙视群体成员的歧视和不公平对待。\n\n性别歧视就像种族问题一样，许多人认为在美国性别歧视已不再是女性的障碍。毕竟，与大多数发达国家的情况一样，女孩在学校的大多数科目中的表现都比男孩好，而且更有可能上大学并顺利毕业。 50 尽管如此，她们仍然受到歧视，因为人们有偏见地认为她们比男性能力差。\n\n# 内隐偏见\n\n我们知道，许多真诚地认为自己没有偏见的人，在某些情况下，他们的行为会带有偏见.人们更容易暴露他们偏见的一个条件是精神疲劳，也就是当人们**疲倦、喝醉、分心、害怕、愤怒或做任何消耗或分散他们认知资源的事情的时候**。在这种情况下，人们倾向于借助他们的刻板印象 —— 即使他们有很强的动机去做正确的事情。\n\n\n证明我们持有偏见的另一个关键因素是，我们是否相信一个人可以控制他（她）的处境。反肥胖偏见是最后一种“可接受”的偏见，因为大多数人相信肥胖的人可以控制自己的体重. \n\n另一种可以接受的说法是“容易合理化”。我们越容易使我们的偏见合理化，我们就越有可能坚持并采取行动。\n\n# 减少偏见\n\n关键因素似乎是在实现共同目标方面的相互依存：这是一种个人需要彼此才能走向成功的局面。在一个群体内部建立起来的合作关系常常会在该群体后来被要求与另一个群体互动时继续存在。\n\n拼图教学：现在，已经不是只有一位专家（老师）了，每个学生都是他（她）自己的专家。他们没有相互嘲弄，而是开始互相鼓励，因为确保他们的同学能够以最佳方式传达他们的材料符合每个学生的最佳利益。\n拼图方法发生作用的原因为什么拼图方法会产生如此积极的效果？这项技术成功的一个原因在于，参与合作的过程打破了内群体与外群体的感知，并允许个体发展“一体”的认知范畴：我们是一体的。一个群体中的每个人，通过与其他成员分享他（她）的知识，会向他们提供帮助。\n\n\n","n":0.186}}},{"i":69,"$":{"0":{"v":"Reason","n":1},"1":{"v":"\n群体保护机制和由此产生的群体偏见是一种生物的生存机制，促使我们偏爱自己的亲属和部落，并对外人保持警惕。\n\n# 经济与政治竞争\n\n\n偏见往往是经济和政治力量造成的。根据这一观点，由于资源有限，占支配地位的群体可能试图剥削少数群体以获取某种物质利益。当群体为相互排斥的目标发生冲突时，会导致偏见的增加。\n\n竞争和冲突会滋生偏见。\n\n# 替代性攻击：替罪羊理论\n\n攻击行为部分是由挫折和其他诸如痛苦或无聊的厌恶状态引起的.受挫的人有一种强烈的倾向，他们会猛烈抨击导致自己受挫的原因。然而，通常情况下，一个人遭受挫折的原因要么太强大，要么太模糊，不可能直接报复。在现代，“寻找替罪羊”一词指的是把我们的麻烦归咎于无辜和无能为力的人的过程\n\n个人，特别是当他们感受到挫折时，会把攻击性转移到那些不受欢迎的、可以接触到的、相对无力的群体身上.\n\n1949 年，两位社会心理学家分析了历史上许多煽动者所发表的大量演讲。 他们发现这些人的演讲中有着惊人的规律性：\n ● 你被骗了。你在社会中的地位是不安全的，这并非因为你个人的过错。\n ● 存在着一个广泛的阴谋，这个系统是针对我们的。\n ● 像我们这样的好人总是被愚弄。\n ● 我们的敌人是低等动物：爬行动物、昆虫、非人。\n ● 我们不能相信外国人，他们抢走了我们所有的工作。\n ● 我们也不能相信我们自己的政府，它是腐败的。公民自由其实是“愚蠢的自由”。\n ● 我们正在走向灾难，厄运即将来临。像你这样真诚、单纯、善良的人需要一位领导者。看呐，那就是我！我要改变这一切！\n ● 所有人都反对我 —— 媒体、犹太人、臭名昭著的官僚们都试图让我闭嘴。敌人密谋夺走我的生命，但上帝会保佑我。让我来引导你。\n\n\n# 自我形象和地位的维持\n\n偏见的一个强有力的决定因素是我们需要为我们的行为和自我意识辩护。如果我们对一个人或一群人做了一些残忍的事情，我们中的大多数人都会试图责怪或诽谤那个人以证明我们的残忍是正当的。如果我们能说服自己，一个群体是无用的、不人道的、愚蠢的或不道德的，我们就可以任意地去奴役该群体的成员，剥夺他们接受体面教育的权利，或对他们进行攻击，而不去质疑我们自己的道德感。对他人持有偏见会增强我们的自尊心。\n\n# 从众导致的偏见\n\n许多有偏见的行为都是由人们对社会规范的从众所驱动的。我们如何来确定从众所发挥的作用呢？一种方法是观察当人们移居到这个国家的不同地区时，他们的偏见会发生什么变化。\n\n最后，偏见也可能源自基于社会制度的法律和习俗。一个倡导种族隔离的社会，会支持某个群体劣于另外一个群体的观点。","n":0.2}}},{"i":70,"$":{"0":{"v":"Attack","n":1},"1":{"v":"\n# 人类的攻击性\n\n我将攻击定义为旨在造成伤害或造成身体或心理痛苦的故意行为。攻击行为可能是身体上的，也可能是口头上的。\n\n人类社会并非都富有攻击性。 在依赖合作促进群体生存的紧密文化中，愤怒和攻击被认为是危险的和破坏性的，罪犯将被排斥或受到惩罚.攻击是一种可供选择的策略\n\n## 荣誉文化\n\n在这种文化中，即使是很小的争议也会使一个人不可摧毁的荣誉受到影响，这就要求他作出积极的回应，以恢复他的名声\n我们可以看到，虽然攻击的生理成分存在于人类和其他灵长类动物中，但攻击并不是一种反射性的“本能”。文化影响已经“浸入我们的皮肤之下”，塑造我们对情境的反应和社交活动，从而决定我们是否采用攻击性反应。\n\n## 性别\n\n当“作为一个男人”由竞争力和力量来定义时，男人总是试图通过表现出攻击性来“证明”他们的男性气质和地位。 相反，当男性生活在对他们的生存缺乏内部和外部威胁的文化中时 —— 不可否认的是，没有多少文化会如此幸运 —— 他们便不会被培养成好斗的人，在那里性别差异被最小化，并且鼓励合作。\n\n暴力的首要预测因素是性别。作为成年人，男性比女性更容易发生自发的、无端的攻击陌生人的行为，刺激男性攻击的激素是睾酮，尽管男女都有睾酮，但男性体内睾酮的比例较高。\n\n发生在家庭中的大多数极端暴力事件都是由男性实施的。例如，每 10 个杀死家庭成员的杀人犯中有 8 个是男性。当男性殴打受害者时，他们通常会比女性施虐者造成更严重的伤害。 然而，当涉及比谋杀和残忍殴打稍逊的身体攻击形式时，男性和女性之间往往存在很大的重叠 —— 这与性别刻板印象相反。在很多两性关系中，双方都具有同样的攻击性。\n\n对于那些与伴侣有身体攻击的男性和女性而言， 29 他们的行为也是出于同样的原因：嫉妒、愤怒、报复和自卫。\n\n## 关系性攻击\n\n作者把攻击定义为伤害他人的意图, 女性比男性更容易参与更具社会性的攻击行为. 关系性攻击，即通过破坏他人的名誉和关系来伤害他人。回避、散布虚假谣言和恶意流言蜚语、诽谤以及“荡妇羞辱”都是最好的例子，其后果可能是毁灭性的\n\n关系性攻击的一种特别有害的形式是网络欺凌。\n\n# 攻击的作用\n\n某些类型的攻击行为可以起到有用的、也许是必要的作用：它们“释放了能量”。这种看法源于精神分析的宣泄或能量释放的概念\n\n人们越是用攻击性的行为发泄愤怒，他们便会越加愤怒，也就会变得越有攻击性。直接或间接、口头或身体上发泄愤怒并不能减少敌意，反而会增加敌意。\n\n报复、行为过度与升级为什么表达愤怒会导致更大的敌意？一旦我们对他人表达了负面的感觉，一旦我们给前老板贴上了一个“没有良心的混蛋”的标签，那么用前后一致的声明和行动来跟进就会变得更加容易 —— 尤其是当我们在公开场合报复的时候。此外，报复通常比最初的侮辱或攻击更为严重；我们倾向于行为过度，这为减少失调奠定了基础。\n\n行为过度会导致失调最大化。犯事者对你的所作所为和你的报复之间的差异越大，心理失调就会越大。\n\n## 攻击的原因\n\n### 酗酒\n\n世界上许多人会高兴地摄入酒精这种药物。酒精会降低我们的抑制力，使喝酒的人更友好、更合群，但也会放松对实施攻击行为的限制，包括性侵犯。酒精减少了社会抑制，使我们不那么谨慎，更容易冲动。但它不仅仅如此：酒精也会破坏我们通常处理信息的方式。醉酒的人通常会专注于社会状况最早和最明显的方面，并对其做出反应，而往往会忽略其中的细微之处。\n\n### 痛苦、不适与饥饿\n\n因此，其他形式的身体不适，如酷热、潮湿、空气污染和难闻的气味，会增加愤怒，从而降低攻击性行为的门槛。 61 一种强有力的不适形式是伴随着低血糖的饥饿。\n\n已经证实，一天中温度越高，人们实施暴力犯罪的可能性就越大。气温升高会大大增加从家庭暴力、谋杀、强奸到暴乱和内战许多类型冲突的风险\n\n### 拒绝、排斥与嘲弄\n\n遭到拒绝会产生过多的负面影响，尤其是攻击性的急剧增强。被拒绝者”在随后有机会攻击他人时，对拒绝者和中立者表现出比未被排斥者强烈得多的敌意\n\n### 挫折、剥夺与攻击\n\n如果一个人在实现目标的进程上遭遇到挫折，那么由此而产生的挫折会增加攻击反应的可能性。总而言之，当目标近在眼前，或者当期望很高，或者当公平规则被违反，或者当目标没有令人信服的理由而受阻时，挫折最为明显。挫折往往不是简单剥夺的结果；而是**相对剥夺**（ relative deprivation ）的结果，当我们看到别人享有更好的条件，或者当我们失去了与我们期望相关的东西时，我们会感到被剥夺。\n\n相对剥夺解释了大多数社会革命中由来已久的一个谜团：它们通常不是从那些生活在最底层的人开始的。最常见的是那些最近摆脱了生活困境，环顾四周，发现有人生活得比他们更好而且感觉自己系统地受到不公平对待的人。\n\n## 攻击的模仿，学习\n\n现在我们来看看社会认知学习理论的一些发现。社会认知学习理论认为，人们通过诸如他们的信仰和对事件的感知等认知过程，以及通过观察和模仿他人，学习如何去行动 —— 包括攻击行为或有益行为。\n\n### 武器效应\n\n实验发现，如果漫不经心把步枪（而不是网球拍）放在乘客座位上，人们开车时会更具攻击性。\n\n### 匿名\n\n社会学习的某个方面往往会抑制攻击性，那就是大多数人必须对自己行为负责的倾向。但是，如果这种责任感被削弱了，会发生什么事情呢？菲利普 · 津巴多 89 已经证明，匿名的人由于无法加以识别，往往比不匿名的人更具攻击性。匿名会导致去个性化（ deindividuation ），这是一种自我意识减弱的状态，减少了人们对他人如何看待自己的担忧，并削弱了对被禁止的行为方式的限制。\n\n### 大众媒体\n\n随着时间的推移，不断推出的有关暴力的图片和描述会让我们麻木。当我们看到人们受到越来越多的伤害时，我们所感受到的痛苦却会相对减少，这就是所谓的脱敏过程。人们可以通过收看晚间新闻的战争场景、每天玩几个小时的偷车游戏，或者通过目睹发生在父母之间的现实暴力，来让自己变得麻木。\n\n随着时间的推移，那些玩过许多不同暴力游戏的人，更容易发展出被称为敌意归因偏见（ hostile attribution bias ）的倾向，以敌对的方式解释他人模棱两可的行为的倾向 —— 而不是给予他人善意的怀疑\n\n频繁地接触暴力媒体，尤其是暴力视频游戏，确实会对许多儿童和青少年产生影响，当然这种影响对那些已经形成暴力行为倾向的儿童和青少年影响最大。观看暴力似乎对那些易受伤害的观众影响更大，原因有以下五个：\n\n（ 1 ）它会增强生理性唤起（“我想我真的很生气，而不是紧张”）；\n（ 2 ）它会诱导人们模仿敌对或暴力人物的倾向，削弱以往习得的禁忌（“如果他们能做到，我也能做到”）；\n（ 3 ）它会引发潜在的愤怒、恐惧或挫败感（“我最好在他抓住我之前抓住他！”）；\n（ 4 ）它能促进人的心理麻木，减少移情（“呵呵，再来一次，还有什么？”）\n（ 5 ）当我们感到沮丧、愤怒或受伤时，它通常会示范我们认可的行为方式（“哦，你就是这样做的！”）。\n\n## 攻击的要素\n\n\n### 性脚本和同意难题\n\n理解最令人不安和最持久的攻击类型之一：强奸和其他形式的性侵\n\n\n一个答案可能在于：作为性别角色的一部分，生活在美国社会中的男性和女性学习了不同的性脚本。 113 性脚本因文化、性取向、种族、年龄以及地域的差异而有所不同，而且会随着时间的推移而发生变化。\n\n在美国，对于年轻、异性恋的女性和男性来说，一个主要的脚本是女性的角色是拒绝男性的性行为，而男性的角色是坚持不懈去追求。这个脚本或许可以解释为什么许多人对“不”这个词的含义争论得如此之多。\n\n# 如何减少暴力\n\n## 惩罚\n\n对于普通公民来说，减少攻击的一个明显方法就是惩罚。如果人们要建立长期的非攻击性行为模式，作为孩子，他们必须内化一套反对攻击性反应的价值观。总的来说，这项研究表明，如果对攻击性行为的惩罚既及时又适度，那么尚未形成价值观的儿童更容易对攻击性产生厌恶。\n\n这些研究似乎意味着：（ 1 ）看到攻击者得到奖励会增加儿童的攻击行为；（ 2 ）看到攻击者受到惩罚不会增加或减少儿童的攻击行为。完全不让孩子接触攻击性榜样也会起到同样的效果。\n\n提供非攻击性榜样遏制攻击的一种重要手段就是清楚地表明这样做是不适当的。最有效的标准是社会 —— 也就是说，在同样的情况下，其他人选择和解而不是报复。\n\n培养同情心：同情心对人类生活至关重要，它是非人性化的解药。已经证明在儿童的同情心和攻击性之间存在着负相关：同情心的强度越高，表现出攻击性行为的可能性就越小\n\n培养利他主义和专注力\n\n利他主义 —— 为他人做一些事情，即使是以我们自己直接的舒适或快乐为代价 —— 是对付攻击的一剂强力解药。利他主义会给人们带来很好的感受。\n\n冥想也可以帮助","n":0.113}}},{"i":71,"$":{"0":{"v":"Skill","n":1}}},{"i":72,"$":{"0":{"v":"Decision","n":1},"1":{"v":"\n\n# 10-10-10\n\n- How will we feel about it 10 minutes from now?\n- How about 10 months from now?\n- How about 10 years from now?","n":0.204}}},{"i":73,"$":{"0":{"v":"Rules","n":1},"1":{"v":"\n\n知道做什么会出错，不要去做！\n\n\n# 底层规律\n\n- 人类\n  - 生存\n  - 社交\n\n人类的神经是受外界的影响而改变的，每个人的经历形成了每个人独特的世界观\n\n## 心理学\n\n认知吝啬者：我们总是寻求保存认知（心理）能量并**将复杂事物简单化处理**的方法。我们会**利用经验法则**去走捷径。我们会忽略一些信息以减少认知负担；我们会过度利用一些信息以避免去寻找更多的信息；或者我们只是按照最初的直觉，接受一个不够完美的选择，因为它已经足够好了。\n\n### 倾向\n\n\n- 可得性\n  - 峰终原理\n  - 锚定效应\n  - 简单联想\n- 损失厌恶，害怕小概率事件\n  - 奖惩机制\n- 寻求解释\n  - 避免怀疑，消除不确定性\n- 快速分类\n- 性别的关注点不同\n  - 男性和其他男性竞争\n  - 女性挑选男性，关注自己的孩子\n- 自己\n  - 注重自己的利益\n  - 高估自己\n  - 自我欺骗\n- 社会\n  - 寻求社交认同\n  - 权威\n  - 注重声誉\n  - 互惠原理\n  - 一致性原理\n","n":0.147}}},{"i":74,"$":{"0":{"v":"Vivid","n":1},"1":{"v":"\n# 生动形象\n\n- 当一件事情越生动，越个人，越有趣，越有情感。我们越容易受他的影响\n- 我们也会高估于事件发生的可能性。当这件事非常形象生动的时候。\n- 我们对于自己亲身经历的事情，会给予过多的权重，认为他们会再次发生。\n- 对于一些证据表明的长期变化，而会低估作用\n- 我们更倾向于相信具体的事情，而忽略一些抽象的概念。我们更关注现在的信息，而不是可能没有提到的信息。\n","n":0.378}}},{"i":75,"$":{"0":{"v":"Social","n":1},"1":{"v":"\n# 社会接纳\n\n - 人会倾向于被喜欢，被社会认同\n - 喜欢表扬我们的人。\n - 会有强烈的倾向来避免被羞辱，失去自己的名誉\n\n\n# 权威\n - 我们倾向于服从权威，特别是当我们不确定被管理，或者当周围的人都做同样的事情的时候。\n - 专家也会犯错，重要的是弄清楚是哪一个专家可信。","n":0.277}}},{"i":76,"$":{"0":{"v":"Self","n":1},"1":{"v":"\n# 自己的利益带来的偏见\n\n因为做的事情会为自己带来收益，所以自己就会产生一定的偏见，做出的预测就不可信。\n\n对于他人的决策思考：什么是利益，谁收益。\n\n# 乐观\n\n认为自己是独一无二的，对于自己的未来十分乐观。当我们失败，我们会责怪外界环境和坏运气\n\n# 自我欺骗\n\n我们会骗自己，将现实歪曲成一个更舒服的世界，特别是危害到自己的利益\n","n":0.5}}},{"i":77,"$":{"0":{"v":"Rewards","n":1},"1":{"v":"\n# 奖励\n\n人只会去做有用的事情，设定奖励的目标会使人的行为向其优化。有奖励就会强化行为。\n\n不要过度的从别人那里学习，因为不一定同样的行为带来同样的回报。\n\n建立系统和规则来鼓励你希望的行为。\n","n":0.707}}},{"i":78,"$":{"0":{"v":"Impatience","n":1},"1":{"v":"\n\n\n# 缺乏耐心\n\n⁃ 对于比较近的事情会赋予更高的权重\n⁃ 我们倾向于立刻的奖赏。\n- 追求短期回报\n\n","n":0.447}}},{"i":79,"$":{"0":{"v":"Consistence","n":1},"1":{"v":"\n\n# 一致性\n\n\n当我们做出承诺之后，我们就会保持一致。我们的行为也会很难改变。我们更容易去寻找支持自己观点的证据。我们很容易去解释新的信息来支持和符合自己的观点。我们并不想放弃自己的努力。\n\n当我们做出一个公开，自愿的承诺。我们就很难去改变它，很容易坚持下去。\n\n当我们先同意一个小的请求之后。别人就可以一步一步地增大要求，因为我们一开始作出的承诺，所以后面我们会保持一致。\n\n强烈的意识形态也利用这一点来增强人们的一致性，让人失去理智，跟着领袖行动。\n\n避免这一点最好的方法就是当你发现自己在动一个洞里的时候，你就要停止挖洞。决定应该是由我决定去哪儿做出的，而不是因为我做过什么\n\n我们更喜欢默认的选项，我们倾向于让事情不改变。\n","n":0.707}}},{"i":80,"$":{"0":{"v":"Bias","n":1},"1":{"v":"\n# 偏见盲点\n\n认为我们自己比大多数人更客观、更少偏差。\n\n# 证实偏见\n\n在所有的认知偏见中，证实偏见是最主要的。它关系到我们如何看待世界和处理信息。我们注意、记住、接受各类信息，这些信息证实了我们已经相信的事情，并且倾向于忽视、遗忘、拒绝那些与我们的观点相悖的信息。\n\n证实偏见有助于解释为什么人们顽固地坚守那些牢不可破的信仰。他们会寻找一切可能的证据来支持他们所期待的是正确的，所以他们不必“改变主意”。\n\n# 自我中心偏见\n\n自我中心偏见人类是一种社会性种群，但我们也是以自我为中心的：我们倾向于把自己置于宇宙的中心。这就是为什么当人们能够将新信息应用到自己身上时，会比认为它只会影响到别人时更能记住新信息的原因。\n\n巴纳姆效应指的是，当人们被赋予可以适用于几乎所有人的模糊、万能的自我描述时，他们通常会说“难以置信！那就是我！”。\n\n# 消极偏见\n\n为什么坏事比好事具有更大的威力人类进化的一个奇怪的特点是它倾向于消极：我们倾向于关注潜在的威胁而不是祝福，这种倾向通常被称为消极偏见。消极反馈比积极反馈对情绪的影响更大。坏消息比好消息更容易、更经常地被分享。\n\n# 预测未来和回忆过去的偏见\n\n无论是积极的还是消极的，我们都会高估未来发生事件可能带来的情感影响，以及我们所做反应持续的时间。\n\n- 我们的记忆是有选择的，我们倾向于记住一些带有强烈感情色彩的事情。\n- 童年的回忆是不可靠的。\n\n# 重构记忆\n\n记忆是一个重构的过程。对我们记忆最为强烈的影响不是过去实际发生的事件，而是我们现在对那些事件的思考。我们构建的记忆更为符合我们自己的想象。正是因为证实偏见的存在，我们更有可能回想起那些证实我们看法的记忆。\n\n\n# 容易相信\n\n- 我们不是天生的质疑者，我们更容易相信，更难去怀疑。\n- 当我们想去理解一些信息的时候，我们必须先相信他。\n\n# 做事情的倾向\n - 人是坐不住的，如果感觉无聊失去耐心，总是想做一些事情，我们希望获得刺激和兴奋。\n - 但是一旦方向不对的时候，做什么都是错的\n - 当没什么话可说的时候，我们也会想讲话。\n\n# 情景的影响\n\n - 对于坏运气的发生的失败会给更多的指责，而对于有幸运的人给予态度的奖赏。\n - 极端的情况会使人做出在正常情况下永远不会做的事情。把人置于极端情况就会改变他们正常的行为。\n - 匿名的环境下，人们就会做出破坏的行为。","n":0.196}}},{"i":81,"$":{"0":{"v":"Bad","n":1},"1":{"v":"\n# 损失厌恶\n\n⁃ 我们对于自己拥有的东西会给他赋予更高的价值。\n⁃ 我们对于负面信息会更加敏感。\n⁃ 禁止某项东西，反而会让他变得更有吸引力。\n⁃ 我们会给更加稀缺的东西，赋予更多的价值。","n":0.408}}},{"i":82,"$":{"0":{"v":"Availability","n":1},"1":{"v":"# 可得性\n## 峰终原理\n## 锚定效应\n## 简单联想\n\n人们很容易将单一事件和其他的事件联系起来，产生不好或好的感受，这往往是不可靠的。\n\n要乐于接受坏消息，这样才能更好的客观认识事物","n":0.447}}},{"i":83,"$":{"0":{"v":"Photo","n":1},"1":{"v":"\n- scn\n  - 人像：远摄端使被摄体上半身充满画面\n  - 摇摄：想要拍摄在被摄体的背景带有速度和虚化移动效果的照片\n  - 手持夜景 \n  - 夜景人像：建议在拍摄后当场回放拍摄的图像以检查图像亮度。如果被摄体 显得较暗，靠近被摄体并重新拍摄。\n  - 逆光场景：在 此模式下拍摄一张照片时，会以不同的曝光连续拍摄三次。这会生成一张具 有宽广色调范围的图像，可最大程度地减少因逆光导致的限幅阴影。\n- P档\n  - 相机自动设置快门速度和光圈值以适应被摄体的亮度\n  - 您可以随意设定自动对焦方式、测光模式和其他功能\n- Tv 快门优先自动曝光\n  - 较快的快门速度会冻结移动被摄体的 动作。较低的快门速度可以产生模糊的效果，给人以动感。\n  - 如果最低的f/值闪烁，表示曝光不足。转动拨盘设 置较低的快门速度直到光圈值停止闪烁，或者设置较高 的ISO感光度。\n  - 如果最高的f/值闪烁，表示曝光过度。转动< 6 >拨盘设 置较高的快门速度直到光圈值停止闪烁，或者设置较低 的ISO感光度。\n- 光圈优先自动曝光 Av\n  - 较大的f/值(较小的光圈孔径) 会将更多的前景和背景纳入可接受的对焦范围。相反，较小的f/值(较大的光 圈孔径)会将更少的前景和背景纳入可接受的对焦范围。\n  - 如果快门速度“30\"”闪烁，表示曝光不足。 转动拨盘设定较大的光圈(较低f/值)直到快门速度 停止闪烁或设定更高的ISO感光度。\n  - 如果快门速度“1/4000”闪烁，表示曝光过度。 转动拨盘设定较小的光圈(较高f/值)直到快门速度 停止闪烁或设定更低的ISO感光度。\n  - f/值越高，光圈开口将越小。根据镜头的不同，所显示的f/值会有所不同。如果 相机没有安装镜头，则光圈值将显示为“F00”。\n  - 光圈值越大，从前景到背景合焦的区域就越广。\n\n![](https://tczimg.s3.amazonaws.com/vscode/450011983b674263b838a2ce1fa3fad2.png)\n\n- M 手动曝光\n  - 要设定快门速度，转动< 6 >拨盘。要设 定光圈值时，转动< 5 >转盘。\n![](https://tczimg.s3.amazonaws.com/vscode/7cf031b511694b9b909a9bb937144b36.png)\n\n- 灵活优先自动曝光 Fv\n  - 闪烁的值表示设定的值将导致曝光不足或曝光过度。调整曝光直到数值停止闪烁。\n\n![](https://tczimg.s3.amazonaws.com/vscode/4b4e3cf6eece4c09b105d82f9492111b.png)\n\n- 长时间(B门)曝光\n  - 在此模式下，持续地完全按下快门按钮期间快门保持打开，松开快门按钮时 快门关闭。此摄影技术称为“B门曝光”。B门曝光用于拍摄夜景、焰火、天空以及其他需要长时间曝光的被摄体。\n  - 设定所需的光圈值。\n  - 长时间B门曝光比通常在图像中产生更多噪点。\n  - ![](https://tczimg.s3.amazonaws.com/vscode/1d0bb4a4bef9490cacdfae58229b1be0.png)\n-\t测光 18%灰度\n![](https://tczimg.s3.amazonaws.com/vscode/b9ba7a172d734b2bb4d38e5563466ed7.png)\n- 自拍\n  - ![](https://tczimg.s3.amazonaws.com/vscode/e1a296f376ce48218cc4877d3cd15860.png)","n":0.11}}},{"i":84,"$":{"0":{"v":"Video_change","n":1},"1":{"v":"\n运动摄像要注意以下几个重要问题：\n\n1）要有明确的目的，不能无目的乱用。\n\n2）摄像机的运动速度或变焦速度要与画面内容相协调，同时，也要考虑后期制作的需要。\n\n3）起幅落幅一定要留有一定的长度，一般不少于5秒。这是因为既要符合人的视觉习惯，同时也要为后期制作提供方便。\n\n4）运动镜头不能太多，过多使用会使人感到疲劳、心烦。在任何影片中，运动镜头所占比例总是很少的，大量的是固定镜头或动静结合的画面。\n\n# 推摄\n\n推摄是摄像机向被摄主体方向推进，或变动镜头焦距使画面框架由远而近向被摄体不断推进的拍摄方法。推镜头有以下画面特征。\n\n随着镜头的不断推进，由较大景别不断向较小景别变化，这种变化是一个连续的递进过程，最后固定在主体目标上。因此在拍摄推镜头时，必须选择好起幅和落幅（最好先试推一次）。这种明确的拍摄目标和景别的确定是为拍摄目的服务的，是为了通过推镜头来突出主体物或某个细节，给观众以某种启迪\n\n推镜头有交代环境、表现环境与主体目标关系的作用。因此，推镜头一般由远景或全景起幅，逐渐向主体目标推进。因为推进是连续的，所以增强了真实感和可信性。\n\n# 拉摄\n\n拉镜头正好与推镜头相反，是摄像机逐渐远离拍摄主体，或通过变动焦距使画面框架由近而远与被摄主体逐渐拉开距离的拍摄方法。拉镜头的拍摄方法、运用与画面特征如下：\n\n1）拉镜头是由较小景别起幅向较大景别连续渐变的过程，随着这个过程，被摄主体由大变小，周围环境逐渐展开。拉镜头的这种画面特征可真实地向观众交代主体物所处的环境及与环境的关系，有时能给人以悬念或新意。与推镜头不同的是，在镜头拉开前，画面环境对观众来说还是个未知数，镜头拉开，往往会给观众以“原来如此”的感觉。拉镜头常用于侦探、喜剧片中。\n\n2）拉镜头也常用于转场或故事的结尾。随着镜头的拉开，画面内容越来越丰富，这时把画面中的某一部分切换成中景或全景，给人以连贯、流畅、顺理成章的感受，不会让人感到跳跃和“突然。拉镜头还常常用于故事的结尾，随着主体目标渐渐远去、缩小，其周围空间不断扩大，画面逐渐扩展为广阔的原野、浩瀚的大海或莽莽的森林，给人以“退出”“结束”的感受，并给人以启迪和遐想，能引起观众的种种情绪，赋予结尾抒情的色彩。拍摄拉镜头的注意问题与推镜头大致相同。”\n\n# 摇摄\n\n摇摄是指摄像机机位不动，借助三脚架或人体做水平旋转或做上下移动的拍摄方法，是运动镜头中运用最多、最广泛的一种拍摄手段。\n\n1）对于一些宏大的场面或较大的物体，由于画面框架的限制，用一幅画面很难表现完美，摇摄可突破画面框架的局限，用较小的景别把较大的场面或物体一一表现清楚，使观众对被摄物既有一个整体印象，又可以把被摄物的每个细节尽收眼底。\n\n2）当用摇镜头表现多个主体时，可让每个主体充满画框，当画框上出现某个主体时可稍作停顿，形成间歇摇，以加深观众对每个主体的印象。摇摄常用于向观众交代会议上的主要人物。\n\n# 移摄\n\n通俗地说，移摄就是“边走边拍”。移摄可以肩扛拍摄，也可把摄像机架在车、船等运动中的物体上拍摄。专业摄像中，要铺设移动轨道，利用移动车和三脚架来拍摄。移动摄像是一种很符合人的视觉习惯的拍摄方法，可以突破画框的限制，让所有的被摄主体都能平等地在画面中得到展示，克服摇摄中由于透视关系造成光轴较远的景物畸变的问题。移动摄像摆脱了固定位置摄像的局限，使摄像师有更大的活动余地，能更好地发挥艺术创作思路，使静的东西“动”起来，使观众有参与感。在移动拍摄中，适当安排一些前景元素横向滑过画面，以便强调镜头的动感，有时也可利用背景的变化营造类似效果。移动拍摄中为了表现运动的速度和动感，移动方向要和主体运动方向相反。\n\n# 跟摄\n\n跟摄时，摄像机可以是移动的，与被摄主体做同方向等速运动拍摄；也可以是固定的，用摇镜头的方法跟定一个目标拍摄。与移摄不同的是，移摄的被摄目标是多个，而跟摄是跟定一个固定的目标。无论是哪种方法，跟摄能产生画面中被摄主体相对不变而背景不断变化的一种独特的艺术效果。跟摄常用于体育比赛等被摄主体快速运动的节目。","n":0.408}}},{"i":85,"$":{"0":{"v":"Video","n":1},"1":{"v":"\n## iphone\n\n1.  虽然人眼在 24 FPS 的时候就会认为是动态影片，但是并不说明更高的帧率人眼无法分辨。一般来说越高的帧率就意味着画面会更加的细腻流畅。所以这也是为什么李安最近开始使用 120FPS 来进行电影拍摄的原因，你会有更加身临其境的感觉。\n2.  更高的帧率可以通过后期慢放为低帧率。我们管这种方式叫做「升格」，也就是我们俗称的慢镜头，比如说你拍摄了一个 1 秒钟的画面是 240 FPS，那么我们可以后期每秒钟播放 24 帧，这样就意味着我们把 1 秒钟发生的事拉伸到了 10 秒，这就是慢动作的基本原理。\n\n## 慢动作\n\n拍摄拍摄慢动作的精髓在于一定要是本身画面中有高速运动的物体才会比较震撼。更加重要的是，拍摄的时候时间不要过长。因为 10 倍慢动作的话，一秒钟就是播放 10 秒钟，如果你拍摄 10 秒就是 100 秒。\n\n高帧率拍摄的普遍特点是对于光线环境要求比较高，所以如果你是在弱光下拍摄，那么就会发现画质下降得非常迅速。所以如果你要是想要拍摄高帧率，最好是在光线环境较好的情况下拍摄。如果是小物体，最好是可以补充一定的光线进行拍摄。\n\n## 延时摄影\n\n所谓的延时视频就可以理解为「抽掉正常拍摄之间的一些帧，在组合到一起进行播放就会实现一种快进的效果」。\n\n「它可以让本来几小时甚至是几天发生的画面，仅仅在几秒钟就可以展现。」\n\n延时摄影保证画面的稳定非常重要。因为画面一旦产生非常轻微的晃动都会导致素材不可用。因此一般来说，如果是定机位的延时摄影都需要一个三脚架配合。\n\n### 远景类\n\n远景基本上都是用在一些空镜中，用来交代场景。比如如果你的主题是「秋日之旅」，那你就可以拍摄一些秋叶纷纷落下的大场景。你可以放在影片的开始做铺垫，也可以放在影片的中间做转折。\n\n### 中景类\n\n这一类镜头最为常见，尤其是中特写几乎是所有的 VLog 都会使用的镜头（大部分的手持自拍就属于这个类别）。这类镜头的好处就是可以交代主角的动作，完成叙事任务。\n\n### 特写类\n\n基本上特写都是用来交代人物的表情，可以展现人物的心理状态。你的开心快乐都可以使用特写来表达。\n\n## 过程\n \n对于刚刚入门拍摄的用户来说，我们只需要知道 6 个字即可：推、拉、摇、移、俯、仰。\n\n*   推：直接靠近画面主体，让场景逐渐聚焦在某一个部分。\n*   拉：逐渐远离主题，逐渐展现主体所在的环境。\n*   摇、移：画面从一个方向移动到另一个方向。\n*   俯镜头：从上向下拍摄，一般用来体现主体的卑微。\n*   仰镜头：从下向上拍摄，一般用来体现主体的高地位。\n\n*   正确的握持姿势，双手握持手机拍摄。\n*   拍摄 4K 60FPS 后期回放为 4K 30FPS。因为慢镜头可以缓解镜头的抖动状况，所以一般来说我喜欢拍摄 4K 60 FPS 的原因就是可以慢放让画面更加顺滑，不过前提是对应的画面是没有对白。","n":0.136}}},{"i":86,"$":{"0":{"v":"Travel","n":1},"1":{"v":"\n拍摄一张高精度照片的忠告\n\n1．在一切可能的时候都使用三脚架——你的手再稳也不可能比三脚架稳定；如果你在拍摄中需要经常快速移动，带一个独脚架也是个好主意。\n\n2．即便你手里的三脚架是捷信或者曼富图，也别忘了经常检查一下云台与三脚架的结合部是否有轻微的松动现象？快装云台的快装板是否因过度磨损而松动了？这些情况容易被忽视，但很可能让你的名牌三脚架变得“岌岌可危”。使用三脚架时还应该注意：对所有三脚架来说1/8s～1s往往也是震动最容易发生的速度。即使使用了三脚架，在大风天气或使用超长焦镜头的时候，仍然有必要采取额外的稳定措施。\n\n3．所谓的“安全速度”——镜头焦距的倒数（如手持200mm镜头，快门速度不应低于1/200S），只是一个大概的数值，对不同年龄、不同拍摄经验的人来说肯定有所不同；在你疲劳的时候与身体状态良好时的表现肯定也不一样。\n\n4．不要太迷信镜头的“防抖功能”——不要觉得有了它就可以从此告别手振了——它只能将“安全速度”下延2、3级快门速度而已；记得好好研究一下你的镜头说明书：看看在哪些情况下（如在三脚架上、在行驶的汽车里）“防抖功能”需要关闭。\n\n5．同样不要永远过于相信相机的自动对焦——即便听到合焦提示响起，焦点也不一定永远处于你所希望的位置。\n\n6．别太指望依赖后期电脑的锐化来改善照片的清晰度——这只在某个很小的范围内有效，超过这个范围就只能让照片变得更“糊”。\n\n7．在拍摄条件允许的情况下，使用尽可能低的感光度；在拍摄时尽可能获得完整的构图，而不要总是依赖后期剪裁——对于非全幅数码相机来说这尤其重要！\n\n\n","n":1}}},{"i":87,"$":{"0":{"v":"Sun","n":1},"1":{"v":"\n# 落日\n\n\n「太阳落山前后，才是夜景拍摄的最佳时机。」\n\n# 逆光拍摄\n\n首先要有太阳，时间是太阳刚刚出来或太阳快要落山光线很柔和的时候。\n1.举起的手机，打开 HDR 模式。\n2.调节位置，使被拍对象遮住太阳的一部分，具体看图（注意是一部分！）\n3.调节对焦点，使画面中得人不会一片漆黑（可以稍微有点暗）或者后面的天空一片白。\n4.拍照。\n5.后期用 VSCOcam 把阴影和高光调节一下（把阴影调节亮，高光的地方调暗），其他的按需调节。\n\n![](/assets/images/2021-09-09-23-14-53.png)\n\n# tip\n\n头顶光，可以理解为从上照射下来的光，比如中午的太阳，屋顶的灯，不建议使用这种光线拍照，无论是人还是景物都会缺乏立体感，拍人的话，头发，鼻子，美股，帽子什么的容易在脸上留下杂乱的阴影，很容易拍出大花脸。\n\n\n# 种类\n\n摄影是光影的艺术，有了好的光线，就可以轻松出大片。常见的光线有顺光，逆光，侧光，头顶光这 4 种。\n\n![](/assets/images/2021-10-04-22-37-56.png)\n\n顺光，就是光线从摄影师背后射过来的光，特点是很亮，可以保证清晰度，缺点是画面显得死板，没有明暗对比，因为顺光也叫平面光。\n\n逆光，是指镜头正对着光线拍摄，特点是，可以拍出唯美剪影和轮廓光，缺点是，掌握不好很容易过曝，手机比不了相机，所以对手机摄影要合理期待。\n\n侧光，是指从你和被摄者侧面照射过来的光，户外的话一般日出后日落前都是都是拍侧光的好时机，优势就是侧光能够很好的凸显明暗对比和立体感，缺点就是掌握不好会拍出阴阳脸。\n\n头顶光，可以理解为从上照射下来的光，比如中午的太阳，屋顶的灯，不建议使用这种光线拍照，无论是人还是景物都会缺乏立体感，拍人的话，头发，鼻子，美股，帽子什么的容易在脸上留下杂乱的阴影，很容易拍出大花脸。\n\n\n“直射光\n\n在晴朗的天气里，阳光没有经过任何遮挡直接射到被摄者身上，受光的一面就会产生明亮的影调，不直接受光的一面则会形成明显的阴影，这种光线称为“直射光”。在“直射光”下，受光面及不受光面会有非常明显的反差，因此容易产生立体感。\n\n当太阳被薄云遮挡时，阳光仍会穿透白云扩散下来，这时所产生的照明反差将会降低，非常适宜拍摄人物。\n\n散射光\n\n在阴天，阳光被云层所遮挡，不能直接射向被摄对象，只能透过中间介质或经反射照射到被摄对象上，光会产生散射作用，这类光线称为“散射光”。由于散射光所形成的受光面及阴影面不明显，明暗反差也较弱，光影的变化也较柔顺，因此产生的效果比较平淡柔和。”\n\n","n":0.302}}},{"i":88,"$":{"0":{"v":"People","n":1},"1":{"v":"\n# 拍全身\n\n把双脚放到画面下边缘，因为手机镜头是定焦的缘故，镜头边缘会产生拉伸的畸变，所以看起来腿会长一些，而且拍摄的时候手机最好平视或者低角度仰拍，因为近大远小的透视原理，会在视觉上显得腿更长，脸更小。\n\n![](/assets/images/2021-10-04-22-33-55.png)\n\n# 拍半身\n\n不要把画面边缘截取在颈部，胸部，腰部，膝关节这些部位，因为会有一种截肢的感觉，应该在肩部，胸部以下，胯部，和膝盖上方，看起来会自然一点。\n\n![](/assets/images/2021-10-04-22-35-08.png)\n\n# 坐着拍\n\n双腿不要内收，因为肌肉挤压会显得腿粗，而且短，要像左前方或者右前方伸出去，而且脚踝要伸直，让脚面充当小腿的延长线，因为伸直，肌肉绷紧，所以腿会显得细长。\n\n![](/assets/images/2021-10-04-22-35-42.png)\n\n# 自拍\n\n想自拍脸小，可以用遮挡的方法，用手，胳膊，衣服，帽子，围巾各种各样的东西都可以。\n\n![](/assets/images/2021-10-04-22-36-39.png)","n":0.447}}},{"i":89,"$":{"0":{"v":"Pose","n":1}}},{"i":90,"$":{"0":{"v":"Stand","n":1},"1":{"v":"\n人在站立时，双腿起着支撑身体的作用。为了支撑整个身体，我们基本只有两种站姿：一是两腿平衡站立均匀支撑，二是将重心转移至一条腿上。腿和脊柱成为了人物站立的中心线，穿起了三个体块：头部、胸部、胯部。以中心线为轴，这三个体块可以灵活地转动、倾斜，产生角度透视变化，三个体块尽量不在一个平面或打破平行，那么产生的变化就比较有力度，否则容易平淡。在一个轴线三个体块的组合变化下再加上两个手臂的动作，这样站姿的变化就更加丰富。\n\n![](/assets/images/2022-12-24-12-31-57.png)\n\n两条腿均匀地支撑整个身体，这样的站姿稳健但是呆板，缺少生气，也很难有效地突出人体的曲线美。所以，想要突破这种呆板的站姿，那么就要调整姿势，转移身体重心！\n\n![](/assets/images/2022-12-24-12-33-03.png)\n\n## 重心腿与辅助腿\n一条腿支撑全身的大部分体重，另一条腿轻轻落在地面，协助重心腿保持身体的平衡。这是我们摄影中常用的站姿，这样的站姿富有曲线感，也方便进行系列的动作演变。\n\n重心腿”与“辅助腿”可以转换。一组动作组合中，“重心腿”与“辅助腿”并不是固定不变的。我们可以根据具体的形体变化要求，进行两条腿的定位以及快速转换，这样可以直接变化身体曲线和引导上肢形体的变化。\n\n![](/assets/images/2022-12-24-12-33-49.png)\n\n![](/assets/images/2022-12-24-12-39-16.png)\n\n在整体变化中，保持重心始终是关键，也是保证整组动作完成的必要条件。首先，围绕轴心进行三个体块的变化，即头部、胸廓和胯部的前后倾斜；其次，进行两条手臂的摆放；最后是人物表情神态的展现。整体平行对称的站姿使人物具有装饰性，歪歪的头以及内八字的脚都使对称站姿增加了变化又给人可爱的感觉。\n\n![](/assets/images/2022-12-24-12-40-07.png)\n\n![](/assets/images/2022-12-24-12-40-15.png)","n":0.707}}},{"i":91,"$":{"0":{"v":"Calibration","n":1},"1":{"v":"# 脸型的调整方法\n\n1．胖脸型：\n 避免正面拍摄角度，可斜侧一些或用一些道具遮挡，尽量选择立体光拍摄。\n\n2．瘦脸型：\n 尽量选用正面角度拍摄，注意颧骨轮廓不要太突出，选择平光为主。\n\n3．脸不正：\n 不要正面拍摄，侧面角度要注意选择脸小面为主拍角度，可选择道具遮挡。\n\n4．凸额头：\n 调整头部角度上扬，头部不要太侧，可选择头发或道具遮掩住额头。\n\n\n\n5．双下巴：\n 调整下巴向前伸，拉长下巴赘肉，拍摄角度可高一些或用道具进行遮挡。\n\n6．下巴短：\n 调整下巴向前伸，拉长下巴与脖颈的距离，最好不要使用前顶光，可以用底光加强，使下巴凸显一些。\n\n# 五官的调整方法\n\n1．大小眼：\n 选择斜侧面角度，眼小这边靠近镜头拍摄。\n\n2．对眼：\n 尽量避免正面角度拍摄，选择斜侧面同时调整视线方向”\n\n“3．眼白多：\n 尽量避免视线角度太侧或太上，黑眼球角度调整尽量靠近镜头拍摄角度。\n\n4．眼无神：\n 尽量调整眼睛看向某一定点处，或者摄影师给个手势吸引被摄者的眼神，用光使眼睛产生眼神光。”\n“5．鼻梁歪：\n 尽量避免正面拍摄，选择侧面或斜侧面角度拍摄。\n\n6．鼻梁高：\n 尽量选择正面拍摄，不要选择太侧面角度，以平光为主，机位平拍角度。\n\n7．鼻梁低：\n 尽量选择正面拍摄，不要选择侧面角度，用正面光提高鼻梁高光。\n\n8．朝天鼻：\n 尽量不要正面上仰，避免鼻孔太突出。可调整下巴微收，机位升高拍摄。\n\n9．嘴巴歪：\n 尽量不要以正面角度拍摄，嘴歪面靠近镜头拍摄角度。\n\n10．扇风耳：\n 尽量不要以正面角度拍摄，用头发或道具遮挡，靠近镜头面耳朵处于阴影中。\n”\n# 肢体的调整\n\n“1．体态胖：\n 服饰搭配选择高腰服装，使用广角镜头、低机位角度拍摄，使身材拉长。\n\n2．腿形短：\n 尽量穿高跟鞋，使用广角镜头、低机位角度拍摄，使腿形拉长。\n\n3．双腿粗：\n 服饰选择长裙，使用道具掩饰，机位不要太低。\n\n4．手臂粗：\n 尽量选择带袖服装，手臂不要夹紧身体，更不要抬起手臂，可选择道具掩饰。\n\n5．上身短：\n 选择长一些的上衣，机位不要过低（在腰部以上），减轻腿部的长度比例。\n\n6．小腹凸：\n 调整模特尽量收腹，不要身体太侧，使用道具进行一定的遮挡。\n\n7．臀部垂：\n 服装上衣尽量长，遮住臀部。拍摄时不要选择太侧面的角度，可少拍站姿或依靠道具。\n\n8．胸不挺：\n 服装不宜太肥大，尽量让模特吸气挺胸，双肩后收，突出胸部线条。\n\n9．肩不平：\n 不要拍摄正面角度，可调整模特肩部高低，通过手臂造型提高低肩面。\n\n“10．“O”型腿：\n 不要正面平行站立，采用双腿交叉或自由步调整腿形线条，也可设计坐姿或趴卧等姿势。”\n\n\n","n":0.183}}},{"i":92,"$":{"0":{"v":"Basic","n":1},"1":{"v":"\n# 整体线条\n\nA型\n是指身体线条成“A”型结构，造型特点比较稳定、均衡。拍出的效果比较挺拔、有气势。注意模特的身体不要过于僵硬，会显得比较呆板；双腿尽量分开，但尺度不要太大；注意收腹、立腰、挺胸，适合风格比较时尚、前卫、另类的人群美姿设计。\n\n![](/assets/images/2022-12-24-12-29-37.png)\n\nC型\n是指身体曲线成“C”型结构，造型特点比较富有弹性，效果比较优雅、轻松。注意动作幅度不要过大，否则容易失去重心；身体向前倾时要注意腰部的挺拔；身体向后倾时要注意挺胸、收腹。适合风格比较优雅、内敛、含蓄的人群美姿设计。\n\n![](/assets/images/2022-12-24-12-30-08.png)\n\n“S型\n是指身体曲线通过头部、肩部、胯部、腿部的线条变化使模特形体产生“S”型结构。效果比较性感、妩媚，造型充满魅力与诱惑。注意动作幅度不要过大以免引起姿态变形。适合风格比较成熟、性感、前卫的人群美姿设计。\n![](/assets/images/2022-12-24-12-30-36.png)\n\n“L型\n是指身体结构呈“L”型，美姿的重心比较稳定，线条流畅，在单人或双人美姿中运用较多，站姿与坐姿均可设计。在拍摄模特穿裙装时也来利用裙摆的线条设计出流畅的“L”线条美姿。”\n![](/assets/images/2022-12-24-12-30-56.png)","n":0.707}}},{"i":93,"$":{"0":{"v":"Lightroom","n":1},"1":{"v":"\n调整一张照片的基础后期一共有两个重要部分：一个是光线、一个是色彩。所以你首先要知道的是，不同的调节工具不过是为了调整这两个部分即可。\n\n### 曝光\n\n这一参数基本上大部分人都知道，直接控制画面的明暗，用来控制一张照片的整体影调。\n\n### iphone鲜明度\n\n这个调节功能，绝对值得一吹。不仅仅是我自己，身边的很多摄影师都对这个调节选项赞不绝口。更重要的是，这个鲜明度仅此一家。我没有在任何后期软件上看到过这个调整功能，就算有也是指颜色。而在这里，你可以理解为：「智能 HDR 的后期调整。」\n\n### 高光\n\n高光是指调整画面中亮度较高的部分。如果画面中有过亮的地方可以通过高光进行调节。很多人会喜欢用这个工具压曝光。但是其实数码摄影的特点就是一旦过曝就会损失很多细节。所以其实大多数情况如果画面中出现过曝的情况，想要拉回很多细节是很难得。\n\n不过，还是会有效果。而且实际使用中，因为这一代的 iPhone 智能 HDR 已经非常好，照片高光过曝基本上只会在超广角镜头中出现。我更喜欢使用这个工具增加高光，因为这样很多时候可以给画面中带来光线感。\n\n### 阴影\n\n阴影是指调节画面较暗的部分。一般如果你拍摄的画面中较暗的部分较多，想要更多细节，可以通过提升阴影获得。而且数码相机的特点是，阴影中往往会包含很多细节。但是需要注意的是，如果没有节制的提升阴影，会使画面出现很多噪点，所以一定要控制好量。\n\n### 对比度\n\n对比度可以让画面中暗的地方更暗，亮的地方更亮。这种调节方式可以让画面直接变的更加立体。也会更加具有层次感，如果因为天气等原因你拍摄的照片有些偏灰，那么对比度调节可以让画面更加通透。\n\n### 亮度\n\n亮度调节主要是调节照片的中间调。如果你想保护好阴影或者是曝光不要受过多的改变，那么调节亮度是一个很好的选择。不过我基本上很少使用，因为我认为中间调对于照片的整体色彩和层次还是影响比较大的。\n\n### 黑点\n\n简单来说就是可以让画面的阴影从某一个亮度开始全部变黑。正常后期很少修饰，如果拍到了很灰的照片那么这个功能可以让照片更有对比。\n\n### 饱和度\n\n调整照片的整体颜色浓度。如果是在一些风光作品、或者是静物作品中，我建议使用饱和度进行颜色的调整。一般来说大家都会喜欢让照片的饱和度更高一些，这样更加吸引眼球。但是高饱和度往往不耐看，相反，一些低饱和度的照片反而能够经久耐看，所以这也是什么很多经典的摄影作品都是低饱和度的原因。\n\n### 自然饱和度\n\n我自己其实很少调节饱和度，如果是想要照片的饱和度更高一些我会使用自然饱和度。自然饱和度一般来说都会提升画面中相对中性的颜色。更加关键的是，自然饱和度会适当的保证肤色不受影响，这对一些人像照片来说是非常重要的，因为很多人增加饱和度都会发现肤色变的很奇怪。\n\n色温\n\n而且后期也有很大的调整空间，比如色温调节。你只要知道这个参数可以让你的画面偏蓝还是偏黄，从而整体影响画面的冷暖调即可。\n\n### 色调\n\n你只要知道这个参数可以让你的画面偏绿或者是偏洋红即可，也是整体上影响画面的冷暖调。\n\n### 锐度和清晰度\n\n其实这两个参数从原理上来说，区别并不大，只不过是一个作用范围的问题。锐度更像是强化画面中边缘线条之间的过渡，而清晰度则是画面整体的对比度。这两者都可以让你的画面看起来更加清晰，你可以按照自己的喜好调节就好。\n\n### 噪点消除\n\n噪点消除一般都是用在弱光照片中，用来提升画面的纯净度，但是有一点要说明的是：\n\n「噪点消除的使用一定要有度，如果过度的使用会让画面的清晰度直线下降。」\n\n所以一般来说，如果我使用了噪点消除我还会给画面增加一点清晰度。\n\n### 晕影\n\n这是一个在人文纪实作品中经常使用的后期手法，即通过四周的曝光减淡，从而突出画面中央的主体。简单来说，就像是一个聚焦的过程。不过还是那句话，一定要适可而止。\n\n大家可能也注意到顶部的「自动」功能，这个功能其实是很强大的，我们在打开「视觉透视剪裁的调整」，通常它会直接进行自动调整。在前期拍摄了一些有一定视角歪斜的照片，绝大部分时候可以非常完美的一键式的完成校正、水平和垂直，当然你也可以关闭「自动」，然后手动进行调整。\n\n还有两个很重要却容易被忽略的独门秘技值得分享，首先是：\n\n1. 所有我们上述提到的参数调整，不仅仅适用于照片，也同样适用于视频。是的，这些参数调整很多后期软件在照片上都很常见。但是这么丰富的视频调整工具，很少有软件具备。所以如果你想要给自己的视频进行调整那么 iPhone 相册目前看来竟然是最佳选择。\n\n我就拿我自己非常喜欢的 Retouch 这个软件举例，这款软件可以是快速地消除画面中不必要的部分\n\n「自己先想好需要怎样的画面，再使用工具进行实现。」","n":0.2}}},{"i":94,"$":{"0":{"v":"Lens","n":1},"1":{"v":"\n# 焦距\n\n可以看出影像就是光线通过一个透光的小孔进入一个黑盒并被相机的传感器（或者是胶片）记录下来，这其中小孔就是我们所说的镜头。\n\n焦距是指镜头的光学中心点和传感器的距离\n\n## 广角\n\n超广角（13mm 定焦镜头）很多人对于超广角的第一印象肯定是「广」，这个「广」包含的是拍摄足够多的画面内容，其实对于超广角来说摄影师看中的是**夸张的透视效果**。\n\n越是广的镜头，越会有非常强烈的空间感，因为在超广角中透视强烈，会遵循「近大远小」的规则\n\n其实本质上这种拍摄手法恰恰是合理利用了超广角的空间感。把画面分为了「前景」「中景」「远景」三个不同的组成部分。我们要做的就是合理的把这些景物填充进去。\n\n超广角照片中低角度远远多于高角度。也就是说，使用超广角仰视拍摄往往更容易出现好照片\n\n## 长焦镜头\n\niphone的 所谓的数字变焦虽然听起来是比较高级的，但其实本质上就是一种裁切放大","n":0.408}}},{"i":95,"$":{"0":{"v":"Iphone_setting","n":1},"1":{"v":"\n# 夜景模式 \n\niPhone 的夜景模式不可以主动打开，手机会自行判断是不是需要夜景模式，但可以强制关闭，只要点击画面的左上角夜景图标就可以看到。\n\n夜景模式的最长时间是 30s，这种情况前提是手机必须判定你的手机在三脚架上或者是足够稳定的环境，这样你就可以拍摄到星星\n\niPhone 夜景模式的核心在于颜色还原。其实我们很多时候觉得夜晚拍照不好看，亮度只是一方面，其实颜色还原才是关键，这也是 iPhone 的夜景模式和其它手机一个夜景模式比较核心的区别—色彩还原\n\n# 手电筒\n\n这就是其实在日常拍摄时，我们不能忽略了「补光」的作用。目前我们的 iPhone 都已经具备了手电筒的功能，在拍摄一些主体相对较近的画面时，我们可以使用另一部 iPhone 的手电筒打开进行光源的补充。我们不仅仅可以通过手部的位置移动改变光源的方向，我们也可以通过重按手电筒进行光源强度的调整。\n\n# 实况照片\n\n实况照片的本质含义是给每一个瞬间更好的容错率。这个功能原理也是非常简单，就是每一次按下快门瞬间前后各 1.5 秒都记录下来。你可以简单的理解为直接拍摄了一个「动图」\n\n进入编辑界面，可以重新选择照片。因为实况照片本身拍摄了对应前 1.5 秒和后 1.5 秒的图像，所以如果我们想要更好的瞬间就可以重新寻找。这对一些合影留念的照片有着非常好的使用场景。拍摄一张人像，可能会出现表情包或者是闭眼的情况，此时就可以使用实况照片重新找到一张表情更好的。\n\n实况照片可以演化为不同的效果。这里你可以直接理解为动图制作。打开相册以后，找到对应的实况照片，上滑就可以进入到效果界面。坦率地说，我认为苹果在这里的设计还是有点深，导致很多用户并不知道这里还有一个效果的功能。\n\n## 长曝光\n\niPhone 也是有长曝光功能的。只不过这项功能是在实况照片中隐藏。但是需要说明的是，因为这里的长曝光是一种多张合成，所以想要获得清晰锐利的照片最好在按下快门前后各 1.5 秒保持手部的稳定\n\n# 快捷键\n\n只需要「向下滑动快门」即可。也就是说，现在横拍的拍摄界面快门键是「向下是高速连拍、向上是视频快录」，竖向拍摄时则变为向左和向右。\n\n# 滤镜\n\niPhone 本身的滤镜是可以直接前期使用的。我们可以在拍摄界面就直接选择滤镜，预览画面就可以直接看到滤镜效果。而且有一点需要说明的是，iPhone 的拍摄效果都是可逆的。比如你使用一个滤镜以后，如果不喜欢了，只要在相册里直接复原即可，所以你可以大胆地在前期使用任何你想要的滤镜，不需要有任何的顾虑。","n":0.189}}},{"i":96,"$":{"0":{"v":"Food","n":1},"1":{"v":"\n# 食物\n\n\n1，如果在普通餐厅，大排档这些地方拍照，因为环境很乱，适合近距离拍特写，突出食物本身，忽略杂乱的环境。\n\n![](/assets/images/2021-09-09-23-34-17.png)\n\n2. 如果是圆盘子，适合垂直俯拍，而且要使用正方形构图，不要只关注食物，餐具也很重要。\n\n![](/assets/images/2021-09-09-23-34-37.png)\n\n3. 常见拍实物的角度有垂直 90°，适合摆盘造型好看，食物比较扁平的，斜上 45° 能够很好地展现食物的层次感和周围的环境氛围，水平 0° 适合层次很多的食物，比如汉堡，蛋糕，马卡龙之类的食物。\n\n![](/assets/images/2021-09-09-23-35-01.png)\n\n4. 如果主体环境过于混乱，那么就要在画面中留白。注意想表达的主题\n\n\n5. 而区别于大量纯色的另一种干净是空间感。上图中的柠檬鸡无论是前景还是背景都色彩繁杂，但前景与观者之间空隙带来的距离感，和被虚化的背景都在强调主角的同时还减轻了观者的视觉压力，我认为它同样也是一张「干净」的照片。\n\n![](/assets/images/2021-10-04-22-51-23.png)\n\n6. 拍出场景感，比食物本身更诱人\n\n![](/assets/images/2021-10-04-22-52-47.png)\n\n还有一种非常值得分享的场景是朋友聚会，其实在很多时候我们分享一次尽兴的聚会时不一定非得是最后的丰盛一桌，这个过程其实更有趣，上图是在朋友家包饺子的时候随手一拍，最后竟发现它是我对今晚最满意的一张照片。\n","n":0.289}}},{"i":97,"$":{"0":{"v":"Focus","n":1},"1":{"v":"\n# 光圈\n\n我们前面说到光圈通过变大缩小可以改变画面的亮度，但是在相机上，因为光圈都是可以改变的，光圈带来的不仅仅是画面的明暗，还有「虚化效果」\n\n光圈：光圈越大，景深越小；光圈越小，景深越大。\n\n焦距：焦距越长，景深越小；焦距越短，景深越大。这也为是为什么 85mm，70-200mm 等焦距适合人像的原因，因为虚化好。\n\n# 对焦\n\n我们在拍摄的预览画面里点击会出现一个方框，这个方框就是所谓的对焦框。我几乎所有的照片都会主动点击对焦框拍摄\n\n我们很多时候拍摄照片不够有趣，是因为没有尝过更近的拍摄，很多场景如果能够更近一点会有着很不错的效果。\n\n拍摄这样的画面时，还有一个小窍门：**在调焦时不要把焦点放在可能虚动的物体上**——哪怕它实际上处于主体的位置；而应该把焦点放在不动的景物上，这样才能让画面的静态部分获得更清晰的效果。\n\n## iphone\n\n在打开 iPhone 的人像模式以后，我们需要点击画面右上角的一个 f 形的图标。点击图标以后，我们的画面正下方就会出现一个调节光圈的界面。我需要在这里说明一下，这里的光圈仅仅是模拟了虚化效果，而不是改变真正的进光量，所以文章前面提到的光圈改变曝光在这里不适用。\n\n\n### 摄影室灯光\n\n你可以完全理解为这个光效就是为你的面部进行补光，尤其是适合一些注意自己肤质的女孩子。基本上我给我们家领导拍摄人像的时候基本上都是默认开启这个光效的，差距非常明显，所以一定要打开。\n\n### 轮廓光\n \n如果说摄影室灯光是给女孩子的，那么轮廓光就是给男孩子的。因为轮廓光会强化你面部的光线效果。让你的面部阴影更黑，高光更亮。也正是因为如此，会给人非常硬朗的感觉。所以这也是为什么说，这个光效更适合男孩子的原因。\n\n从我的实际使用经验来看，人像模式在半身人像以上有最好的表现。全身人像因为目前的算法局限会显得视觉上不真实。","n":0.277}}},{"i":98,"$":{"0":{"v":"Exposure","n":1},"1":{"v":"\n摄影是用光的技术\n\n# 原理\n\n- 快门时间\n  - 通过小孔打开的时间长短。小孔打开的时间越长，孔径不变的情况下进光的时间越长，自然光线就会越多，画面就会越亮，这就是我们所说的快门速度。\n- 光圈大小\n  - 通过小孔的孔径大小。小孔的孔径越大，那么单位时间内，自然光线就会越多，画面就会越亮，这就是我们所说的光圈。一般来说，光圈的数值为 f1.8、f2.8、f8、f16。并且数值越小，才意味着光圈越大，也就是孔径越大，进光越多。\n- 感光值\n  - 对于光线感受的能力越好，画面越亮。但这里有一个重要前提，随着感光值的提升，画面质量会开始下降。因此想要很好的画面效果，那么就需要尽可能地降低感光值。\n\n所谓的测光模式，不过是在计算画面中的曝光时针对重点的曝光对象有更多的加权。\n\n## iphone 拍摄\n\n所以我们在进行 iPhone 拍摄的时候，可以通过以下两种方式进行曝光的干预：\n\n01 点按画面\n\n02 调节滑杆\n\n我们可以在点击画面以后，看到一个对焦框，在对焦框的旁边有一个滑杆。拖动滑杆进行曝光调整，向上滑动提升画面亮度，向下滑动降低画面亮度。\n\n\n## 直方图\n\n通过直方图能够判断一张照片的曝光是否准确。直方图中色阶左侧反映的是影像的暗部；右侧代表影像的亮部。正确的曝光方式是充分利用数码相机所能记录的曝光范围，在必须有所取舍的情况下，不要损失亮部层次。","n":0.229}}},{"i":99,"$":{"0":{"v":"Composition","n":1},"1":{"v":"\n1. 一幅好照片要有一个鲜明的主题（有时也称之为题材）;\n2. 一幅好照片必须能把注意力引向被摄主体;\n3. 一幅好照片必须画面简洁。\n\n摄影构图被习惯称为“减法构图”，把画面上所有分散注意力的东西都“减”下去，只留下那些最强烈的、最想表现的东西——对于新手入门，这不失为把握构图一个好办法。\n\n摄影师的画面中没有「多余的事物」。画面中的每一个元素都是为了画面的表达，即使有多余的也会通过事物的摆放或者是裁切等方式去掉。而这一切，也属于构图。\n\n当我们构图的时候，就是通过对画面中元素的选择，布局从而能够达到：「让照片读者的视线引导向被摄体，以及简化画面中没有必要的元素的效果」。\n\n构图方式的选择没有对不对一说，更多的只能是适合不适合。所以，这就需要我们可以自行检验自己的构图方式。那么检验方式是什么呢？\n\n检验的方式就是我前面提到的，构图的意义是不是每一条都符合，怎么样，是不是很简单。\n\n\n## 三分法\n\n三分法，又称井字构图法。这是几乎每一个摄影师都需要掌握的构图方式。在这种构图方法中，我们需要在拍摄画面中抽象出两横两纵的线。因为这样其实特别像是一个井字，所以我们也叫井字构图法（以下全部统称为三分构图法）。\n\n非常多的影视作品中经常会使用黄金螺线法则这种方式进行构图。但是需要说明的是，一般来说只有在 16:9 的画面中，我们才会使用这种黄金比例分割。如果不是，效果反而适得其反。而如果不是 16:9 的比例我们就会对这种内容进行演化，演化的结果自然是三分法。\n\n### 居中\n\n居中构图是一种最正经的布局方式，很多时候也就意味着「威严」。所以，一些严肃人物的肖像照片几乎都是使用居中构图的方式。尤其是，当你的拍摄主题在画面中的元素比较大的时候，选择居中构图没有什么不妥的。\n\n\n### 对称\n\n对称构图是一件比较「形式化」的构图\n\n#### 镜面对称\n\n我们可以找到生活中各种各样的反射面。这些反射面是最为简单的产生对称的方式，比如水面的倒影就是一个最为简单的对称构图方式。如果是很大的水面，我们在拍摄镜面对称的时候，只要稍微放低角度就可以轻松完成拍摄。\n\n但是当你实际操作的时候，就会发现有的时候即使手机已经贴紧地面了，但是角度仍然不够低。这个时候，我们仅仅需要把我们的手机倒转一下，这个时候镜头几乎已经完全贴近地面的时候，就可以轻轻松松的完成拍摄。不要小看这种拍摄方式，这很多时候可以让你的照片增添很多光彩。\n\n#### 元素对称\n\n最为简单的就是我们在画面中绘制一条线\n\n对角线构图的本质是一种均衡感，其实从视觉服务上跟对称还是有些神似，但是其实还是有着本质不同的。因为在对角线构图中，我们的元素不需要「呼应」关系，需要的是「对立」关系\n\n![](/assets/images/2021-09-09-23-08-04.png)\n\n### 黄金螺旋\n\n黄金螺旋：在矩形中按照黄金比率旋进渐进无限分割，切点的连线形成对数螺旋线。　　\n首先，将要拍摄的图片的主体作为起点，就是黄金螺旋线的绕得最紧的那一端。这种类型的构图通过那条无形的螺旋线条，会吸引住观察者的视线，创造出一个更为对称的视觉线条和一个全面引人注目的视觉体验。\n\n## 引导线构图\n\n需要我们细致的聊一聊。因为在所有的构图方式中，如果能够用好引导线构图绝对会让你的作品脱颖而出。\n\n如果你走在路上，你会发现脚下在向前延伸的同时会逐渐交汇并消失在一点上，那么这个点就是叫做灭点。\n\n引导线是一种非常直接的引导我们视线的方式。通过引导线可以让我们的视线在画面中流动，从而展现画面中的不同主体。\n> \n这也是为什么，我们今天去看，非常多的风光摄影佳作，几乎随手可以看到风光摄影作品中使用引导线构图的原因。\n> \n当然，引导线构图绝不仅仅是只有线条的这样一个方式。其实，只要是画面中，任何具有指引含义的物体，都可以算作是引导线构图。\n\n\n## 前景\n\n是不是能够利用好前景，目前已经是一个合格的风光摄影师的必备技能\n\n为什么我们需要前景。一般来说，我们的照片都是二维的。但是本质上并非如此。我们在前面的对焦部分了解过这里的知识。大部分的拍摄都是主体和背景两个部分来完成。基本上，画面的空间感只能来自于主体和背景之间的距离。\n\n我们的空间开始加入了第三个层次。那这第三个层次就会极大地丰富整个画面的空间感，这也是前景最为基本的作用，或者说是最重要的作用。\n\n前景的好处远不止提高空间感中这样一件事。如果你是大面积使用前景时，还起到了简化画面的作用。例如，很多时候我们会使用一些植物花朵进行遮挡，让整个画面更加干净。所以，如果下次你的画面比较杂乱，不妨就可以使用这种方式来简化画面。\n\n前景仍然需要低调。很多人使用的前景过于明显，这种明显可能是来自于颜色，明暗等等。所以大多情况下需要记住前景是为了主体服务的，不能够喧宾夺主。\n\n## 寻找画框\n\n框式构图，就是尽可能地使用生活中一切可能的「框」把我们的主体，框在其中的方式。本质上，其实框式构图的好处和前景非常相似。首先是依然会营造一种独特的空间感。这种空间感和前景不同的是通过营造画框外和画框里两个世界来进行。也就是说，框外一个世界，框内一个世界。让我们照片有更加丰富的层次。\n\n### 质感构图\n\n说到质感，是一件值得仔细探讨的内容。当然，这种质感有很多的元素一起组成。而我们这里讨论的质感是最为直观的一种。摄影是一种视觉为主的艺术，这里面是所以使用了「为主」这个词是因为，其实摄影可以不仅仅是视觉。我们所有的构图技法都是服务于视觉上的刺激。但人对这世界上的事物很多时候时候是一个综合感官的产物，例如我们可以闻到气味，吃到味道以及摸到的手感等等。\n\n### 重复构图\n \n我们都知道重要的事情说三遍，本质上是因为在语言上，重复就意味着一种强调，其视觉上也是如此。这也就是重复这种构图形式的基本意义。其实想要拍摄到重复的构图需要取决于景物本身，因为只有景物本身具有重复特性，才能进行拍摄。\n\n# 拍人\n\n![](/assets/images/2021-09-09-23-31-25.png)\n\n如果太胖，太丑，可以用头发，帽子，书本，包包，树枝树叶，等物品遮挡脸部，腰部，而且最好拍侧身，叉腰或把胳膊抬起来，让肌肉绷紧。想自拍脸小，可以用遮挡的方法，用手，胳膊，衣服，帽子，围巾各种各样的东西都可以。","n":0.209}}},{"i":100,"$":{"0":{"v":"Color","n":1},"1":{"v":"\n# 色彩\n\n","n":0.707}}},{"i":101,"$":{"0":{"v":"Angle","n":1},"1":{"v":"\n所以在拍摄之前应选取不同的方位、角度对物体进行观察及比较，从中找出一个最可表达主题、最生动的视点，以找到最合适的构图。\n\n（1）正面拍摄\n\n正面拍摄是一种最常用的摄影角度。正面拍摄可以产生庄严、平稳的构图效果。但平稳的线条、对称的结构也会因缺乏透视感而显得呆板，而且很多时候会因为对象的受光情况相似而不能凸显对象应有的立体感。\n\n（2）侧面拍摄\n\n用斜侧的摄影角度，画面上原来的并行线条变成了斜线，具有纵深感，能将人的视线引向深处，增强立体感。而视线跟随斜线延伸，也会使画面变得生动，随斜侧方位的角度变化，其透视效果也会出现有趣的改变。\n\n（3）仰视拍摄\n\n仰视拍摄指的是向斜上方的角度进行摄影，多用于拍摄高大的景物。这种拍摄角度既可以拍到高大景物的全景，又可以形成垂直[…]”\n\n","n":1}}},{"i":102,"$":{"0":{"v":"Negotiation","n":1},"1":{"v":"\n# 说不 \n\n- 不要随便答应除非你真的想做","n":0.5}}},{"i":103,"$":{"0":{"v":"Movie","n":1}}},{"i":104,"$":{"0":{"v":"Me","n":1},"1":{"v":"\n\n配镜 \n\n右眼：125度 50*95度散光 \n\n左眼275 125*90度散光 \n\n \n\n \n\n西服 36R \n\n裤子 30*30 \n\n8码 鞋子 \n\n胸围 38 \n\n袖长 26 ","n":0.243}}},{"i":105,"$":{"0":{"v":"Love","n":1},"1":{"v":"\n- [[Basic|life.love.basic]]\n- [[分手的理由|life.love.breakup]]","n":0.577}}},{"i":106,"$":{"0":{"v":"Sex","n":1}}},{"i":107,"$":{"0":{"v":"Touc","n":1},"1":{"v":"\n# 爱抚\n\n女性性感区比男性分布广，包括头发、脸颊、口唇、舌、耳朵、颈部、乳房、手、下腹、臀部、大腿内侧等。女人性感最强烈的部位是生殖器官，即阴蒂、小阴唇、大阴唇周围的区域和阴道口。触摸阴蒂不但能激发女方的性欲，而且能引起她的快感。可以说，阴蒂是控制女性性行为的主要“杠杆”。\n\n女人似乎对抚摸的力度更为敏感。通常她们喜欢先轻柔地抚摸，再逐渐增加力度。很多人以自己喜爱的方式抚摸配偶，但这不一定是对方所喜欢的。你应先弄清对方的真正需要（如抚摸部位和力度等），方可获良好效果。\n\n用手去触摸、抚弄、搔抓、揉捏或挤压乳房这一主要性感点，会产生特殊快感。乳房的性反应同男性的阴茎一样，在搓揉或吸吮刺激中即有竖起现象；外阴是性刺激的核心部位，尤其是阴蒂，一旦被按摩刺激，可使女性感受到性交之外的最大满足，同时也就做好性交前的生理和心理准备——大阴唇扁平、膨起，阴道内充血并渗出多量分泌物使阴道润滑。只有这时，女性才达到充分的性兴奋，才会有性交的要求，双方才有进入高潮并获得性满足的可能。\n\n## 愉悦点\n　●轻柔按摩乳房会有强烈愉悦和性欲。\n\n　　●乳头对温柔爱抚有反应，增加性兴奋。\n\n　　●唇和口对触摸很敏感，可增加性感。\n\n　　●按摩下腹会有放松效果，升高性反应及期待。\n\n　　●按摩大腿内侧除可减缓性紧张外，还能帮助性感流畅。\n\n　　●触摸耳垂能很快传达性感刺激及愉悦。\n\n　　●爱抚颈背能够激起十分强烈的性兴奋。\n\n　　●轻抚腋下及柔软的上臂内侧，会觉得很愉快。\n\n　　●臀部很性感，对强而有力的按摩有反应。\n\n　　●靠近性器官的鼠蹊部是相当性感的地方。\n\n　　●膝（膝盖后方）对轻柔的按摩和碰触灵敏度也很高。\n\n　　●按摩刺激拇趾腹，会触发全身的性反应。\n\n## 脸部\n\n脸部轻轻按摩伴侣的脸能带来高度的安全感。用你的手和手指围住他的颚和下巴，然后双手沿着下颚骨向上按摩到耳部，以手指向上和向外舒缓掠过他的脸颊，如此重复数次。小心地以指尖描摩着伴侣的唇形，温柔而缓慢地按摩唇四周、唇上\n\n## 头\n\n头和颈部手回到伴侣的肩膀，花几分钟按摩伴侣的颈部，然后，往上按摩至伴侣头发里，让你的手指头散开来，按摩他整个头的头皮，就好像你正在帮他洗头发一样。接着，一手一边，拇指放在耳朵下面，其他手指放在头骨后面，轻轻往你这边拉，如此可以放松头部的紧张。然后按摩耳朵，交替按摩太阳穴、脸颊、下颚。\n\n## 手\n\n　　手臂用来回流动的方式，按摩手臂的最上端，从肩头到手腕，保持你的姆指在上端，其他手指圈着手臂。试试交叉按摩法，并且按摩手臂最大块肌肉处。然后拉他的手臂让其伸展，按摩手掌和腕部，轻轻外拉他的手指。对另外一只手重覆同样的的动作。","n":0.408}}},{"i":108,"$":{"0":{"v":"Kiss","n":1}}},{"i":109,"$":{"0":{"v":"Woman_type","n":1},"1":{"v":"\n# 分类\n\n- 家庭 vs 个人\n- 保守 vs 开放\n\n\n性开放和保守看上床时间\n家庭和个体看家里谁说了算\n\n## 开放 个体 （白左女权）\n\n- 割腕女\n  - 纹身多\n  - 性开放\n  - 拥有自己身体的自治权\n  - 抛开被男人的束缚\n- 女猎手\n  - 行为主动\n  - 温柔\n  - 家庭母亲主导\n  - 主动推动关系\n\n## 保守 个体 （田园女权）\n\n- 田园女权\n  - 相信婚姻关系\n  - 认为自己的身体价值是最重要的\n  - 推迟上床\n  - 母亲主导\n  - 向男方索取利益\n- 拜金女\n  - 可能找不到1对1\n  - 只认钱\n  - 多个男人对自己投资\n  - 短期租赁\n\n## 开放 家庭 （自由保守）\n\n- 女玩家\n  - 夜店\n  - 父亲主导\n  - 男生做决定\n  - 在意男性的看法\n  - 在不同男生中游走\n  - 女性特征让男性主动\n- 灰姑娘\n  - 坠入爱河很快\n  - 容易变心\n  - 很难不理会前男友\n  - 不会自己做决定\n  - 会被男人牵着走\n  - 立规矩\n\n\n## 保守 家庭 （传统保守）\n\n- 浪漫女\n  - 父亲主导\n  - 追求1对1\n  - 渴望理想伴侣\n  - 自带剧本，迎合剧本\n- 混圈女\n  - 1对多\n  - 通过男人上位\n  - 依附男人\n\n延缓做爱时间，不会劈腿，会隐藏自己\n\n女人不希望男人出轨，但她们喜欢一个可能出轨的男人。","n":0.1}}},{"i":110,"$":{"0":{"v":"Understand","n":1},"1":{"v":"\n# 了解一个人的话题\n\n合适\n身体维度、工作维度、人际交往维度和未来 / 精神维度 \n\n 第一组\n1. 如果可以在世界上所有人中任意选择，你想邀请谁共进晚餐？\n2. 你想成名吗？想以什么方式成名？\n3. 打电话之前你会先排练一下要说什么吗，为什么？\n4. 对你来说，“完美”的一天是什么样的？\n5. 你上次自己唱起歌来是在什么时候，给别人唱呢？\n6. 如果你能活到90岁，同时可以一直保持30岁时的心智或身体，你会选择保持哪一种呢，心智还是身体？\n7. 你是否曾经秘密地预感到自己会以怎样的方式死去？\n8. 说出三件你和你的伴侣看上去相同的特征。\n9. 人生中的什么东西最令你感激？\n10. 如果你能改变被抚养成人过程中的一件事，会是哪一件。\n11. 花四分钟时间，尽可能详细告诉伴侣你的人生经历。\n12. 如果你明天一觉醒来就能拥有某种才能或能力，你希望那会是什么能力呢？\n\n第二组\n\n13. 如果有一个水晶球可以告诉你关于自己、人生，未来乃至任何事情的真相，你会想知道吗？\n14. 有没有什么事是你一直梦想去做而没有去做的，为什么没有做？\n15. 你人生中最大的成就是什么？\n16. 在一段友谊之中你最珍视的是什么？\n17. 你最宝贵的记忆是什么？\n18. 你最糟糕的记忆是什么？\n19. 假如你知道自己在一年内就会突然死去，你会改变现在的生活方式吗？为什么？\n20. 友谊对于你来说意味着什么？\n21. 爱与情感在你生活中扮演着什么样的角色？\n22. 和你的伴侣轮流说出心目中对方的一个好品质，每人说五条。\n23. 你的家人之间关系是否亲密而温暖，你觉得自己的童年比其他人更快乐吗？\n24. 你和母亲之间的关系是怎样的？\n\n\n第三组\n\n1.  每人用“我们”造三个句子，并含有实际情况，比如“我们俩在屋子里，感觉……”\n2.  补完这个句子：“我希望和某人在一起，分享……”\n3.  如果你想和对方成为亲近的朋友，请告诉对方有什么重要的事情是他或她需要知道的。\n4.  告诉对方你喜欢他或她身上的什么东西，要非常诚实，说些你不会对萍水之交说的东西。\n5.  和对方分享生命中那些尴尬的时刻。\n6.  你上次在别人面前哭是什么时候？自己哭呢？\n7.  告诉对方，你已经喜欢上了他或她身上的什么品质。\n8.  你觉得什么东西是严肃到不能开玩笑的，假如有的话。\n9.  如果你今晚就将死去，而且没有机会同任何人联络，你会因为之前没有对别人说什么话而感到遗憾，你为什么到现在都没有对他们说这些话呢？\n10. 假设你拥有的全部东西都在你的房子里，现在房子着了火，救出家人和宠物之后，你还有机会安全地冲进去最后一次，取出最后一件东西，你会拿什么，为什么？\n11. 你的家人中，谁去世了会令你最难过，为什么？\n12. 说出一件你的个人问题，问对方如果遇到此事要如何解决。另外，也要让对方如实告诉你，在他或她眼中，你对于这个问题的感受是怎样的。\n\n\n- 什么使你现在的生活开心\n- “If you could predict the future how would you want it to look?”\n- “What is your biggest fear?\n- “How was your childhood?” \n- “What makes you feel special?” \n- “What is a quality you look for in a man?\n- “If you had a million dollars what would you spend it on and why\n- “What is your greatest passion?” \n- “Are you a spiritual person?” \n- “How often do you see your best friend ?” \n- “Who is the biggest influence in your life?”\n- “What do you value most in life?” \n- “What’s the hardest thing you have ever been through?” \n- “What are you grateful for in life?” \n- “If you could change one thing about the world, what  would it be?\n- “If you could go back to your childhood, what is one thing you’ve learned that you would teach another child?” \n- “What are your top priorities in life right now?” \n- “How do you react when someone makes you angry ?”\n- “What is your favorite attribute?” \n- “You know you’re beautiful, right?” \n","n":0.068}}},{"i":111,"$":{"0":{"v":"Type","n":1},"1":{"v":"\n几乎所有的爱情研究人员都将两种基本类型的浪漫爱情区分开来：激情型和陪伴型。 激情型爱情的特点是强烈的情感、兴奋、无法抑制的性欲和对所爱的人的强烈关注。如果这段关系是牢固的，陪伴型爱情就会取代它，这是一种更温和、更稳定的体验，以相互信任、可靠和温暖的感觉为特征。与通常短暂的浪漫激情相比，陪伴型爱情通常持续时间更长，并随着时间的推移而加深。陪伴型爱情的双方可以自由地谈论任何事情，并感到彼此之间深深地理解。因此，如果激情型爱情像可卡因，那么陪伴型爱情就更像一杯美酒 —— 美味可口，令人愉悦，很少有心悸和躁狂。\n\n# 过程\n\n在他的《幸福假说》一书中指出了每段浪漫关系中的两个危险点。第一个危险点在激情之爱阶段的顶峰，此时处于极度兴奋状态的伴侣们会一头扎进去。充满激情的爱，每一秒都想待在一起，他们会闪电般地搬到一起同居乃至结婚。有时，这些夫妻能够从激情阶段过渡到陪伴阶段。但是，如果在这个关键时刻，他们相信唯一真正的爱是由痴迷、性刺激和激情所定义的，他们可能会在最初阶段的吸引力消退时（这最终是必然的）便决定不再相爱了 —— 他们会不断地处于失望之中。\n\n第二个危险点出现在热恋开始消退的时候。当情侣们从最初的兴奋中走出来时，他们开始注意到心爱伴侣的缺点，而不知何故，他们之前竟然设法忽略了这些缺点。他们不再发送调情或充满激情的短信，只是提醒她要喂猫之类的琐事。海特认为，当一对夫妇到了这个阶段，他们必须要有足够的耐心。幸运的是，如果他们允许自己在他人身上投入更多，他们可能会发现自己有了一个真正美好的生活伴侣\n\n我们的内隐爱情观念的影响；我们是否有能力发展成安全型依恋关系的影响；我们能做些什么来弥补最初阶段的强烈欲望的丧失。\n\n## 内隐爱情观念\n\n对于那些相信浪漫命运的人来说，满足感和在一起的时间长短之间联系更强，但它也与应对压力时的逃避策略有关。“命中注定”的关系在风平浪静的时候是最幸福的，但当狂风暴雨袭来时，他们的爱情小舟却会搁浅。这些夫妻发现，当他们的伴侣不可避免地不再符合他们的理想标准时，他们很难在关系中保持满意。相比之下，那些认为爱情是随着年龄增长而增长的夫妻在应对策略上投入了更多的努力。随着时间的推移，他们会更满意 —— 即使他们的伴侣不再满足他们最初的理想。他们期望自己的伴侣随着时间的推移而改进和变化，他们对关系衰退的暂时性有更好的理解。对于“让我们一起解决”的夫妻来说，冲突与他们对关系质量的评估没有关系；相反，他们会积极地与伴侣讨论问题，并修复彼此之间的裂痕。\n\n## 安全性依恋\n\n没有安全依恋的人对真诚的赞美持怀疑态度，并倾向于对轻微的过失进行猛烈抨击。随着时间的推移，他们的伴侣往往会厌倦重复听到那些没有保证的承诺。通过这些自我实现的动力，对被拒绝的恐惧进而增加了被拒绝的机会，这反过来又强化了这个人不值得去爱的观点。\n\n他们发现了信任伴侣的能力 ——“ 相信他（她）会在我们脆弱的时候，以一种对我们的需要的方式来对待我们”，预示着随着时间的推移，逃避倾向会减少。芬克尔的例子得到了许多研究的支持，表明对于不安全的人来说，找到一个有安全依恋史的伴侣是一个不错的选择，但正如我们将看到的，这并不是他们唯一的补救办法。\n\n刺猬困境：与一段充满激情的恋情的起起落落相比，一段伙伴关系中更稳定、更可预测的节奏会带来特别的回报。一段历久弥坚的长期关系带来的好处包括情感上的安全感，以及被一个既了解你的优点也了解你的缺点的人接受所带来的可贵的舒适感。\n\n长期亲密的关系也有潜在的黑暗面。 有句经典的讽刺：“你总是伤害你所爱的人。”为什么会这样呢？回想一下我们之前对得失理论的讨论，一个相当令人惊讶的事实是，当一个人最初对我们的消极情绪逐渐变得积极时，我们会发现这种情况比那个人对我们的感觉一直都是完全积极更有价值。相反，当一个曾经积极评价我们的人慢慢地以消极的眼光来看待我们时，我们往往会发现，这比他（她）自始至终地表达对我们的负面情绪更有害。这一过程表明，一旦我们对长期伴侣的奖励行为有了一定的了解，作为奖励来源的那个人可能会变得不如陌生人那么重要。**这一过程表明，一旦我们对长期伴侣的奖励行为有了一定的了解，作为奖励来源的那个人可能会变得不如陌生人那么重要**。这种关系越紧密，过去那种长期的尊重和回报的历史越久远，他们的退缩就越具有毁灭性。事实上，长期的恋人更有能力造成损失，而不是提供额外的收益，从而伤害他（她）所爱的人。\n\n哈维（ O.J.Harvey ） 89 发现人们对陌生人的恭维反应比对朋友的恭维反应更积极，为什么会这样呢？来自陌生人的认可是一种收益，根据得失理论，它会让我们感觉更好。我们似乎总是在陌生人的眼中寻求帮助，而对我们最亲密的朋友和爱人的熟悉却使我们受到伤害或失望。正如罗马政治家西塞罗（ Cicero ）早在公元前 46 年所建议的，解决办法是将这些损失和伤害的感情转化为令人兴奋的收获和新的理解。那么，怎样才能做到呢？\n\n我们想要感觉到我们的伴侣真正地、深深地理解和接受我们；并且知道这一点的同时不用担心，如果他们“真的”了解了我们最深层、最卑鄙的缺点和错误，我们会被拒绝或抛弃。缺乏安全感的人很难找到这种平衡。那些自尊心低、对拒绝高度敏感、因而觉得自己不值得被爱的配偶也会这样。由于这些人害怕被拒绝，他们倾向于将自我保护置于自我表露之上；他们竖起了“刚毛”，因此失去了他们渴望拥有的那种温暖关系。我们对伴侣对我们的看法会影响到我们的反应：后退一步，保护自己的利益，还是承认自己的脆弱，寻求沟通？情侣们必须在两种选择之间作出选择，一种是走一条风险更大但更诚实的道路，加深与伴侣的关系，并带来许多新的情感收获；另一种是走一条保护自己免受进一步伤害的道路，但会增加进一步受损的可能性。在人际关系中，就像生活中的许多事情一样，风险越大，潜在回报就越多。\n\n在这个过程中，真实性 —— 与伴侣自由分享真实感受和看法（甚至是负面的）是避免陷入停滞的关键。它减少了一段关系最终陷于停滞的可能性，就像多汀夫妇所追求的那样。当人们压抑自己的烦恼，把自己的负面情绪和真实想法隐藏起来时，他们往往会陷入一个看似稳定和积极的脆弱平台，但这一平台可能会被情绪的突然反转所摧毁。\n\n**维持爱的一个重要因素是相信我们的伴侣理解和支持我们；他们信任我们，关心我们，和我们在一起会感到安全，知道什么对我们重要，并积极帮助我们满足需要，最为根本的是，对我们的内心了如指掌**。这使我们不仅能够爱对方，而且能够以一种方式感受到对方的爱，即使对方不在我们身边，我们也能与对方建立联系。这种被理解的基本感觉比实际的行为指标（如谁在家里做什么）可以更好地预测幸福感、安全感和舒适感\n\n在被需要和有压力的时候互相支持的人比不支持的人，更有可能建立起一种健康的关系。但是如果事情进展顺利呢？事实证明，对处于亲密关系中伴侣的幸福感的一个强有力的预测因素是，无论是困难还是成功的时候彼此都能守在对方身边。雪莱 · 盖博（ Shelley Gable ）和她的同事 96 发现，当人们描述最近的一次成功时，从他们的浪漫伴侣那里得到了积极的回应（“多么棒的消息啊！我知道你能做到！我们马上去庆祝吧！”）。几个月后，他们的关系比那些得到不太热情回应的人（“干得好，亲爱的。晚餐吃什么呢？”）更幸福。这是有道理的。在许多关系中，伴侣的成功会带来复杂的情感；这种喜悦可能带有一丝嫉妒。盖博的研究表明，当夫妻之间的快乐远远地掩盖了嫉妒时，他们才是最幸福的。\n\n随着一段关系朝着更亲密的方向发展，真实性对于持续的激情、承诺和成长变得越来越重要：即便不情愿，我们也会放弃努力给人留下好印象的能力，并开始揭示有关我们自身的诚实的关系。真实性意味着愿意在适当的情况下，以表露出我们关心的方式，向我们的朋友和所爱的人表达各种各样的感情。\n\n大多数人都会接受并对爱人的直言不讳做出反应。直言不讳，我指的是一个人在不指责、不抱怨、不评判或不嘲笑另一个人的情况下，清楚地表达出自己的感受和关切。直言不讳之所以有效，就是因为直言不讳能让接受者无偏见地倾听。","n":0.18}}},{"i":112,"$":{"0":{"v":"Past","n":1},"1":{"v":"# 聊天学到的\n\n- 分享情绪\n- 分享生活的点滴\n- 不要说太多\n- 感觉自己失败的原因就是除了lrq 我的付出比对方多，不是很平衡。\n- 说的太多 缺乏神秘感了\n- 对方如果不主动那我宁可放弃\n\n# lrq\n\n- 对方比较主动\n- 我一直被引领 被安排 被教导\n- 对于我来说是一个很习惯的方式，因为这是我和父亲的关系\n\n\n# lz\n\n- 一开始算是两情相悦的，一起出去玩也比较开心\n- 中间说没感觉让我伤心了很久\n- 其实主要原因是我逼得太紧了，让人想逃离，需求感太强了\n- 没有激情也是真的，我给的安全感太多了\n\n# wbw\n\n- 总体来说一直是我在找话题\n- 时间久了就形成了习惯\n- 毫无疑问wbw不是那种你对她好她就会一直和你在一起，她是想和自己喜欢的人在一起的类型\n\n# byl\n\n- 见面的时候情绪的表达更多一点，不要太冷漠\n- 多多关注女生的细节\n\n# SH\n\n- 给对方买礼物会让她更喜欢你\n- 表达真实的想法还是要注意程度和场合和时间\n- 如何发现不合适还是需要早点结束","n":0.177}}},{"i":113,"$":{"0":{"v":"My_point","n":1},"1":{"v":"\n# 我注意的点\n\n- 不强迫别人去做我想做的事\n- 接受对方的好意\n- 理解尊重对方的观点，不说“废话”, 不说脏话666\n- 感情中没有对错，我保留自己的想法就好\n- 对方想说自然会说\n- 注意细节\n\n# 我不想找的对象\n\n- 回避问题，拒绝沟通\n- 没有上进心\n- 不喜欢户外运动，旅游\n- 时间观念淡薄 \n- 太瘦\n- 不健康\n- 家庭差距大\n\n# 我的评价标准\n\n1. 你最看重她的一项品质是什么？（善良、诚实、 善解人意、 会照顾人等）\n\n聊得来\n\n善解人意, 聪明， 有上进心，对于事物充满好奇\n\n2. 为什么这项品质对你很重要？ （可以帮你判断她人格是否健全、 世界观是否正确）\n\n好相处，自己在相处的时候可以放松自己\n\n3. 列出那些你不能去容忍／忍受对方做的事情。（欺骗、 嫉妒、 颐指气使、无理取闹等）\n\n- 出轨\n- 不诚实\n- 忽略事实\n- 情绪化\n- 冷暴力 拒绝沟通\n- 不在乎我的感受\n\n4. 你能为她提供什么？ （时间、金钱、物质、感情支持、安全感等）\n\n- 成长\n- 陪伴\n- 安全感\n- 提高效率\n\n5. 你最喜欢做的事情或爱好是什么？ (你的爱好或癖好，运动、绘画、音乐、表演等)\n\n- 跑步\n- hiking\n- 写代码\n- 看书\n- 看动漫\n\n\n6. 你最欣赏自己的地方是？（自信、乐观、 运动健将、 烹饪高手、 工作才干等）\n\n- 自律\n- 时间管理\n- 上进心\n- 愿意尝试新鲜事物\n\n7. 你的缺点是什么？\n\n![[thinking.shortcoming]]\n\n8. 在恋爱关系中， 你认为最重要的东西有哪些？（对我来说是三个： 坦诚、 专一和尊重）\n\n- 专一\n- 良性沟通\n- 尊重\n\n\n9. 想找的对象\n\n- 聊得来  \n- 主动一点 E\n- 可以一起出去玩\n- 喜欢动漫\n- 可以理性的讨论问题 T\n- 聪明 ","n":0.115}}},{"i":114,"$":{"0":{"v":"Make_love","n":1},"1":{"v":"\n# 练习\n\n- 龟头按摩\n- 冠状沟按摩\n- 反手撸\n\n# 等级\n\n- level 0 疲软：前两个练习\n- level 2 半勃：反手撸\n- level 3 持续勃起：快感期\n- level 5：收缩pc肌，睾丸抬起，准备射\n- level 6：射\n\n练习找准level 3的感觉\n\n# 延时技巧\n\n- 先停留\n- 慢插 1s 1下\n- 切换频率\n- 拍打式，不是幅度大\n- 拔出一半，旋转式，可以慢，摩擦yd\n- 女上前后，把控幅度，不要上下\n- 注意力，注意对方的快感\n- 一拍吸气 7拍呼气\n- pc肌，1s推1s放，往外推\n","n":0.174}}},{"i":115,"$":{"0":{"v":"Live_together","n":1},"1":{"v":"\n1，买套，几盒几盒的买。 最好去正规店里，或者各大药店，尽量不要网上。不要体外，中招的不在少数。\n\n2，两个人租房子，不要住到对方家里去。\n\n3，做好因鸡毛蒜皮的事吵架的准备。\n\n4，明确规划好双方要做的家务问题。因为家务问题而分手吵架的也不在少数，不要以为仅仅是做饭，洗衣服等等，细节打败爱情。\n\n5，不要一起洗澡，因为，emmmm……不仅会啪啪啪，更是因为女生开很烫的水都不会觉得热，男生：哎呀妈呀你要烫死我！！！！\n\n6.同居也不要着急见父母，请再深入了解一下对方的人品，不管之前的缺点隐藏的再好，一再同居几个月，都会原形毕露，这个时候再看看，你是否真的可以接受对方的缺点。\n\n7，规定好双方最晚回家的时间。除非真的有其他急事。一来可以推掉不必要的应酬，二来也可以养成良好的习惯。\n\n8.如果争吵的非常激烈，不要轻易离家出走，也不要因为气愤砸家里的东西，这也是我需要改正的地方，我总是容易情绪上来，晚上离家出走，其实很不安全。最后对方也会疲惫。\n\n9，备一些常用药品在家里。比如拉肚子的，感冒的，发烧的等等。\n\n10，每天给对方一个小时的自由时间。打游戏也好，安静的看书也好。给对方一点空间，不要逼的太紧。\n\n11，不太建议钱放在一起，避免未来一旦没修成正果，引发一些不必要的争端。\n\n12，不要参与对方的家事。除非主动和你商量对策。\n","n":0.707}}},{"i":116,"$":{"0":{"v":"Investment","n":1},"1":{"v":"\n\n# 投资\n\n- 时间投资\n  - **偶尔找对方擅长的事帮忙，并且用正面回馈来强化**，让对方主动乐于为你做这些，而不是去提要求，也不是占便宜。\n- 情绪投资\n  - 爱情产生关键在于引起对方情绪波动。你可以先把对方捧到天上去，再通过调侃或忽冷忽热的方式让对方情绪下跌，再上再跌\n  - 你要不卑不亢，敢说敢作。**对于不满意的地方，该说就说，该怼就怼**。只是要注意语气和尺度，不要开那种有伤大雅的玩笑。\n- 物质投资\n  - 利用他之前在自己身上付出的资源\n  - 习惯成自然，利用惯性，让他习惯于为自己付出。\n\n- 引导投资的技巧一定要配合一个节奏。\n  - 你需要不断的保持一个微妙的节奏，有一个形象的比喻——驴前面的胡萝卜。要保持将要吃到但吃不到的状态，不要让对方吃死了。要保持一定的自我，太顺从，对方会觉得总能够轻易吃到“胡萝卜”，也就自然而言不想动了，会让他可能还喜欢你却也失去付出动力。\n  - 你既然要对方持续的为你付出，那么你就要长期的保持你的魅力和价值，甚至不断的换着法子吸引他，让对方长期愿意投资你。\n\n不要骚扰，也不要怕太麻烦对方。关系都是麻烦出来的。其实**让对方愿意和你接触有两个维度：一是能看到你本身的价值；二是和你接触他自己能获得价值感**。\n\n你之前可能就有些付出太多，这没有关系，你从现在开始，把重心从“付出”转移到“吸引”和“引导”上来。**你对他的好不是他的，你是有主导权的，随时可以收回。人都是怕失去的。**\n\n他对你不好，是你允许的；他对你好，是你可以引导的\n\n","n":0.224}}},{"i":117,"$":{"0":{"v":"Health","n":1},"1":{"v":"\n从生物力学的角度来看，有迹象表明，持续手淫的男性基本上是在宣传他们作为费洛蒙贝塔的地位，而女性的生化机制会下意识地登记他们的情况。睾丸激素较高的男性在性自信和气味方面都表现出他们的性能力。\n\n如果你长期缺乏睾丸激素，和/或受到催产素的镇静作用，你的性能力就处于不利地位。事实上，从进化的角度来看，我们野蛮的狩猎采集者开始时的Beta型男性会更容易将手淫作为一种性释放，因为从理论上讲，他们比Alpha型男性获得的繁殖机会少。\n\n对男人来说，手淫是一种变态行为。它意味着没有能力成为 \"足够的男人 \"去干一个真正的女人；打飞机对男人来说是失败的，但对女人来说是一种权力。\n\n手淫化解了这种冲动。它杀死了这种冲动，或者至少是升华了它。因此，有理由认为，一个以手淫为耻的全球社会惯例，对一个有兴趣扩展的社会来说是有益的吗？\n\n# sex\n\n一个健康的男性产生的睾丸激素是女性的12至17倍。女人想要和男人一样多的性生活，或者像男人一样频繁的性生活，这在生物学上是不可能的。相信当一个女人说：\"我不明白为什么性对男人如此重要 \"时，她说的是字面上的事实。没有一个女人会经历17倍于她自己的睾丸激素水平（除非有类固醇）。\n\n女性的性欲也是周期性的。即使在她的排卵周期的高峰期，当她处于最饥渴的时候，她也不会体验到男人一天24小时都在做的事情。这就是神话的根源，也是社会习俗的来源。\n\n性欲取决于雄性激素水平，而不是雌性激素水平。","n":0.447}}},{"i":118,"$":{"0":{"v":"Get_back","n":1},"1":{"v":"\n# 挽回\n\n当你穷追猛打时，你的需求感太强，降低了自身的价值。\n\n需要断联来改变两人的心理差距。\n\n- 切忌急躁、患得患失。\n- 不要被对方忽冷忽热，忽左忽右的态度和情绪干扰。你大可以把他当做重新恋爱的对象，这期间你们之间保持距离感，我认为暧昧是最合适的！\n- 不要在去想对方为什么这样那样，对方在想什么等等。\n- 不要给对方压力，不要纠缠对方\n\n## 心态\n\n1. 首先，挽回的过程中你要有坚定的信念，相信我是可以挽回的她（他）的，我们现在只是暂时分开而已，你要坚定的相信这个世界上没什么不可能的，我不是在做成功学培训，也不是销售培训，但是你必须有这样的心态\n2. 再次，千万不要有种我错了，都是我不好的这种心态，我建议你们强烈克服这样的心态。呵呵，你这样做就是在不停的给自己减分，最后直到减分到0，如果让对方感到我们相处的时候你不珍惜，现在分手了，你居然……那么这样的话，我很明确的告诉你，你没戏了，会让对方觉得你不值得挽留，如果在心态上和姿态上让对方高出一等，嗯，嗯，男女通用，那么你注定要失去这段感情！但是我只是让你们克服这样的心态，我是让你们的之间的感情建立在平等地位，每个人都有自己明显的缺点，或者脾气不够好，或者生活太邋遢，或者给予的关心和关注不够等等，这些是需要我们改正的，只要我们改正就好，而且做到真真正正的改变！\n3. 就是你要挽回的那个她（他）从心里上要做到，她（他）不是最好的，她（他）不是我的真命天女或者真命天子. 不要一定，放平心态\n4. 想清楚自己在这段关系的控制能力，应该是我设置的自己的期望\n5. 不要觉得对方比自己好，所以就低她一等，尽力去讨好她。\n\n## 冷处理\n\n如果对方想冷静，想要你不再纠缠，你此时的冷处理，正和对方的心意，冷处理的过程中，甚至还会出现对方很好奇你怎么样。\n\n冷处理的时间里，要简单梳理一下自己，积极的改变自己，提升自己，做一个新的自己。这段期间不妨和自己谈一场恋爱，摆脱一下烦恼，不去想“能不能挽回”、“再联系时如果拒绝我怎么办”等这样的想法。这段期间内，相信自己，提升自己才是正确的解决方式。\n\n【冷处理期间，对方忘了我怎么办】实际上这个问题问的很没有必要，为什么这么说，既然你决定要冷处理，一定是对方对你排斥、拒绝、冷漠，冷处理也是迫不得已而为之；如果此时你再继续联系、纠缠对方，我想换成是你也很烦躁！既然对方不想与你联系，对你的感情已经在变淡，你还问不联系对方会不会感情变淡这样的问题，是不是很没有意义？\n\n【冷处理需要多长时间】冷处理的时间里，可以消除对方对你的否定态度，对你的否定态度越小，就越容易改变对你的想法！这个时候你再以朋友身份介入，不唐突的顺其自然的交往，我相信，对方对你的排斥就不会那么强烈了，这就是一个好的开始~~\n\n有人说，我冷了一段时间，尝试联系对方还是拒绝我！嗯，这个没什么怎么办，我只能说太正常了，有些人冷了一段时间会态度缓和，而有的就不会。再次联系都是从进攻开始，那么你碰钉子很正常，对方还是以往的态度，证明你根本没有消除对方的顾虑，对方对你还是有不满意的地方！你的主动没效果，继续被动，暂时消失一下，看看对方是否能尝试找你？不要指望迅速的见效。\n\n这条规则很简单，简单得不用去过多解释。你必须记住：在分手发生后接下来的至少4个星期内，不要主动跟她联系，包括打电话、发微信、发短信等等。没有任何例外的情况可以破坏这条规则！你一定、必须成为那个不去主动联系她的人。切断联系这条规则是有心理学和生理学理论做基础的。\n\n千万要记住：无论发生任何事，也不管你有多担心、多沮丧、多想她，你都不能是那个首先去联系她的人！\n\n如果她主动联系，你不可以有下面这类行为：\n\n- 对她生气\n- 情绪沮丧或悲伤\n- 对她言语粗鲁\n- 炫耀或吹嘘。有些男人会去吹嘘在分手期间他跟多少女人睡过或者是约会过等等。（就算那是事实，她也不会相信你，只会让自己显得更可悲。）\n- 讨论以前的关系（争论当时谁对谁错等等）。\n- 暗示或直接问她是否已经跟其他男人约会过或者睡过。（问这类问题是极最蠢的，除了让自己更失落外，还能有什么其他帮助吗？）\n- 央求她再给你一次机会\n\n\n## 重塑自我\n\n心态改善是挽回过程中有利于你的行动方向，冷处理之后，双方保持交集情况下，再次接触，要让对方感受到你的与之前的不同和改变，如果对方认可你的改变，对方越认可越有利于挽回，当然挽回的时机当然是越早越好。\n\n一定要搞懂或者清楚他为什么和我分开？心里要做到明明白白，其实许多分开的理由都是借口，如果你连分开的理由都不清楚，或者错误的把对方的借口当做分手的真正理由，那么说明你们彼此不是真正的了解，也许这样的挽回是否有价值值得商榷。\n\n其实这就是你们之间平时情感需求不一致积累的结果，没有给予对方的情感需求导致对方分手，这种情况还分为很多种，有的人其实没有做错什么，只是性格原因而已，这种则不必去花时间自我反思做错了什么，而有的人需要考虑一下是不是在这段感情中过于以自己我为中心而忽略了对方情感，导致对方逃离。\n\n## 如何突破对方防御\n\n所以不是三言两语、轻而易举就能挽回的，你要正视分手的事实，不能还总想着曾经的过往，甜蜜，这样你越想越痛苦，心里越焦躁，越着急挽回，越拼命的想为对方付出一切，以祈求对方能和自己复合，这样的心态没错吧？那么结果只是你俩之间的距离越来越远。\n\n此时我认为你们俩人的状态，以朋友这个角度接触是最好不过，有的则两人可以继续联系，甚至对你的关心不是特别排斥和反感，这样的情况就好不少，此时你们之间保持着小小暧昧的关系再恰当不过了。\n\n但是接触中要顺其自然，千万不能提及感情，不要再把对方当成你的恋人，你在联系对方，其实你想做什么，大家心知肚明，何必又要刻意提出来呢？你不说对方也知道你是怎么想的，但是你一说出来挑明，可就不一样了，对方会本能的心理防御，一提到感情，对方一定会排斥你，对你的态度立马转变，而此时的你身处情感煎熬中，一定会被对方忽冷忽热的情绪左右，你此时也根本冷静不下来，患得患失！\n\n循序渐进，顺其自然！在双方的接触中以很自然的状态进行，不要突然对方回复你几个短信，你就突然要约对方吃饭，谈谈怎么怎么样，这样做只能前功尽弃，状况进一步恶化!\n\n## 吸引力缺失\n\n吸引力的直接衡量标准是从智力、受欢迎程度、和自我价值、三观等方面的多个标准体现的综合价值\n\n在一个恰当的时间出现。具体时间男女生不太一样、性格也会有不同反应，在对方后悔怀念你的时候出现最佳，有时候都不需要你做什么自然而然就和好了，不知道该怎么办的时候，先从朋友做起。这时候一定不能再作、再去逼别人，那就连最后的希望都没了，凡事要注意方法。\n\n情感疲倦：累觉不爱、\n\n- 解决方式：暂时没感觉了，其实这种只是没有新鲜感了，一直在重复一样的相处方式和生活内容，久而久之就会觉得腻了，这种情况下其实分手一段时间反而是好事，因为提分手的一方冷静下来之后容易后悔。可尝试用朋友的身份继续相处就行，照样吃饭聊天看电影，该干嘛干嘛，或者先不见面也行，但一定做好沟通，不然对方容易真的死心放弃了，等到两个人心情都恢复好了，负面情绪消除得差不多再恢复情侣关系。同时可以尝试做一些不同的事，或者给对方一些小惊喜，互相承诺一些以后相处模式，定期做些特别的事，感情就可以长期甜甜蜜蜜了。\n\n供需失衡\n\n- 两个人的关系核心需求是女生需要宠、男生需要理解。\n- 从根本原因上来说，分手的人都是因为情绪价值得不到满足，或者说没有得到自己付出没有得到想要的回报。不同类型的人不自由各种各样的需求，因为每个人在亲密关系中需要的东西是不一样的，这些都是由一个人从小到大的成长所决定的，不管自己能不能意识到，都很难改变。\n\n因为在成长的经历中，有一些需求没被满足，少了这样那样的体验，长大以后在亲密关系当中就会下意识的去寻找和满足自己内心深处的东西，那些投射到心灵深处的特质，就是人在亲密关系当中寻找的吸引点，这是人性使然。\n\n\n## 破冰聊天\n\n破冰聊天的内容\n\n- 从生活话题入手，不要谈感情。\n- 从自身角度或者ta身边的人和事切入，不要谈及当事人。\n- 多谈论积极的生活状态，令人愉快的话题，向前看，不要谈过去。\n\n①引导聊天法\n\n不要说“最近过的怎么样”“你还好吗”“有时间吗”……诸如此类的“不专业的”聊天话术，把自己整的和推销员一样。这种就是典型的“纠缠话语”。另外还包括“你为什么不回我”“不能做恋人难道不能做朋友吗”“我放不下你”这样的话，雷区，不要踩。\n\n不过引导聊天法需要你能充分调动对方的好奇心，如果你俩交流还正常，你可以发个有关联的朋友圈，比如你们一起养了一只猫（别的根据情况自己想），或者展示她知道你以前从来不会做的事情，引导评论。\n\n或者发一些生活上她擅长你不擅长的东西去问她，还是拿猫举例，“怎么给猫洗澡”“猫不吃饭怎么办”之类的，还有送妈妈礼物送什么，女生可以问电脑出故障了怎么办……（其它生活上的自己想）\n \n②“三三聊天法”\n\n何解？就是你联系她，不管她理不理你，你就联系她三次，每次隔三天，每次发三句话。点到为止，及时结束话题也不要让对方感到有压力，不要聊太多。\n\n可以真诚自然，装作不经意的表达你对她的习惯性思念。但是一定不要表现情绪波动，并且说完马上岔开话题，表示自己也不想再感情话题上停留，但可以给她造成一定的情绪波动，触动旧情。\n \n③新话题切入法\n\n你们恋爱的时候肯定关于家庭、情感经历、人生观世界观、兴趣爱好之类的都聊过了，以前说过的在没老师的监督指导下就不要说了，可能引起她对你的负面记忆。少谈过去。\n\n所谓新话题，就是曾经没有跟她说过的生活细节部分，或者分手后你一个人做了哪些事，学会了做什么菜，看了什么电影什么书，打算去哪儿旅游……反正要是新鲜的话题，能引起她兴趣，不听完睡不着觉（但是你不一定要说完哦，可以愉快结束，为下次聊天打下伏笔）\n\n","n":0.174}}},{"i":119,"$":{"0":{"v":"Faq","n":1},"1":{"v":"\n# FAQ\n\n这里记录一下我在亲密关系中的一些常态以及自己的分析\n\n## 老是在脑海中跟对方对话\n\n可以看出我在情感关系中处于焦虑依恋，所以当我得不到对方的回应后就会十分焦虑。\n\n因为缺乏了对方的反馈，于是我只能在大脑中和对方对话。这样的后果就是我会花很多时间在这个事情上，但是这样其实也是一种逃避，我应该直面对方去问这些问题。不过由于现实的限制，有些话并不能直白的表达出来。\n\n- 解决办法：把想说的写下来，想到什么就写什么, 至少以后就不会再想一遍\n- 和伴侣约定好合理的讨论时机\n\n## 经常check对方的社交网络\n\ncheck对方的社交网络是为了更好的了解对方，但是我在短时间会check太多次，完全没有必要.\n\n我之所以会这么做的原因还是**闲**吧。我把重心放在了对方身上，而不是自己身上。\n\n- 对方发的内容90%都不是和我相关的，我完全不需要那么关注。\n- 和我相关的我又看不到就当不存在。\n\n做好我自己\n\n## 反复上知乎或者Google看一些别人的经验或者没有科学依据的东西\n\n这么做还是因为我想找到一个解决方案，我还是潜意识把感情当做是解题。但是很多情况下，感情不是努力了就有结果，还是需要找一个合适的人在一起。\n\n没有科学依据是我想通过出生时间确定对方的性格，这我也知道是不合理的，但是却发现他们总是可以说对。也许只是把一些大家都有的特点总结起来的吧。\n\n- 把看过的总结好，知道的就不需要看了","n":0.302}}},{"i":120,"$":{"0":{"v":"Comfort","n":1},"1":{"v":"# 舒适感\n\n1. 讲话彼此能听懂\n2. 推进关系照顾对方情绪\n3. 约会相处自然无尴尬\n4. 恋爱彼此平等相互付出\n# 哄女友\n\n别哭（别怕），什么事儿都有我呢。（陪伴是最暖心的事情）\n \n没事，交给我就行，我来解决。（真的很酷！）\n\n你是最棒的+（你怎么可以这么优秀）（这件事你居然能想到这样做，好厉害）（你比她们都棒）+就是夸啊，使劲夸阿，夸到她心烦都没有理由。\n \n只要你表现得在乎而且不让她太烦。有主动去解决问题的意识而不只是一味地问她该怎么做。\n像个成熟男人一样担起责任来（是我让你不开心的，我要负责让你开心起来）\n一般女孩子很快就会好起来的。\n\n最好是能发现自己错了主动认错然后哄一哄。\n最好能给个大大的拥抱，死死抱住那种，然后带着去吃好吃的玩好玩的。\n最好能耐心谈一谈，一定要耐心。\n最不济的，把她放到一边不要管，这样也有可能自己消气的。但首先得认错。\n\n最重要的一点，让她明白，你是理解她的。\n\n第一，一定要顺着她的意思，辩解只会使事情变得越来越复杂。\n第二，如果这件事跟你有关，不要试图将事情表述清楚，目的、方式、经过……这些都不重要，重要的是你知道这一切都是你的错了。\n第三，如果这件事跟你无关，一定不要试图站在道德制高点来讨论这件事，一定要站在她的角度安慰她。\n第四，所有看起来很弱智的安慰方式都是可取的，所有看起来毫无道理的语言都可以用来哄她。不用担心没有解释和说明的机会，她度过了这段时期冷静下来会愿意听你之前没说的话的。\n\n请按如下操作步骤：\nA、暂时关闭你大脑里的理性和逻辑模块进程；\nB、与女友待在一起（做什么看人看事儿）；\nC、闲聊，反复强调她（你女友）是对的《- 循环 直到她开始敞开心扉；\nD、由少到多的身体接触；\nE、承诺她一件“女友一直想做或喜欢做的并且可以马上开始的事”；\nF、做这件事，直到她开心；\nG、重启你的大脑。\n\n![[life.communication.hard#安慰]]","n":0.302}}},{"i":121,"$":{"0":{"v":"Chat","n":1},"1":{"v":"\n[[两性|life.communication#两性]]\n\n# 聊天模型\n\n女生的回应\n\n## 积极\n\n- 讲自己的状态\n- 回复字数比较多\n- 主动聊天\n- 有情绪\n\n### 做法\n\n- 提问\n- 邀约\n  - 先模糊邀约\n  - 再具体\n- 要求\n- 调情\n\n\n## 普通\n\n- 平淡\n- 无话题\n- 无情绪\n- 废测，一致性测试\n\n### 废测的解决办法\n\n废物测试是确认你的价值，是一个展现价值的机会。\n\n核心就是不要解题，跳出女生的框架。\n\n- 情绪不要受影响\n- 不要产生对抗\n- 不要在乎结果\n- 荒谬性，往有趣的地方引导，夸张\n\n想象高价值的人会怎么回应。\n\n1. 直接回应，**不要解释**，转移话题\n2. 忽略问题\n3. 橡皮泥理论，接话，重新塑造，丢回去（荒谬）开玩笑\n\n\n## 消极\n\n- 敷衍\n- 已读不回\n\n\n### 怎么办\n\n因为没有看到价值\n\n1. 说话简短、及时止损\n2. 好奇心打开：创造聊天机会\n3. 朋友圈发动态，激发好奇心\n\n聊天可以让对方看到自己的价值，但不要自我赋格\n\n保持更新朋友圈\n\n# 核心指标\n\n- 价值\n- **性张力**\n  - 起伏\n- **购买欲**\n  - 客户购买的欲望\n  - 女生想得到你\n\n## 情绪原则\n\n聊天聊得是情绪，不是逻辑。当出现争吵，改变逻辑是没有用的。\n\n- 上策: 瞬间改变情绪，亲吻\n- 中策: 哄女友开心\n- 下策：讲道理\n\n而真正的应该是聊天要传递情绪，因为没有触达你的情绪，就没有触达到你，没有走进你的心里。所以，要感受对方的情绪，接收对方的情绪，并尽量去感同身受，这样会让对方有一种“你很懂我”的感觉，从而会在心里把你划入到“自己人阵营”。\n\n\n\n## 目的\n\n推进关系\n\n“愉快聊天”容易让女生产生一定的“亲密提升”和“情感依赖”，而对于大部分男生来说，“聊天”并不是“刚需”，也并不擅长。\n恋爱中的“男女差异”源自女生更注重“抽象情感”的感受，男生更注重实际交互、一起做事的体验\n\n## 制造氛围\n\n- 挑战\n  - 有点否定，表现自己的喜好，展现个性样本，不要平淡\n  - 会有废测\n- 曲解\n  - 发散思维\n  - 曲解对方的意图\n  - **想象女生的行为是为了得到我**\n\n\n\n## 展现价值\n\n表现性格样本和生活模式的一小部分，利用只言片语的力量，所以女生想要了解更多\n说一点点，营造神秘感\n\n## 角色扮演\n\n开玩笑，升级关系无风险\n\n假定两人去做什么事情\n\n## 被拒绝\n\n注意有拒绝阶梯，会形成惯性，所以需要有框架，下一次你有为我做一件事\n\n这次的拒绝成为下一次的邀约\n\n# 沟通\n\n大多数人都会接受并对爱人的直言不讳做出反应。直言不讳，我指的是一个人在不指责、不抱怨、不评判或不嘲笑另一个人的情况下，清楚地表达出自己的感受和关切。直言不讳之所以有效，就是因为直言不讳能让接受者无偏见地倾听。\n\n即时反馈的重要性\n\n为了能够在亲密关系中有效地进行沟通，我们必须就我们的言语和行为如何被理解给予并接受即时的反馈。这将为我们提供所需要的信息，以洞察我们的行动和表达的影响，并考虑我们满足自己和合作伙伴需求的选择。\n\n## 错误的方法\n\n人们往往不知道如何提供建设性的反馈，而是以一种激怒或惹恼接受者的方式来进行反馈，从而导致出现比他们需要解决的问题更多的问题。对于我们所有人来说，听到用感觉来表达的反馈（“我很难过。”）比听到用判断或指控来表达的反馈（“你是个轻佻的混蛋！”）更容易\n\n# 观察\n\n与众不同在于你观察女生的方式：所有的男人看脸看胸看腿看穿着，你看她聊天时候后仰的姿态。看着你微笑的眼睛，偶尔露出的小虎牙。\n\n之后是行为方式的认同：她等待你的样子，吃饭的样子，跟你出去玩的样子，坐在你旁边唱歌的样子，蹦迪的样子，渐渐从外到内，你认同她的越深入，深刻，女生会觉得你越懂她。\n\n再之后是对她生活方式的认同：她在做一份什么样的工作，为什么做这个工作，以及她之后想要干什么。她的兴趣、爱好、梦想，她做的每一件事，每一个举动每一个行为都有背后的逻辑，你需要挖掘出来，然后给与认同。每一个女生都有她活着的意义，找出来，如果她自己都不知道，你就帮她找出来。\n\n镜像式聊天。有时候我们不需要输出什么观点，只要顺着他的话题展开，并认同他说的话，让他有一种和你就像是在跟他自己聊天的感觉。那么，他的聊天体验就棒极了，而且会有一种你很懂他的感觉，从而赢得他的好感。\n\n# 注意\n\n1. 女生也有状态不佳、心情不好的时候，当遇到女生反馈不好或者态度冷淡的时候，找个台阶直接结束聊天就好了\n2. 聊天过程中话不要太多，交流还是跟女生互动为主，如果另一方如果成为了你倾听者，那么这段对话是你很失败的\n3. 你最主要的还是表达自己的诚意，表达自己对她的关切，多嘘寒问暖，恋爱时最忌讳清高孤傲，很闷很冷淡。\n4. 传递有用信息、发表观点，**先认可再提建议**\n5. 在跟女生聊天调情的时候，一样的，如果你逻辑了，就没有情绪流动，你逻辑了，就没办法打开她的情感开关，没有情感开关，哪里来的我们常说的感觉呢\n\n# 自我披露 \n\n自我披露法则\n\n  互惠还与沟通的开放程度相关。向对方披露较多个人信息的人，很可能获得类似程度的个人信息回报。如果正在沟通的双方存在共同利益，这种现象会更明显\n\n自我披露能增进吸引力。对于披露自己的弱点、内心想法和自身事实的其他人，人们会有亲近感。如果披露基于感情而非事实，这种亲近感就会更强烈。其部分原因在于披露的强度，这种强度会对披露者的好感度产生积极影响。\n\n过于笼统的披露会削弱开放感，从而降低亲近感和好感度。过于私密的披露往往会凸显一个人的性格和人格瑕疵，从而降低别人对他的好感度。在一种关系中过早地披露私密的人，往往会被视为不可靠，从而进一步降低别人对他的好感度。因此，当你遇到某人时，如果想把他当作长期朋友或者伴侣，就应该多加小心，不要在关系初期披露你最私密的方面。\n\n  自我披露过程包括两个步骤：第一步，必须进行既不过于笼统，又不过于私密的自我披露。第二步，自我披露必须获得同情、关怀和尊重。对一个坦率的自我披露做出负面回应，会令关系立即终止。\n","n":0.11}}},{"i":122,"$":{"0":{"v":"Topic","n":1},"1":{"v":"\n[[Understand|life.love.understand]]\n\n\n# 一开始\n\n多聊她\n\n- 外貌\n  - 化妆\n  - 身高\n  - 服装\n- 文字\n- 行为\n- 兴趣爱好\n\n\n## 前提\n\n我们的交流是男女交流的前提\n\n- 不要聊无关紧要的话题\n- 女生会觉得聊天就是浪费时间\n\n几种交流方法贯彻前提\n\n- 赞美：我对你感兴趣  [[Appreciation|life.communication.appreciation]]\n- 夸大的赞美：夸张化 搞笑 土味情话\n- 推拉：赞美+说不喜欢的点\n  - 会挑战女人，容易收到废测\n\n\n\n\n# question\n\n1. 我哪一点最吸引你？\n2. 描述一下我的味道。\n3. 对我的第一印象是什么样的？\n4. 你第一次吻我之前在想些什么？\n5. 我第一次把你约出来的时候你考虑过拒绝我吗？\n6. 初恋时你多大？\n7. 我做过的哪件事很让你生气？\n8. 告诉我，你是何时发觉爱上我的？\n9. 最想去哪个地方旅行？\n10. 将来想生活在哪个城市？\n11. 我使你难堪过吗？\n12. 如果你能够改变我的一个方面，那会是什么呢？\n13. 如果你打算问我一个问题，你会问什么？\n14. 你是如何察觉我在生气的？\n15. 你觉得我能够伤害你最深的一件事会是什么？\n16. 我做的哪道菜你已经吃厌了？\n17. 如果我想在餐桌上给你一个惊喜，你希望是哪道菜呢？\n18. 你想要的完美爱情是什么样的？\n19. 的有想过你30岁之后的人生会是什么样子么？\n20. 将来你想把你的房子装修成欧式田园风还是极简风？\n\n1. 喜欢什么运动\n2. 喜欢什么花\n3. 喜欢什么食物\n4. 喜欢什么穿衣风格\n5. 喜欢看什么书，最喜欢的作者是谁\n6. 喜欢什么电影/音乐  \n7. 平时一个人的时候，喜欢干什么\n8. 一般有什么心事  \n9. 星座话题（如果不信，就不要聊）\n10. 喜欢什么游戏\n\n1. 你喜欢什么样的工作环境？\n2. 工作上有什么新鲜事情？\n3. 老板人怎么样？\n4. 是否对自己的工作满意？\n5. 压力大不大？\n6. 下班之后一般喜欢吃什么？\n7. 自己做饭？\n8. 平常去哪儿玩？\n9. 你喜欢看什么电影？\n10. 最想去哪个城市工作？\n\n1. 你认为是性还是感情维持着一段完美的恋情？\n2. 如果你的朋友偷腥，你会让他的伴侣知道吗？\n3. 描述一下你心中完美的约会。\n4. 什么会让你挥剑斩情丝？\n5. 你认为在恋爱中谁会占主导地位，为什么？\n6. 一个人不在家，另一个人独自在家，你会怎么想？\n7. 你认为男人的爱与女人的爱是不同的吗？\n8. 作为女性，你认为男性最有必要知道的是什么？\n9. 你对彼此忠诚的定义是什么？\n10. 给爱情下个定义。\n\n11. 你相信一见钟情吗？\n12. 浪漫的度假作为你生活方式的一部分，你有何感受？\n13. 一个男生最吸引你的部位是哪里？\n14. 你会因为一个什么样的小细节而对一个男人动心？\n15. 你有想过将来会有几个孩子吗？\n16. 想要养什么样的宠物？养几只？\n17. 如果让你重新选择，你想做男生还是女生？\n18. 喜欢独处么？\n19. 你愿意信任我么？\n20. 在什么样的情况下，你会放弃原则？\n\n1. 你认为钱最重要的功能是？\n2. 你是如何学到作为女性所应具备的品质的？\n3. 你心中完美的婚礼是什么样子的？\n4. 如果金钱不再是目标，你最大的追求会是什么？\n5. 如果你中了彩票，会去做什么呢？\n6. 你认为谎言有度吗？\n7.你父母对你做过性启蒙吗？或者你自学的？\n8. 你对自己未来三年五年的规划（或者可以一起规划一下你们的未来）\n9. 可以告诉我支持你的信念是什么吗？\n10. 你最欣赏谁？为什么？\n11. 当你陷入困境时会向谁请教？\n12. 你是如何压住怒火的？它造成过麻烦吗？\n13. 如果你打算写本书，你会写些什么呢？\n14. 如果可能，你最想住在哪儿？为什么？\n15. 如果你中了彩票，还会继续上班吗？\n16. 当你对某人有偏见时，你是怎么想的？\n17. 你最好的朋友是谁？为什么？\n18. 你是如何选择现在这项事业的？\n19. 现实一点的说，什么事情会让你快乐一整天？\n20. 你做过的最无私的是哪件事？\n21. 你相信世上有鬼吗？\n22. 你今后12个月中的目标是什么？打算如何实现？\n23. 你对自己的受教育程度满意吗？\n24. 你曾犯下的最大的错误是什么？它是如何改变你人生的？\n25. 如果你捡到一个钱包，你会怎么做？\n26. 最近读了哪本书？阅读它主要的原因是什么？\n27. 当你感到沮丧时，你会做些什么，行为会因此有何不同？你又是如何克服沮丧的呢？\n28. 是否实现过年初制定的目标？\n29. 希望改变自己的什么？\n30. 你家最大的“公开的秘密”是？\n31. 你认为动物有灵魂吗？\n32. 不涉及职业和婚姻的状况，描述一下你自己。\n33. 你人生中最重要的事是？\n34. 最让你感到羞耻的事是什么？为什么？\n35. 你生命中最早的记忆是什么？\n36. 你养大过宠物吗？最爱哪一只？\n37. 你最害怕什么？\n38. 如果你得独自为自己的生活负责，不能指望任何人，你的生活会发生哪些变化？\n39. 你最希望我向你坦白什么？\n40. 你认为何时该保守秘密？为什么？","n":0.089}}},{"i":123,"$":{"0":{"v":"Breakup","n":1},"1":{"v":"\n\n# 分手的理由\n\n- 需求没有满足\n  - Not spending enough time together\n    - Always being late\n    - Workaholic\n    - Always putting your friends first\n  - Bad Communication\n    - Not Listening\n    - Not showing interest in the conversation\n    - Not looking her in the eyes\n    - Not being interested in her life\n    - Not being able to compromise\n  - Financially unstable\n    - Not being ambitious \n    - Financially depending on her\n  - Being Unattractive\n    - Being too moody\n    - **Being an addict**\n    - **Not taking care of yourself**\n    - Bad smell\n    - Repeating old mistakes\n    - Too much bragging\n    - Not knowing how be attractive\n  - **bad sex**\n  - being unfaithful\n    - 隐藏事情\n    - 欺骗\n    - 出轨\n  - 不支持\n    - 不支持对方做的事情\n    - 不帮忙家务\n    - 期待对方做自己不想做的事情\n  - no emotion\n    - 变得无聊\n    - 没有约会\n    - 不一起笑\n    - 不感激对方有趣的一面\n    - 不对对方有激情\n    - 没有惊喜\n    - 不陪伴\n  - 不感激\n    - 忘记对方的愿望\n    - 把对方当做小孩\n    - 没有表扬\n    - 没有未来计划\n    - 没有礼物\n    - 没有郑重对待感情\n\n- 感觉自己的界限被侵犯\n  - pressure her to have sex\n  - 没有安全感\n    - 总是责怪对方\n    - 批评对方多\n    - 不道歉\n  - Abuse\n    - 限制对方\n    - 控制对方\n    - 让对方觉得自己没有价值\n    - 否定对方\n    - 拿别人比较对方\n    - 催促对方做出承诺\n  - 不尊重对方家庭\n- 对对方太好了 （没有界限感）\n  - 爱没有错，但强迫对方接受的爱，就是一种变相是控制欲，不能给对方你以为的舒适的港湾。\n  - 做所有的事情也不期待回复\n  - 不是一个挑战\n  - 没有自己的观点\n  - 可以被预见\n  - 害怕和对方争吵\n  - 让对方不尊重自己\n  - 为对方放弃一切\n\n# 走出失恋\n\n- 切断投资\n- 重新建立起新的生活。\n- 关注自己。喜欢做什么就去做","n":0.07}}},{"i":124,"$":{"0":{"v":"Basic","n":1},"1":{"v":"\n# Basic\n\n提供支持、陪伴和爱的关系有益于健康，不管是在压力状态下还是在欢乐岁月里。 相比之下，孤独并不会产生更多的压力事件，但它是压力源转化为疾病的一个危险因素。事实上，单身生活有其自身的社会和身体优势：与已婚或同居的人相比，单身者更有可能与朋友外出吃饭、去锻炼身体、去上艺术和音乐课、去听讲座、去做志愿者工作。 你不必拘泥于保持忠诚的关系。换句话说，你所需要的仅仅是保持联系。\n\n## 爱的博弈\n\n两性的基础是吸引。\n\n吸引的本质是你可以提供的价值：\n\n- 外在价值：外貌和资本，是在认识对方，建立关系上重要\n- 内在价值：情绪价值，让对方的感受，在维护关系上十分重要\n\n当两人在提供的价值不对等就会失去平衡，付出少的一方对于感情的权力更大\n\n\n## 框架理论\n\n有自己的原则！和坚持的事情。知道自己的偏好\n\n你越愿意牺牲越不在乎自己内心真实的需求和想法，但你是有血有肉的人，要学会发脾气。你的没有框架原则底线只会“宠坏”对方，并让ta觉得不值得珍惜。\n\n\n## 原则\n\n* I love you as who you are. \n* 真正的了解对方，让对方成为更好的自己很重要。\n* 在两性关系中，谁越不在乎，谁就拥有这段关系的主导权\n* focus on myself anytime\n  * set boundary and standard\n  * gain control back\n* 不是付出就有回报的\n* say what you want!\n  * confident\n  * 坚定自己\n  * **set anchor for woman**\n* have goals and put yourself first,不要太available\n  * put her to your life style 不是把我放在她的生活中\n* not always **seek approval, 有自己的观点**\n* challenge yourself **face your fears**\n* slow down, 不要show too much love\n* in sex, focus on her needs\n\n## 感觉\n\n感觉就是调动情绪，推拉的关键。可以通过细节去影响，注意将对方的情绪放大。\n\n情绪高涨点时，升级关系，可以有肢体接触\n\n## 追求\n\n- 告白大多数会问为什么喜欢，讲其特别的点，利用细节，独一无二，描绘画面\n- 留心对方自己都没注意的需求，给惊喜。\n\n## 男女关系平衡理论 \n\n男女关系中，总有一个是处于低位的，另一个处于高位。 所有的男女关系，两个人的关系是不可能平衡的。 不同的关系，只是这种低位和高位的悬殊程度不同罢了。\n\n男女关系中，低位者总是迁就高位者。高位者有什么需要，低位者总会想办法满足他的要求，低位者总是想博得高位者的欢心，让他满意。 \n低位者比高位者更需要对方。\n\n从投资学角度来讲，低位者在恋爱中的投资比高位者多很多。可以说，低位者是以一种仰视的角度来看高位者的。高位者对低位者具有吸引力。这也就迫使低位者不断投资，去讨好高位者。在恋爱关系中，谁投资多，谁就先输了。 \n\n所以在男女关系中，是高位者在主导这段关系。 \n\n## 友谊公式\n\n友谊 = 趋近度 + 频率 + 持续时间 + 强度\n\n趋近度是你和他人之间的距离，也是你和他人接触的时间长短\n\n趋近度发挥作用的关键是目标必须处于一个没有威胁的环境。如果一个人感受到其他人的迫近威胁，就会“举起盾牌”采取回避行为，试图摆脱他人\n\n频率是你和他人在一定时间内接触的次数，持续时间是指你和他人接触的时长\n\n强度是指通过采取语言和非语言行为满足他人心理和/或生理需求的程度\n# 了解自己\n\n首先对你自己要有充分的认识，知道自己要什么想要做什么，想要成为一个什么样的人。","n":0.099}}},{"i":125,"$":{"0":{"v":"Value","n":1},"1":{"v":"\n# 价值\n\n情绪价值就是，彼此放松，哈哈大笑的开玩笑，娱乐。\n分为两个部分，第一是感受情绪，第二是带领情绪 （积极）。\n\n## 判断价值\n\n1. 女生的反应\n2. 自我赋格行为\n   1. 赋予自己资格\n   2. 低价值认同高价值\n   3. 解释 ”越优秀的人越不需要解释自己”，解释太多只会让事情变糟糕\n   4. 证明\n   5. 迎合\n\n## 损失自己价值的行为\n\n\n- 投资性行为\n  - 不断提问\n    - 你在干嘛\n    - 做什么工作\n  - 邀约女生\n  - 提要求\n    - 为什么不回消息\n- 低价值行为\n  - 表达自己的状态\n  - 如果女生对我不感兴趣，说这个也没有意义\n\n\n问就是在向别人索取信息，索取价值！回答，则是在给别人信息和价值。\n\n高情商的人会主动帮助别人，给予价值和主动付出，来增加别人对自己的好感度，别人了解自己越多，自己就越受追捧！\n\n# Hypergamy\n\n一个女人寻求比自己地位更高的男人来结婚。没有什么比这更重要的了","n":0.164}}},{"i":126,"$":{"0":{"v":"Iron_rules","n":1},"1":{"v":"\nIron Rule of Tomassi #1\n\nFrame is everything. Always be aware of the subconscious balance of whose frame in which you are operating. Always control the Frame, but resist giving the impression that you are.\n\nIron Rule of Tomassi # 2\n\nNEVER, under pain of death, honestly or dishonestly reveal the number of women you’ve slept with or explain any detail of your sexual experiences with them to a current lover.\n\nIron Rule of Tomassi #3\n\nAny woman who makes you wait for sex, or by her actions implies she is making you wait for sex; the sex is NEVER worth the wait.\n\n性是永远不值得等待的。\n\n性爱是双方自发的化学反应，而不是一个谈判的过程。\n舒适感来自于熟悉感和可预测性；这些都是明显的反诱惑的影响因素。虽然在人际关系中，舒适有它自己的优点，但它不是真正的、热情的性欲的基础。\n\nIron Rule of Tomassi #4\n\nNEVER under any circumstance live with a woman you aren’t married to or are not planning to marry in within 6 months.\n\nIron Rule of Tomassi #5\n\nNEVER allow a woman to be in control of the birth.\n\nIron Rule of Tomassi #6\n\nWomen are utterly incapable of loving a man in the way that a man expects to be loved.\n\nIn its simplicity this speaks volumes about the condition of Men. It accurately expresses a pervasive nihilism that Men must either confront and accept, or be driven insane in denial for the rest of their lives when they fail to come to terms with the disillusionment.\n\nWomen are incapable of loving men in a way that a man idealizes is possible, in a way he thinks she should be capable of.\n\n关于男人是否能确定女人什么时候不爱他的原始问题，比她所意识到的要深得多。我认为男人在服用蓝色药丸的日子里所经历的很多事情--沮丧、愤怒、否认、被剥夺，感觉他被卖给了一个幻想，而没有一个女人能做到这一点--所有这些都植根于一个基本信念，即某个女人，任何女人，在那里知道他需要如何被爱，他所要做的就是找到她，并体现出他被告知她会在他找到时对他的期望。所以他找到了一个女人，她说并向他表明她爱他，但不是以他脑海中一直以来的方式。她的爱是基于亢奋的资格和表现，而且比他被引导去相信，或说服自己，他们之间的爱应该是有条件的。她的爱似乎是两面派的，模棱两可的，而且与他长久以来被教导的，当他找到一个女人时，她会如何爱他相比，似乎太容易失去。因此，他花了他一夫一妻制的努力来 \"建立他们的关系\"，使她按照他的概念来爱他，但这从未发生。这是一场无休止的追逐，维持她的感情，遵从她的爱情观，同时偶尔努力吸引她进入他的爱情观。不断地安抚她以维持她的爱，与他希望被爱的需求感相冲突，这是一个超常的灾难配方，所以当她失去对他的爱时，他根本不知道她不再爱他。然后他的逻辑反应是重拾他们刚在一起时她对他的爱的旧条件，但现在这些都不起作用，因为它们是基于义务，而不是真正的欲望。爱，就像欲望一样，是不能谈判的。\n\n爱，就像欲望一样，只有在不被胁迫和没有义务的情况下才是合法的。男人相信为爱而爱，女人则是机会主义的爱。这并不是说两者都认同无条件的爱，而是两个性别对爱的条件不同。\n\nIron Rule of Tomassi #7\n\nIt is always time and effort better spent developing new, fresh, prospective women than it will ever be in attempting to reconstruct a failed relationship. Never root through the trash once the garbage has been dragged to the curb. You get messy, your neighbors see you do it, and what you thought was worth digging for is never as valuable as you thought it was.\n\nIron Rule of Tomassi #8\n\nAlways let a woman figure out why she wont ƒuck you, never do it for her.\n\nAn integral part of maintaining the feminine imperative as the societal imperative involves keeping women as the primary sexual selectors. As I’ve detailed in many prior comments and posts, this means that a woman’s sexual strategy necessitates that she be in as optimized a condition as her capacity (attractiveness) allows for her to choose from the best males available to satisfy that strategy.\n\nIron Rule of Tomassi #9\n\nNever Self-Deprecate under any circumstance. This is a Kiss of Death that you self-initiate and is the antithesis of the Prize Mentality. Once you’ve accepted yourself and presented yourself as a “complete douche” there’s no going back to confidence with a woman. Never appeal to a woman’s sympathies. Her sympathies are given by her own volition, never when they are begged for — women despise the obligation of sympathy. Nothing kills arousal like pity. Even if you don’t seriously consider yourself pathetic, it never serves your best interest to paint yourself as pathetic. Self-Depreciation is a misguided tool for the AFC, and not something that would even occur to an Alpha.\n","n":0.045}}},{"i":127,"$":{"0":{"v":"Framework","n":1},"1":{"v":"\n\n# 自己的框架\n\n1. 自信有担当为自己做的事情负责\n2. 守时\n3. 持续自我提升\n4. 我可以拥有对我好，可以一起玩，善良，聪明，努力，聊得来的女人\n5. 我喜欢不舒适感，这样意味着成长\n\n\n# 框架的强弱\n\n- 只考虑自己：强框架 -> 吸引力\n- 考虑对方：弱框架 -> 可得性\n\n![](/assets/images/2021-10-02-21-08-05.png)\n\n可得性太高就没有吸引了\n\n## 吵架\n\n- 吵架时是强框架\n- 之后哄对方就是弱框架\n- 这样有利于关系\n\n## 雷区\n\n1. 情绪失控：框架就丢失了\n   1. 动手打人\n   2. 骂人\n   3. 损坏物品\n   4. 威胁对方\n2. 暴露需求感\n   1. 强行亲密接触\n   2. 是降低自己吸引力的\n3. 矛盾扩大化\n\n# how\n\n将外在附着的东西全部剥离\n仅在两个对等的人格上，进行平等的交往\n\n1. 自尊自爱\n2. 照顾对方\n3. 认真聆听\n4. 反馈感受","n":0.16}}},{"i":128,"$":{"0":{"v":"Bad_signal","n":1},"1":{"v":"\n\n# 危险的信号\n\n1. 亲密关系性质低\n2. 在一次的时候不关注我\n3. 聊天情绪变少，变得理智，没有情绪波动","n":0.447}}},{"i":129,"$":{"0":{"v":"Bad_move","n":1},"1":{"v":"\n\n# 亲密关系末日四骑士\n\n## 批评\n\n## 鄙视\n\n## 辩护\n\n说服的本质是在制造对错\n\n可你要先学会区分解释和辩护。解释，相对客观一些，有些问题也一定要沟通开，比如一些原则性问题（出轨、背叛、涉及钱的问题、对你人品的误解等）\n\n事情大小没有客观标准，**核心就是是否有利于维系关系，是否是关心对方**，让彼此心里舒服，\n\n证明第一步就是承认自己的不足。证明自己最好的工具，就是时间。\n\n## 冷战\n\n冷暴力主要是因为无法面对沟通的挫败感和无力感。\n\n如何与喜欢冷暴力的人相处的方法了——讲道理。 他冷的时候你也冷，但是不能和他一样，你要表达你为什么也不想理他（原因）以及要怎样你才会理他（需求），去讲道理，不发脾气和作闹。\n\n他愿意表达一点，哪怕是不满，你也要知道对他来说很难得，你要能迅速接上。尤其是当他表现出“消极沟通”或者想要放弃沟通的时候，一定要坚持沟通下去，坚持讲道理。无论自己心里对他说的屁屁话再窝火，也要找到合理之处，自我反思，表现出对他的认可理解，再反过来让他也要理解你。“正向反馈”，他愿意沟通或者对你好的时候你给予更加积极、热情、贴心的回应才是正确的方法。他的冷淡伤害到你的时候你也让他gun。\n\n**对方一次次选择冷暴力而不是沟通，一般都源于你给他的“负反馈”，即他对你态度好或者尝试道歉、沟通的时候你不领情；而对你态度冷淡的时候你反而贴上去跪舔示好。**\n\n","n":0.378}}},{"i":130,"$":{"0":{"v":"Attraction","n":1},"1":{"v":"\n# 吸引力\n\n影响吸引力的因素主要有：成本、价值和共振\n\n- 成本：即对方和你在一起是否费力。正因为彼此触手可及，所以才能相处起来毫不费力。挽回还有一个关键就是：和你相处起来不费力，不心烦。\n- 价值：不喜欢的人和事物反复出现在我们面前时，也可能提高你对ta的厌恶程度。所以我们往往建议你断联，或者至少一定不要持续不断地出现在对方面前、信息轰炸。刚分手时，对方还处于对你的情绪否定期，你的死缠烂打反复出现在对方面前，只会加深对方对你的厌恶。这些行为都是在降低你的吸引力和价值，让对方觉得离开你是正确的选择，你对ta真的毫无吸引力了。\n  - 吸引力价值中的关键是你能给对方带去情绪价值，让对方觉得你的存在是美好的，和你在一起比一个人过或者比别人在一起更开心幸福。\n    - 1.情绪处理能力\n    - 2.沟通能力\n    - 3.共情能力\n- 共振：在人际关系中，人们倾向于喜欢那些与ta相似的人：价值观、态度、兴趣、背景等等。每多一个相似的地方都可能提高那个人对你的好感度。\n\n很多人已经懂了建设吸引力的方法，能引起对方的关注，但是聊天依然找不到话题，感情没有办法进一步升温或者长期持续的吸引力。\n\n这就需要去寻找更多的相似性，创造更多的交集和共同话题。想象自己成为ta才能懂得ta。理解比吸引更加难得和重要。吸引力只是开关而已。\n\n理想男性（适合约会或者恋爱的伴侣）通常是那些**自信、坚定、随和、心思细腻、没有攻击性的男性**，而不是严苛、控制欲强、过于安静、害羞和顺从的男性。换句话说，女性更喜欢一个有声望的男性而不是控制欲强的男性；\n\n## 不吸引人的点\n\n- 嫉妒 \n  - 它就像是在对女人说：“我感觉到了来自其他男人的威胁和压力，在内心深处，我觉得配不上你”\n  - 如何应对这样的状况呢？其实你只需要拥有这样的心态就够了：“如果把其他男人跟我放到一起比较，我会比他们更优秀！”你可以更开放一些，让女友去跟任何她想要交流的男人讲话或正常交往。\n- 控制欲\n  - 一个有控制欲的男人，在他的内心深处也同样觉得自己是配不上对方的。所以他才认为要想办法控制住她，让她继续留在他的身边。\n  - 同理，你越想把她抓紧，她就越想摆脱你的掌控。这也是人类的本能反应：我们都会去反抗那些试图控制我们的人。\n- 过于放低自己的位置\n  - 女人需要一个能够为她提供生存价值，并且拥有自尊的男人。一旦你将她摆到一个极高的或比你高很多的位置，并且开始将她的需要置于你的需要之上时，她可能就不再对你感兴趣了。她也不会再尊重你，因为她知道，你已经不能没有她。换句话说，她已经完全吃定你了，她想留就留，想走就走，不会有太多的心理压力。\n  - 我见过太多这样的男人，他们通常会这样做：喜欢女友喜欢的东西，做女友喜欢做的事情，把女友作为自己生活的中心。他们把女友放到一个极高的位置，首先去满足她的需求，然后才会去考虑自己。这样做是不对的。疼爱女友没错，但是你不能无条件的为她做所有的事情。\n- 寻求认可/肯定\n  - 如果什么事情都要向女朋友寻求肯定，同样也是一种没有安全感的行为，这种行为透露了这个男人缺乏自尊和自信。\n- 粘人\n  - 老是花时间跟女友腻在一起并不见得是件好事。我们都明白一个道理：钻石值钱是因为它的稀有性。如果你在家门口就可以捡到一块钻石，那它就没那么值钱了。\n\n## 吸引人的点\n\n- 领导力\n  - 领导女人或带领女人。\n  - 在决定做任何事情前，你的脑海里面需要有一个大致的计划，它不需要那么详细，你可以在执行中根据情况做调整。\n- 自信心\n  - “坏男人”常常会让许多女人迷恋，为什么会这样，我想了很久。直到有一天我才想明白：是他们的自信吸引了女人。坏男人之所以能够吸引女人，不是因为他们那些坏的行为，而是因为他们随时流露的毫无逻辑可言的自信。\n  - 但你千万不要把傲慢自大与自信混淆了。傲慢自大是一种伪装出来的自信，很容易被人识破。女人（尤其是美女）天生有一种特殊能力，她甚至不用跟你说话，只是通过观察和潜沟通，就可以轻易看出你是否真的自信。\n  - 女人不需要一个跟班，整天跟在她的屁股后面去做讨好她的事情。你应该拥有自己的想法和独立的价值观，而太多的男人对此都缺乏基本的认知。他们认为：如果什么事情都答应女人、无条件无下限的对女人好，女朋友就会更爱他们。\n- 上进心\n  - 一个有追求和有目标的男人具有难以想象的强大吸引力\n  - 事实已经很清楚：一个被碌碌无为的生活所拖累、没有激情和目标的人是没有任何吸引力的。更糟糕的是，他还把女朋友当成了自己的生活目标（像大多数人一样，或许你也曾经经历过，也包括我在内）。一旦发生这样的事情，分手就已经不远了，因为女人不想要一个没有上进心的男人。\n  - 不可预测，我是一个稀缺的资源\n  - 回消息的频率和质量和对方相同 https://www.youtube.com/watch?v=UYLuOt29OVQ\n\n\n# 为什么人会喜欢\n\n卡内基的建议非常简单：如果你想让人们喜欢你，就要和蔼可亲，假装你喜欢他们，假装对他们感兴趣的事情感兴趣，给他们以赞扬，要表示赞同，不要试图批评，而且要确保尽可能多地使用他们的名字，因为“普通人对自己的名字比对世界上所有其他名字更感兴趣”。换句话说，卡内基确信我们大多数人都像虚构的弗兰克 · 巴特勒；如果你想赢得我们的爱或影响我们，那么尽你所能让我们感觉良好，避免做一些让我们感到不舒服的事情。\n\n我们更喜欢具有令人愉快特征的人； 我们更喜欢同意我们意见的人，而不是不同意我们的人；我们更喜欢那些喜欢我们的人，而不是那些不喜欢我们的人；我们更多喜欢与我们合作的人，而不是与我们竞争的人；与那些批评我们的人相比，我们更喜欢那些赞美我们的人。吸引力的这些方面可以归纳为一个笼统的概括：**我们喜欢那些以最低成本为我们提供最大回报的人**。\n\n吸引力部分地取决于我们对替代品的比较水平。\n\n对我们选择朋友和爱人有深远影响的五个相对稳定的因素: 我们倾向于喜欢生活在离我们较近地方的人；我们喜欢与我们相似的人；我们喜欢那些喜欢我们的人；我们喜欢具有吸引力的人；选择的悖论\n\n## 距离接近\n\n你之所以发现某个人有吸引力并且萌生对他进行了解的可能性，往往是从他与你的生活距离开始的。近在咫尺增加了吸引力，原因却不仅仅是便利和实用。距离越近，我们就越有可能反复接触；而且，在所有其他条件相同的情况下，人们彼此之间越是熟悉就会变得越发可爱和越有吸引力。\n\n## 相似性\n\n在你看来，一个人在态度、观点和兴趣上越相似，你越喜欢他。与自己在上述方面对立的人可能也会吸引人，但最终不会走到一起。\n\n为什么感知到的相似性使人更具吸引力？至少有两个主要原因。第一，对我们大多数人来说，在重大问题上分享我们态度和观点的人都是非常聪明和体贴的，与聪明和体贴的人相处总是有益和有趣的。他们当然具有吸引力，因为他们赞同我们！第二，他们为我们的信仰提供了社会验证；也就是说，他们满足了我们感觉正确的愿望。如果我们感知到与另一个人的相似性，这就足以增强他的吸引力。\n\n## 个人特征：能力\n\n很明显，一个人越有能力，我们就会越喜欢他。所谓“能力”，指的是一系列的品质：聪明、做事的能力、明智的决定等等。\n\n被认为最有能力和最有想法的被试往往不是最受欢迎的人。为什么呢？一种可能是，尽管我们喜欢和有能力的人在一起，但是那些能力太强的人会让我们感到不舒服。他们看起来不可接近、遥不可及，这让我们看起来很糟糕（感觉可能更糟\n\n那么当看到一些人存在某些易犯错误的证据时，我们可能更喜欢他们。那么如果他们偶尔搞砸了，你可能会更喜欢他\n\n**破绽效应**：犯错误的优等生被评价为最有吸引力；犯同样错误的普通人被评价为最没有吸引力。\n\n我们从能力很强的朋友和亲戚中获得极大的满足感和自尊。接近有能力的人是值得的；我们可以向他们学习，享受他们的荣耀和成功。然而，如果他们在那些对我们而言重要的领域比我们更有能力，因此通过比较使我们感到自己无能或存在缺憾时，他们在我们心目中的吸引力便会减弱\n如果兄弟姐妹、亲密朋友和恋人在不同的领域表现卓越，他们可能会更容易保持亲密关系。\n\n### 个人特征：身体吸引力\n\n正如相似效应所表明的那样，人们倾向于在相同的吸引力水平上配对\n人们认为“美丽”的某些方面是与生俱来的，反映出人们对看起来健康、没有疾病的伴侣的偏爱。广告，连续不断的宣传攻势，旨在推销这样一种观念：瓶中女人会让我们变得更有吸引力，在社会上获得成功，从而变得快乐和完整。美貌偏见意味着没有魅力的孩子要为他们的外表付出代价\n\n美貌予人们以力量，但美貌也有一个缺点：人们会对批评自己长相漂亮的人更为苛刻。我们必须面对一个事实，那就是漂亮不仅仅是肤浅的。我们更喜欢漂亮的人，我们对他们更友好，我们认为他们比长相平平的人更温暖、更性感、更令人兴奋。此外，在不确定谁应该为不幸事件负责的模棱两可的情况下，我们倾向于假定他们是无辜的。\n\n当男性搭档认为他在和一位漂亮的女士交谈时，他会用一种能够展现她最好品质的方式和她交谈。当独立观察者听到她的谈话时，他们认为她比伴侣认为她不那么漂亮的女人更有吸引力、更自信、更活泼、更热情。这项研究为自证预言提供了一个生动而感人的例子：不管一个人的外表是否漂亮，当人们把他们当作有吸引力的人来对待时，就会把那些令人向往的品质展现出来。\n\n当我们对一个人的好感增加时，我们会发现这个人会变得更漂亮，这不仅仅是因为我们把他的长相和其他品质平均到了一个整体的评价中去了，而且是因为我们对他的感觉增强了，所以我们认为他更漂亮了。美的东西是好的，但好的东西也会变成美的。\n\n## 讨人喜欢\n\n决定我们是否喜欢某个人的最有力的因素之一，是相信某人喜欢我们。面对你热情可爱的行为，我对你的喜爱无疑会增加，反过来，我也会用更讨人喜欢的方式来表达我对你的喜爱。在随后的互动中，那些认为自己被喜欢的人表现得更讨人喜欢：他们比那些认为自己不受欢迎的人透露更多有关自己的信息，不那么提出反对意见，而且通常对他人表现得更热情、更愉快。那些认为自己被喜欢的人，事实上，后来也被另一个人喜欢；而那些认为自己不受欢迎的人，也不会被另一个人喜欢。这是自证预言的又一个例证。我们的信念，无论对错，都在塑造现实中扮演着重要的角色。\n\n此外，我们的不安全感和自我怀疑越强，我们就会越喜欢那个喜欢我们的人。\n\n对自己有安全感的人不那么“需要帮助”；也就是说，他们不太可能接受任何主动提出的建议。一个没有安全感的人会接受几乎所有表示感兴趣的人，而一个有安全感的人会更加挑剔。此外，一个没有安全感的人甚至会找一个不那么有吸引力的人来减少被拒绝的可能性。\n\n但是在约会的条件下，我们往往更容易被那些似乎只喜欢我们的人所吸引 —— 只有我，而不是所有其他成千上万的人，在等待着这样一次机会。\n\n## 选择的悖论\n\n所以现在你找到了自己的真命天子：住在你附近的某个人；他（她）和你有很多相同的价值观和信仰；这是一个喜欢你的人，而且他（她）所喜欢的人只有你；他（她）是一个长相英俊或漂亮的人。现在怎么办呢？你会说：“我找到了我的人生伴侣！抓住这个机会吧！”或者你会说：“嗯，等等 —— 这真的是最适合我的人吗？也许我很快会遇到更好的人？”\n\n人们认为拥有更多的选择总是比拥有很少的选择好，所以当你问他们时，他们总是说想要更多的选择。但是施瓦茨发现，拥有太多的选择可能会产生一个悖论：能够在多种选择中作出选择固然很好，但当所有这些选择一起妨碍我们作出任何决定时，情况就不那么好了。随着选择的增多，我们对完美的期望也越来越高，这意味着我们常常会这样想：如果我们观察得更久，是否会作出更好的选择。施瓦茨认为，由此而导致的结果是，我们变得更加挑剔，对最终的选择不会太满意；为了追求完美，我们不得不权衡和评估如此之多的选择，这让我们疲惫不堪。有时我们只是被众多的选择所麻痹，最终什么也没有做。\n\n如今，与人见面变得更容易了，因为科技可以让我们立即与更多住在我们附近的潜在伴侣联系起来，这比我们的祖父母一辈子可能遇到的人还要多。但是，就像顾客们面对果酱一样，无休止的选择也可能会导致他们不去做任何选择。\n\n不可避免的人类社会比较过程让选择悖论变得更糟，因为似乎每个人都找到了自己的梦中情人，而你却没有。我们在行动中的确存在着选择悖论：无限的选择让我们把当前的选择比作幻想。没有人能与幻想抗衡。\n\n## 赞扬和帮助\n\n消极的评价通常会增加我们对评价者的钦佩，只要他（她）所评价的不是我们自己。人类追求准确和共同理解的动机，会超越被喜欢、被欣赏、被赞美的欲望。我们当然希望得到爱和赞扬，但同样重要的是，我们也希望被了解和理解。被试更喜欢表扬他们的评价者，而不是那些消极的评价者，但他们对那些赞美可能是别有用心的评价者的喜爱程度会急剧下降、\n\n施惠，像赞扬一样，也可以被视为奖赏，我们倾向于喜欢那些施惠于我们的人。如果人们觉得有义务归还东西，他们不一定喜欢礼物；他们不喜欢从有能力施以恩惠的人那里得到好处。\n\n这句格言是：“曾经帮助过你的人，将比你自己帮助过的人更愿意帮助你。”\n\n## 得失理论 （性张力）\n\n他人积极的、有回报行为的增加对我们的影响，比那个人不断有回报的行为对我们的影响更大。我们会喜欢一个人，由于他对我们的喜欢随着时间的推移在增加，而不是一直喜欢我们善良的老弗雷德（ Fred ）或莫莉（ Molly ） —— 他们一直喜欢我们。该理论预测，在“得”情况下，你会最喜欢一个人（在这种情况下，这个人一开始讨厌你，逐渐会变得喜欢你），而在“失”的情况下，你会最不喜欢这个人（在这种情况下，这个人一开始喜欢你，逐渐开始讨厌你）。","n":0.11}}},{"i":131,"$":{"0":{"v":"Attachment","n":1},"1":{"v":"依恋关系是两性之间一个很重要的话题。因为童年和父母的关系，人们产生了4种依恋类型\n\n![](/assets/images/2021-02-16-22-31-10.png)\n\n- [[回避型依恋|life.love.attachment.avoidance]]\n- [[焦虑型依恋|life.love.attachment.preoccupied]]\n- [[安全型依恋|life.love.attachment.secure]]\n\n","n":0.5}}},{"i":132,"$":{"0":{"v":"Avoidance","n":1},"1":{"v":"\n# 回避型依恋\n\n## 核心\n\n看重自己的生活，不信任他人。很难走入亲密关系。\n\n## 表现\n\n- 专注自己的生活，不怎么考虑别人的感受\n","n":0.447}}},{"i":133,"$":{"0":{"v":"Knowledge","n":1},"1":{"v":"\n\n# 知识结构\n\n姚勇在知乎专栏发表了一篇文章：《人生艰难，如何才能过得好一点呢》（https://zhuanlan.zhihu.com/p/482757365）\n\n1. 人性与社会的知识与经验。\n2. 想事情的方法。会提高学习和专业技能速度，以及提高思考水平，提高生命效率。\n3. 目标规划和执行 。实现目标的办法\n4. 工作生活中做抉择的方法 ，包括了解和洞悉他人的办法\n5. 处理关系的方法。包括亲密关系和功利关系。\n6. 抵抗挫折，照顾自己心灵的办法。\n\n![](/assets/images/2022-06-29-07-55-18.png)\n\n## 人性与社会的知识与经验\n\n社会生存竞争也同样道理——需要了解人和社会的运转规则。无数智者伟人，以及智力运气与我们差不多的人，通过知识取得成就。也靠知识开启工作与人生的顺利之路。\n\n生活工作重大决策质量，取决于对社会和人性的经验多寡。\n\n身体生存，权力，财富，繁衍（也就是男女关系）。当代人类社会都是围绕这几个脉络在运转和博弈。\n\n### 身体\n\n为了增加有效时间，只有两种办法：\n\n1，增加精力；2，提高效率。前者靠健身和饮食起居，后者靠提升思维能力（也就是实用第二类工具）。\n\n### 权力\n\n人类总是会把控制和分配的权力交给少数他们认为有能力的人。这是人类社会发展的必然性。\n\n权力可以分配资源与控制他人，所以只要对功利有追求，必然伴随着对某种权力的追求。这方面的研究是《政治学》《政治心理学》。我们不会过多提及。毕竟想过好日子的人多半并不关注如何控制他人。\n\n对我们重要的是，在现代商业社会中的博弈过程中，把人对权力的追求放入预判因素中。当你了解他人在某种情境对权力的欲求，就可能提高预判准确程度，提高决策质量\n\n### 财富\n\n必要的财富，最大作用是对抗现实复杂人生和世态炎凉的压力。叔本华对财富有过一些很精辟的论述：\n\n“人类天生就是热爱金钱，这种热爱是不可避免的”；\n\n“财富就像海水，越多喝越渴 …… 我们之所以不满，就是因为我们的欲求越来越多，期望越来越高，却总也无法企及，永远不能满足”；\n\n和我们个人经济生活相关的研究领域是经济学，比如《经济学原理》《行为经济学》。这涉及到个人的挣钱，买房，投资，理财等。经济学与心理学、逻辑思维一样，都是现代人应该学一些的知识。\n\n### 繁衍\n\n带来幸福满足感的家庭基础，一定是深厚感情，和谐性爱与足够的物质条件。婚姻与养育后代是消耗性过程。没有足够感情基础和物质条件，经不起消耗。\n\n在预判他人心理活动时，了解一个男人对异性的渴望程度，以及在性吸引下的自控程度。并且了解其在道德层面的看法。有助于预判在追求功利过程中这个人的心理活动与行为。\n\n男女和功利追求几乎同源同类。但男人追求功利的博弈更加隐蔽。追求男女时就没法那么隐秘了，所以相对容易看出这个人的特质。\n\n英雄难过美人关，过关都靠降睾酮。\n\n研究男女的科学主要是《进化心理学》《亲密关系》《社会心理学》《情爱关系中的选择》《社会学》。\n\n### 人性\n\n人性是人类本性，人类本质心理活动属性。大致可以理解为人类共有的心理活动特征。比如善恶，感觉，道德等等。\n\n人的说话行动与抉择，由心理活动推进。有些是直觉快速推进。有些是理性思考后推进。所以如果能够了解别人的心理活动，基本就能推断出这个人行为的大致的情况。\n\n如果你能某种程度预判他人的行为与想法，那么在功利相关的活动中，你可以部分做到得心应手。\n\n如果你能够某种程度给他人灌输自己的想法，那么结合预判，你大概率可以做到庖丁解牛。\n\n人是社会的动物，研究人在社会中的心理和行为，主要是《社会心理学》和《社会学》。\n\n### 人格\n\n人格是一个人一贯的行为方式和内部心理过程。主要研究人与人之间的差异。以及预知人在某种情境下的行为反应。研究这方面的科学理论是《人格心理学》。了解自己和他人的人格，对我们日子能过好一些，有极其重要的作用。\n\n对自己越了解，越能友善与适当地对待自己。这不是一个自然就具备的能力。\n\n对于人格知识的了解，也有助于分析他人性格特征，做到知己知彼。在与他人交往过程中充满自信和从容。\n\n## 提升思维质量的工具\n\n人脑思维过程分两步：1 产生想法，2 对想法进行判断。两个过程紧密衔接，循环往复。甚至几秒就循环好几次。为了提高思维质量，就把这两步的改进，分为创造性思维和批判性思维。\n\n创造性思维是得到一些想法来探索新问题，及时发现已存在问题，创造新方法解决问题，作出判断，形成结论，做出决定。\n\n批判性思维是检视和评价我们在前一步得到的想法。也就是批判性的思考我们第一步的想法。也就是关于想法的论证。\n\n《思考的艺术》介绍了必备的底层思考方法。\n\n### 创造性思维\n\n创造性思维不是只有发明全新的想法与东西才需要。生活中，日常工作中，全都需要。领导给你一件工作，你比别人能想到更高效的完成办法。这就是创造性思维的应用。\n\n如何创造性得到新想法。书中给出了 “采用新思路”，“设计或修改程序制度”，“发明新产品与功能”，“现有事物找到新用途”，“改进现有事物”，“创造或重新定义概念” 等方法。论述极其精彩。\n\n书中也给出了 4 步创造步骤：“寻找挑战”，“表述问题 / 争议”，“调查问题 / 争议”，“产生想法”。\n\n### 批判性思维\n\n批判性思维检验已经产生想法的质量，让产生想法的思考过程接受理性评估\n\n而批判性思维应用于作者当时代的经济，社会，生物，王权等方面，各个智者对当时社会和思想进行检视与批判，产生了《国富论》《资本论》《进化论》《独立宣言》等著名思想\n\n检验思维会用到逻辑的方法。\n\n### 有效推理\n\n因为推理是解决问题的主要手段。生活中处处充满了要解决的问题。所以就有必要提高推理的水平。逻辑学就是用来提高推理水平的。\n\n《生活中的逻辑学》目前中文版本是国外第 12 版译文。是逻辑思维指导生活的开山之作与圣经。作者是著名逻辑学家，批判性思维运动的发起人。\n\n### 甄别谬误\n\n曾经对我有巨大帮助的思考方法里，是一种识别其他人论证谬误的方法。基本只要掌握了这个工具，不管是现实还是网络上，你在辩论和说理论证方面，基本就没有人能够难倒你了。最主要的是你可以节省大量时间。\n\n《逻辑模型》这本书中，作者精选了思考逻辑，表达逻辑，写作逻辑的 67 种技巧。浅显易懂，大量配图。作为工具书参考比较方便。它结合了一些更综合的方法。\n\n### 维度思考法\n\n我们提供思考的 5 个纬度。分别是：思维的高度，广度，深度，远度，灵活度。用这 5 个纬度来度量思考质量。\n\n高度：\n\n现实中的事情都很复杂。有时候，在一个层面上逻辑自洽的思考，如果提升一个高度，就能出现新的逻辑。揭示事物更多的规律，产生更多的创新方法，解决更大规模更复杂程度的问题。这方面的例子就是俗语说的，站在领导的位置思考。如果一个方法能够驱动的事情规模更大，更重要，惠及更多人，影响更深远。我们就说思考是有高度。\n\n广度：\n\n在此是指视野的宽度和事物有关元素的广度。当持续扩大视野在更广泛的区域内搜集更多元素，也许会扩充创新想法，解决更难的问题。在前面 “创造性思维” 中有提及。这和某些特定领域的经验也非常相关。专家往往比局外人掌握更多信息，视野更广。\n\n深度：\n\n涉及到具体专业领域的问题时，必须有足够深入的探查思考。\n\n深度向的思考方法，一般就是多问 “为什么 “ 。\n\n远度：\n\n这是时间轴。很多时候，把近期，中期，和远期三个时间点加入考量的要素。问题就会更清晰。这是任何经济领域和权力领域都要考虑的事。\n\n灵活度：\n\n在这个维度上常用的方法之一是换位思考。或者不断在各种高度，宽度，远度来回跳跃思考。一个想法适应性强，能够经受不同边界情况，依然有效。也可以说方案有弹性，伸缩性。在思考具体执行方案时能够根据情况进行适当、及时变通。不教条。都属于灵活度范畴。\n\n## 目标规划\n\n目标规划和决策的工具是面向未来。生活是一条单行线。在当下决策好，规划好，以便让未来的样子和我们想的相去不远。\n\n### 目标设定\n\n目标设定有两个作用。“确立正确的目标作为行动目的 “。另外一个作用更隐秘，但同样重要 ------ “靠规划出目标让人生有效率前行”。\n\n要设定好目标并达成，需要目标设定本身具备几个特征。这些特征能更有效帮助我们达成目标。\n\n1. 行为 = 期望 x 价值。我们需要制定价值高一些，让人非常有期许的目标。\n2. 目标的难度要设定适度，不能太容易，也不能太难。过去公司培训我经常用 “时刻在离你能力之外一点点的距离挑战你的极限 “。这是提升能力的最佳办法。《心流》中对最佳体验的描述也符合这个规律。\n3. 大目标的实现要拆分成多个具体的小目标，最好有层次。比如减肥，可拆分为增加消耗和减少摄入 2 个子目标。增加消耗又可以分为每天步行 10 分钟和一周 2 次健身房。减少摄入是每周轻食 3 天和不喝含糖饮料。\n4. 目标要足够具体，有衡量的量化标准\n5. 目标分为短期，中期和长期目标。循序渐进。\n6. 为实现目标想出多个办法和路径。\n7. 经常同时去想一下：目标实现后的好处。以及当前要实现目标需要的行动元素。靠心理比较来推动\n8. 最后，先让自己动起来。这是最重要的一步。\n\n### 目标执行实现\n\n参考《动机心理学》的 “自我奋斗” 一章：\n\n1）设立标准\n能够让我们感受当前进展和目标的差距。这是一种无形的激励。减肥者每周拍图，对比瘦下来的一点点痕迹，也是很大的动力。\n\n2）监控行为\n是建立一种机制，不断去监控我们完成目标的行动，是不是出现偏差。比如测量每日步行的 app。在每天提醒当天走路步数是不是达到了标准。\n\n3）自制力量\n延迟满足感，是牺牲短期回报，获取长期回报。在完成减肥目标的过程里，都需要主动牺牲掉一时的口腹之欲。换取长期的形体健美身体健康。\n\n自我损耗理论揭示了人的自控力是每天只有固定一管。所以心理学家的建议是，当今天有完成目标的计划时，尝试减少一部分自控力的消耗。或者多喝糖水（据说补充脑子，当然糖水漱口据说也可能管用）。\n\n## 决策的方法\n### 决策流程与方法\n\n决策流程与方法，可以参考《决策的艺术》。还有一本关于人脑判断与决策非常有趣的书。是诺贝尔奖获得者，行为经济学开创者丹尼尔 · 卡纳曼写的《快思慢想》。\n\n这本书主要就是说人的思考具有很大的一部分非理性。\n\n### 决策依据的质量\n\n依据越充足，越准确，我们就越能做出优良的决定，想出更好的办法。\n\n如果是一件与自己切身利益与发展有关的事，那我们需要：\n\n- 非常清晰事情到底是怎么样的。也就是了解事情本质。\n- 对事情所处人群的环境有深刻的理解。比如同事或股东间，部门内，部门间，下属与领导，单位之间等\n- 对相关人的想法，有比较靠谱的判断\n\n前两条需要第一和第二类工具。第 3 条，比如日常生活一场砍价还价，是双方不断探查利益心理底线的过程。\n\n###  理解与洞悉\n\n人与人之间的能量等级有三种。 一种是专业技能的高下，一种是思维与实践能力的高下，最后一种就是理解与洞悉他人想法能力的高下。\n\n大概有几个角度可以帮助我们提高这方面的能力：\n\n1. 掌握社会与人的知识。具备逻辑思维能力。\n2. 对人普遍的社会行为心理机制熟悉，对决策心理熟悉。\n3. 亲密关系中他人想法的预判，要熟悉一般人在两性关系中的心理活动。\n4. 权力相关的，必须深入理解中国社会运转的规则，中国小农经济的差序格局，权力组成结构，官僚体系，社会治理核心逻辑等。\n\n\n### 理解与洞悉方法建议\n\n建议每个人找到适合自己的方法论，来理解和洞悉别人的想法。\n\n在此只针对年轻人给一些简单的建议：\n\n1. 明确对方在这件事中的角色和利害关系，以及人际关系\n2. 尽量获取个人信息。从家庭背景，成长经历，教育背景，工作经验，个人爱好特长，喜好，三观，习惯等。越多越好。\n3. 分析出人格属性和社会心理属性。全面了解其个性与习性。\n4. 透彻了解对方诉求。无非几种诉求的混合。利益诉求，权力诉求，功能诉求或者感情诉求。\n5. 用第一类和第二类工具分析以上信息。作为决策依据。再使用决策方法进行决策，进行利害取舍。\n\n## 处理关系\n\n一种是功利关系，一种是亲密关系。这两类关系直接关系到我们利益权力和感情生活。\n\n### 亲密关系\n\n亲密关系是社会心理学中专门研究的一个领域。想简单了解可以查阅《社会心理学》中的专门章节。找到适合的对象，经营好恋爱关系与婚姻关系，是重要的人生工程，也是人生里最难的事之一。你的人生里， 什么事情需要持续维持 50 多年呢？工作挣钱最多都只能干 40 年，维系家庭关系获得美满个人生活体验是往后余生都要做的。\n\n罗兰米勒的《亲密关系》彻底分析了人之间所有亲密关系的规律和维护的建议。\n《进化心理学》使用进化论和生物进化解释了大量跨文化的人类心理细好倾向。\n《少有人走的路》(第一卷）分析了成熟心智的重要性，以及对 “爱” 的不同角度解读。\n《家庭婚姻社会学》分析人类谈恋爱，结婚，离婚，再婚，家暴，老年婚姻等各个环节。\n\n### 功利关系\n\n工作就几个选择：进单位，自由职业，搞生意创业。这几个选择都要和别人建立功利关系才可以。上下级，甲乙方，合伙人，客户，政府或其他组织的权力与利益相关人。核心是信任基础上的利益权力资源交换。\n\n一般成年人都是从实践中逐步理清这些关系的。如果对中国特色的关系社会有快速全面的认知，可以参考费孝通的《乡土中国》。但有两篇台湾清华大学社会学教授罗家德的论述，可能更加通俗易懂。关系篇直接跳转。生意篇直接跳转。中国本土心理学杨国枢的《中国人的心理》也可以参考。台湾黄光国写过一本《人情与面子 ——中国人的权利游戏》。台湾是做本土心理学研究比较早的。另外提一句黄光国也是《自卑与超越》的译者。\n\n中国关系社会从过去宗族社会演变过来。还保持着如下格局。\n\n每个人都以自己为中心，向外围绕几个圈层。家人裙带，熟人裙带，弱连带， 完全陌生人。这几个圈层里的法则秩序都是不同。没有统一的契约精神和法制观念。也没有共同的宗教精神纽带连接。每个人都是他人某圈层的裙带关系一员，形成了错综复杂的利益，权力，责任与义务关系。人情也是复杂和暧昧的。\n\n中国社会与权力形态，还可以参考如下书籍。《潜规则》，《血酬定律》，《兴盛与危机》，《开放中的变迁》，《乡土中国》，《中国近代史》（台，徐中约, 未删节），《中国近代思想史》（李泽厚），《中国现代思想史》。\n\n![](/assets/images/2022-06-29-08-10-50.png)\n\n## 抵抗挫折和照顾自己心灵\n\n### 研究自己\n\n认识自己最大的用处，可能并不是针对外界。而是对自己的关怀与安抚。吃好的，买好东西，找到好的亲密关系，好工作，有好多时间尝试好的娱乐活动，这些是你从外界刺激体验到的。但人总有处于负面处境的时候，被外界冲撞，不爽，愤怒，哀伤，绝望，苦恼，无助，被人侮辱戏弄，遭受损失，心理疼痛的时候。在这个时候，你手里唯一的工具，是你平时对自己的了解和接纳。树总有被风吹弯的时候。你要挺起来的真正依托，来自于你内在那个自我认知的你。\n\n### 毫不犹豫的接纳自己\n\n把自己的性格，特性，心理习惯都搞清楚。并且要肯定自己的所有性格与特性。\n\n性格和心理特征没有好坏。不要听信任何外界，尤其有权力和控制的人，对你个性与人格的任何评判。敢于恣意评判他人个性与人格的，都是极具侵略性的人。这种人亲近性很差。有些人就是有人格障碍。你就当他们在放屁。\n\n如果想特别详细的研究自己，建议去看社会学精品译丛系列的那本《自我》。坚定了自我的认知，可以帮你抵御那些侵略性的强势权力控制和 PUA。比如你的领导特别爱用诛心的方式，靠诋毁你的人格，自尊和能力，来负面评价你的能力，管理的你的工作。你需要非常强大的内心和自我认知才能部分抵御这些。\n\n### 从道德观，价值观，和人生观研究自己\n\n经常考虑一些观念和标准的问题。有助于我们在社会生存得舒适些。比如，我自私自利程度是属于，平均，还是比较弱，或者强？对一件事的看法，我认为好，其他人认为不好。虽然没有对错，但为什么有这个分歧？一件事我会这么做，别人却是那么做的，其中的好坏都在哪里？取舍取舍，有取有舍。舍得舍得，有舍有得。我是用什么标准去决定的？我觉着最舒适的度过人生的状态是什么？一直这么过也会舒适吗？我能一直保持现在满意的状态吗？\n\n另外对欲望的自制力，也非常重要。对财富和权力的态度，会在一些重大事情发生时，对你造成冲击。贪欲使人盲目。众叛亲离之时，钱又能带来什么。\n\n### 原生家庭\n\n你的很多思维习惯和性格，都是在原生家庭中形成的。有时候甚至只是一件出人意料的事，冲击了你的心灵，造就了一些人格特质。这个研究就类似拼图。根据儿时记忆，慢慢寻找家庭铸就你心灵的某些拼块。\n\n### 自信\n\n社会心理学对 “自我” 的研究，表明健康心理的人， 对自我评价都在平均值之上。也就是大部分人都认为自己好过大部分人。只有抑郁状态的人才会比心理健康的人更客观评价自己。 \n\n自信是从孩童时代，由父母灌注的。天生获得的优势（颜值，身高，IQ，出身）也会起到作用。如果在负面教育环境成长，性格很容易在自卑和自负之间来回打转。而只有天生的优势没有后天能力的依托，也很容易栽入低自尊境地。\n\n成年人培养自信，只能从两个方面。一个是不断增长且被证明的能力。一个是变得勇敢一点。归根结底，还是靠不断证明的能力。这个过程很难很漫长。而且这种自信基础很弱。基础不牢，稍微碰到能力比自己强的，又会回到过去那个低自尊无自信的自己。\n\n### 情绪自我安抚\n\n《情商》对情绪做了详细介绍。包括情绪从何而来，如何分辨不同的情绪，如何搞清情绪的来源。当有情绪的时候，不要因为自己产生某种情绪而更加羞愧和自责。一个人有任何情绪的时候，都是正当的！要坚信和坚持这一点。情绪对人产生比较大的侵害，往往是二次伤害。也就是你对负面情绪的自责，加深了对自己身心伤害。","n":0.089}}},{"i":134,"$":{"0":{"v":"Management","n":1},"1":{"v":"\n# P.A.R.A\n\n[link](https://fortelabs.co/blog/para/)\n\n- project\n  - a series of tasks linked to a **goal**, with a **deadline**\n- area\n  - a long term activities with standard to be maintained over time\n- resource\n  - a topic of them of ongoing interest\n- archive\n  - inactive iterms from the other three categories\n\n![](/assets/images/2021-11-16-10-14-39.png)\n\n![](/assets/images/2021-11-16-10-14-49.png)\n\n\n\n# project\n\n- 整理知识库\n  \n\n# area\n\n- finances\n- health\n- time management\n- house\n- relationship\n- professional development\n- humor\n- food\n- knowledge management\n\n# resource\n\n- blockchain\n- EV\n- 直播\n- metaverse\n- search engine\n- mlops\n- work_relationship\n- project_management\n\n\n# 自己的已知存储内容\n\n- onenote\n- 有道\n- Evernote\n- inoreader\n- pocket\n- workflowy\n- 收趣\n- 简悦\n- kindle\n- omnifocus\n\ninoreader -> google sheet -> 整理到resource/area -> 保存网页到dropbox\n\n已有的都整理到dendron里\n\n手机看到的到inoreader\n电脑看到的到简悦。\n\n不同的平台有不同的好处，但还是需要最后合并。","n":0.105}}},{"i":135,"$":{"0":{"v":"House","n":1}}},{"i":136,"$":{"0":{"v":"Order","n":1},"1":{"v":"\n我建立了一个六个步骤的问题列表，帮助你评估每样东西的相对重要性，这样你就可以更快地作出决策，继续前行。按照下面的顺序，问自己这些问题，并用“是”或“否”来回答，回答的时候尽量诚实（不要反复斟酌你的答案）。\n\n1. 它是否还能用？问问你自己：它还能不能用？如果答案是否定的，那就丢掉它。如果答案是肯定的，继续问题2。\n2. 你喜欢它吗？问问你自己：我有多大的可能性使用一样我并不喜欢的东西？如果答案是不太可能，那么就丢掉它。如果答案是有可能，继续问题3。\n3. 它是一件必备的东西，还是可选择的？对于“你不喜欢的”东西有一个特例，那就是它是必备的。类似的，可能有一些东西你很少使用，但你确实需要它们，而且很高兴能拥有它们。问问你自己：它是不是必备的，或者如果丢掉它，当我需要的时候我是否必须买另一件，而且我确实知道将来某个时间点会用上它？如果答案是“是”，那就留下它。如果不是，继续问题4。\n4. 有没有一段有价值的往事，附着在这件东西上？问问你自己：它是否有一段有价值的故事？如果答案是“否”，那就丢掉它。如果答案是“是”，继续问题5。\n5. 这段故事是否让你感觉很好？问问你自己：这段故事是不是让我感觉很好？如果不是，丢掉它。如果是，继续问题6。\n6. 这件东西与你的生活有关吗？问问你自己：它是不是仍然与我今天的生活有关？如果不是，可以丢掉。如果是，那你可以留着它。\n","n":0.378}}},{"i":137,"$":{"0":{"v":"Health","n":1}}},{"i":138,"$":{"0":{"v":"Worried","n":1},"1":{"v":"\n想太多，比较太多，感慨太多，很累的。\n\n蹒跚学步的孩子，跌到了，摔疼了。哭两声，站起来，拍拍土，继续往前走。每个人都是这样的，只是别人挫败的时候，你没看到。分心考虑太多，徒增烦恼。实在和自己较劲了，内心波动了，难受了，可以人际上求安慰。或者，干脆写下来，在日记里表达下感受，发泄一下。之后，情绪发泄完了，表达完了，把挫败的感受放下了。请把宝贵的注意力资源放在自己此时此刻能做的，能把握的事情上。比如，想追求生活的幸福，想有个好的前途。眼前，此时此刻，能做的事情有哪些，是想办法接近身边有好感的女孩子？还是把手头需要完成的工作做好？总之，把想到的，眼前能做的事尽力做了。其他，就交给时间慢慢发酵了。大概是这些。\n","n":1}}},{"i":139,"$":{"0":{"v":"Weight","n":1},"1":{"v":"# how to lose weight\n\n食物的类型就是造成肥胖的元凶\n\n重点就是少糖饮食，以及少吃加工食品。\n\n## why\n\nLPL的作用就是把血液循环中恰好“路过”它附近的脂肪“拉进”它所属的细胞中去。人会变胖\n\nHSL的作用能使脂肪细胞（及我们）更瘦。它之所以能做到这点，主要是具有将脂肪细胞内的甘油三酯分解为脂肪酸分子的能力。如此，这些脂肪酸就能进入血液循环中被消耗。人体内HSL越积极，我们释放的可燃烧的脂肪就越多，我们储存的脂肪就越少。\n\n胰岛素在升高LPL活性的同时，也会抑制HSL的活性。人会变胖。\n\n胰岛素在身体中有很多作用，但其中至关重要的作用就是控制血糖。在人吃食物时，血糖会升高，我们就会分泌胰岛素。\n\n胰岛素所做的一切都表现为增加我们储存的脂肪，减少我们燃烧的脂肪。\n\n你分泌的胰岛素越多，细胞和组织越可能对胰岛素产生抵抗。胰岛素抵抗会使细胞对胰岛素的敏感性下降，这就意味着，你需要更多的胰岛素来完成同样的葡萄糖清除工作，以控制血糖含量。\n\n我们从饮食中吸收的糖越多，我们的身体就越习惯于把糖分转化为脂肪储存。","n":0.408}}},{"i":140,"$":{"0":{"v":"Food","n":1},"1":{"v":"\n“早餐\n\n蛋白质：肉类或鸡蛋。\n脂肪：蛋白质类食物中应该已经有不少脂肪，例如培根和鸡蛋中就有。但假如蛋白质中的脂肪不足，那么可以用黄油或奶酪等适当增加些脂肪。\n绿叶蔬菜：可以和煎蛋卷一起吃。\n\n\n\n午餐\n\n蛋白质：肉类或鸡蛋。\n脂肪：假如蛋白质中的脂肪不足可以用牛油、色拉酱、奶酪增加些脂肪，也可以吃一个鳄梨。\n绿叶蔬菜：100克到250克的生食蔬菜或者煮熟蔬菜。\n\n\n\n点心\n\n含有蛋白质或脂肪且低糖的点心都可以考虑。\n\n\n\n晚餐\n\n蛋白质：肉类或鸡蛋。\n脂肪：假如蛋白质中的脂肪不足可以用牛油、色拉酱、奶酪增加些脂肪。\n绿叶蔬菜：100克到250克的生食蔬菜或者煮熟蔬菜。\n","n":1}}},{"i":141,"$":{"0":{"v":"Tiredness","n":1},"1":{"v":"\n疲劳的基础在于我们的身体的新陈代谢 。如果我们身体健康的话 ，每天起床彻底醒来之后是一天中最为清醒的时间 ，这是因为一晚上的休息补充了代谢的消耗 ，让我们感觉自己是全新的 。\n\n\n休息得不充分 、熬夜 ，以及其他一些身体亚健康状态 ，会阻碍代谢的补充 ，使得神经内分泌情况难以恢复到最佳状态 。这会影响人的认知能力 ，记忆 、阅读 、语言和逻辑思维能力会因此受到限制 。因此我们的大脑沉浸于某项工作的能力被削弱 ，表现为难以集中注意力 。疲劳的机制决定了伴随着我们的疲劳感出现的还有成就感降低 、对工作失去兴趣 、容易产生暴力倾向等附带效果 。因此长期高强度的加班 、三班倒等工作方式会改变人的 「性格 」 ，使人变得无趣 、无神 、无味 。\n\n\n转做不同的事情 ，新的事情要与先前的事情具有认知上的明显差异 ，不然的话达不到休息效果 ，反而造成了低效的 「多任务 」状态 。\n\n\n不难理解 ，注意力在疲劳时候受到的这些影响 ，会直接影响到我们的认知能力的表现 ，这包括反应时间的延长 、出错率的增加 、有效的持续工作时间缩短等等 。\n\n\n\n我们神经系统的疲劳耐受性会非常显著地影响我们在压力情况下的认知表现 ，从而决定一个人的 「毅力 」 「专注度 」 。可以说这个因素是 「毅力 」的生理基础 。毅力可以培养 ，但是毅力难以锻炼 ，因此是容易理解的了 。\n\n焦虑会影响专心和记忆。\n\n当焦虑超过阀值，人们可能会失去自己的自我，放弃之前的信仰。\n\n## 方法\n\n- 良好的睡眠\n- 我们更需要的是走出去，找朋友一起参与锻炼活动——跑步、爬山、游泳、骑车、瑜伽、冥想。这些事物较少涉及脑力需求，能让我们获得很好的休息，同时社会联系能让我们由于疲劳和压力产生的情绪有一个宣泄的出口。\n- 在工作时间，最好不要持续投入超过一个小时，而是每过一段时间找点别的事情休息几分钟，喝点水，起身走动一下。\n- 在疲劳感影响到我们的工作和生活时，尤其要拒绝「多线程」的工作状态，即不要同时做多个事情。因为「多任务」是非常低效的，同时又产生更多的疲劳感，其原理我们在前面章节中已经阐述了。\n\n","n":0.134}}},{"i":142,"$":{"0":{"v":"Sleep","n":1},"1":{"v":"\n布钦疗法效果不错：\n\n下面是布钦疗法的步骤： \n1．只有当你感到昨常困的时候才上床。\n2．床只能用来睡觉，不能看书、看电视或者吃东西。\n3．如果你不能入睡，请起床到另一个房间去，待到十分想睡觉的时候，再返回床上。如果还不能入睡，请再次起来。这样做的目的是要将床跟困和入睡联系起来，而不足沮丧和无法睡看。\n4．重复步骤3，如果需要，整晚重复。\n5．调好闹钟，每天早上准时起床，无论晚上睡得怎样，睡了多久。这样能够帮助舟体形成一个良好、有规律的睡眠一清醒节奏。\n6．白天不要小睡。\n\n瑜伽休息术\n躺好闭上眼睛，注意呼吸，均匀、缓慢。感受吸进去的那一口气在体内涌动，深吸一口气，感受这口气到了自己的大脑，然后慢慢这口气向下沉，达到你的脚跟，你的手指，然后往回走，小腿，大腿，腹部，胸部，喉咙，同理，小臂，大臂，咽喉。这口气把所有的浊气都带走，慢慢吐出来。\n这个时候，身体也热起来了，人很自然的就有了倦意。很容易入睡，入睡快且质量高。\n\n## 怎样早睡\n想早起并且精力充沛一定要早睡，保持充足的睡眠，起床时才会让身体舒服。否则当你睡的很晚还硬要坚持早起，第二天起床会觉得又困又累，而且这种情况会持续很长一段时间。\n\n为早睡让路，做好死磕的准备和代价。当你意志不坚定的时候，就会找借口，意志坚定的时候会尽全力找方法，你是打算找借口呢，还是找方法呢？\n尝试过比较管用的技巧：\n\n* 远离所有电子设备：\n* 提前做好洗漱，留意身体的睡眠节奏，当你发现有打哈欠、流眼泪或感觉有些困之类的现象，立刻放下手中的事情，上床睡觉，就会在很短的时间内入睡。\n* 可以通过降低卧室温度来加快入睡，以前经常出差，在宾馆时会把空调开的很低，设上定时关闭，盖上厚被能很快入睡。\n* 尝试减少各种干扰，如使用眼罩来遮挡光照、用耳塞来减少噪音\n* 别在睡前做过于剧烈的运动，也别吃的过油、过饱，睡前别吃任何食物。\n* 别情绪过于激动，尽量避免发脾气、看恐怖片之类的事情\n* 下载一些催眠和入睡的APP，在入睡前播放一些特定的声音，听上一会就能入睡。\n\n\n## 熬夜危害\n\n对人体的影响主要是这些方面：\n* 内分泌紊乱。常见的是连续熬夜或昼夜颠倒后，脸上长痘。还有脱发、月经不规则等都可能与此有关系。更长期的效应难以预见，因为你干扰的是一个顶层的系统啊。\n\n* 植物神经系统紊乱。熬夜对机体而言是一种应激状态，常熬夜者患应激性胃溃疡、十二指肠溃疡的概率都很高。\n\n* 免疫系统紊乱。免疫系统被成为“游动的脑”，深受神经体液的调节，免疫功能的问题可以说是上面两者的结果，也是对健康影响最显而易见的。长期熬夜出现口腔溃疡就是一个方面。换句话说，更容易得病。不仅仅是感染性的疾病，非感染性的疾病例如肿瘤的概率也会提高，因为免疫监视作用受到了抑制。\n\n* 高级神经系统的疲劳。昼夜节律的扰乱让大脑得不到充分的休息，即便白天补足同样长时间甚至更长时间的睡眠，都比不上正常节律的效果，最明显的效应就是记忆力的下降。这个很多朋友都可以过来现身说法吧。\n\n* 其他。例如心血管系统，长期以后血压容易高，心功能储备降低，以及发生冠脉事件的概率都更高。等等等等，不胜枚举。","n":0.25}}},{"i":143,"$":{"0":{"v":"Skin","n":1},"1":{"v":"\n\n# 男性护肤笔记\n\n## 皮肤干燥\n- 男人的皮肤通常比女人更干燥，难以保持水分。\n- 因此，男性需要特别注意补水。\n\n## 收敛水与乳液\n- 化妆品中的收敛水通常含有酒精，它在接触皮肤时会迅速蒸发，并带走皮肤中的水分。\n- 因此，建议在使用收敛水之后使用乳液。乳液不仅会补充水分，还会在皮肤表面形成一层薄膜，防止水分立即蒸发。\n\n## 青春痘问题\n- 男性比女性更容易长青春痘，因为他们通常有更多的皮下脂肪。\n- 男性的皮肤可能较深，随着年龄的增长，皮肤颜色可能会变得红黑。\n- 需要使用控制油脂的产品来处理这个问题。\n\n## 洗脸流程\n1. 使用温水洗脸，使毛孔扩张，以便清洗毛孔内的老废物质。\n2. 将洗面剂挤到手掌上，然后搓揉成泡沫。\n3. 轻轻地抹在脸上，特别注意T区（鼻子、额头等油脂分泌较多的地方）。\n4. 用温水仔细冲洗干净泡沫，确保没有残留。\n5. 最后，用冷水冲洗一次，以收缩毛孔和增加皮肤的弹性。\n6. 用毛巾轻轻拍打擦干脸部，不要用力擦拭以避免刺激皮肤。\n\n## 化妆品使用顺序\n1. 收敛水\n2. 精华液\n3. 眼霜\n4. 乳液\n5. 乳霜\n\n## 护肤理解\n护肤对于男性和女性皮肤有不同的需求。男性通常需要更多的补水，控制油脂分泌，以及防止青春痘的出现。正确的洗脸流程和化妆品使用顺序对于维护皮肤的健康非常重要。此外，避免用力擦拭皮肤可以减少刺激，有助于保持皮肤的弹性和水分。\n\n# 护肤笔记总结\n\n## 化妆水（Toner）\n- 化妆水通常被称为收敛水。\n- 它可以缓解洗脸和刮胡须时对皮肤的刺激。\n- 化妆水的作用包括清除洗脸时残留在脸上的污垢和洗面奶。\n- 同时，它还可以为洗脸后略感干燥的皮肤提供一些水分，以保护皮肤的天然保湿层。\n\n## 如何使用化妆水\n- 使用化妆水非常简单，只需蘸取适量在化妆棉上，然后轻柔地涂抹在脸上的每一寸肌肤即可。\n- 主要目的是清除脸上仍残留的污垢，因此需要使用化妆棉。\n\n## 适合油性皮肤的化妆水\n- 如果你的皮肤属于油性，建议选择不含酒精成分的化妆水。\n- 保湿乳液通常比化妆水浓稠一些，比乳霜稀一些。\n- 乳霜含有更高的油分，更加黏稠，因此具有持久的保湿效果。\n\n## 眼霜的重要性\n- 眼部皮肤比其他部位更薄、更敏感，而且眼睛不停地眨动，导致水分流失速度较快。\n- 因此，眼部需要特别的保养。\n- 眼霜通常在使用保湿乳液之前使用。\n- 如果眼部皮肤不太干燥或敏感，可能不需要专门的眼霜。\n\n\n# 护肤与防晒\n\n防晒是护肤的关键步骤之一，了解不同类型的紫外线（UVA、UVB、UVC）以及防晒指数（SPF）和防晒级别（PA）对皮肤的保护至关重要。\n\n- **UVA**: UVA不会被臭氧层吸收，因此在冬夏无论什么季节，其强度都一样，会导致皮肤晒黑。\n- **UVB**: 大部分UVB会被臭氧层吸收，但夏天尤其强烈，容易导致皮肤晒伤。\n- **UVC**: UVC容易引发皮肤癌，但会被臭氧层完全吸收。\n\n防晒产品通常使用SPF指数来表示其防晒能力，SPF一般在15到50之间，数字越大，防护效果越高。此外，还有PA级别，用于表示对UVA的防护效果，级别越高，防护效果越好，通常使用加号（+）来表示，加号越多表示防护效果越强。\n\n以下是一些防晒建议：\n- 在室内工作时，可以使用SPF15-20，PA++。\n- 春秋初夏在户外活动时，建议使用SPF30-35，PA++。\n- 如果在海边度假或滑雪时，最好选择SPF40-50以上，PA+++的防晒产品。\n\n记住，在使用防晒产品之前应该先使用润肤霜，以确保皮肤得到充分的保湿和滋润。\n\n防晒是保护皮肤免受紫外线伤害的关键步骤，不论是日常护肤还是户外活动，都应该重视防晒工作。\n\n\n\n# 晚上保养指南 🌙\n\n## 洗脸步骤 🧼\n\n1. **过多油脂**：如果脸上分泌过多油脂，可以用洁面油洗脸。\n2. **洗脸顺序**：\n    - 先用温水将脸沾湿使毛孔扩张。\n    - 用洗脸用的洗面器挤出拇指大小的量，揉搓泡沫后轻柔地抹在脸上。\n    - 鼻头等位置更要费心地洗干净。\n    - 用温水冲洗到泡沫完全冲干净为止。\n    - 冲洗干净之后再用冷水冲洗两次。\n    - 洗完脸之后把留在脸上的水分用毛巾轻轻拍打擦干。\n\n## 去角质 🌱\n- **定义**: 角质就是指那些在皮肤内部已经干死的细胞，被新生成的皮肤细胞堆积而露出在皮肤外层的老废细胞。\n- **识别角质**:\n    - 干燥性角质：松松地浮在皮肤表面。\n    - 脂漏性角质：在鼻子两旁或额头上有脂脚角质混在一起而像污垢似的堆叠。\n- **去角质方法**：需要用去角质剂，它是有小颗粒混在里面的洗面奶，只要在脸上搓揉就可以。\n\n## 面膜种类与用法 💆‍♀️\n\n1. **覆盖式面膜**: 在洗过脸涂过化妆水之后敷在脸上放置10-15分钟。\n    - 拿掉后，残留在脸上的精华液轻轻拍打吸收。\n2. **水洗式面膜**: 使用后立即用水清洗。\n3. **撥除式面膜**: 涂抹后等它干掉再撥下来。\n4. **睡眠式面膜**: 洗脸和涂化妆水后敷在脸上睡觉。\n5. **纯天然面膜**\n6. **使用频率**: 一个星期只要敷两次。\n\n## 三部曲 🌈\n- 洗脸\n- 去角质\n- 化妆水\n- 面膜\n- 保湿乳液或乳霜\n\n\n## 皱纹的成因 😟\n\n### 1. **紫外线 & 活性氧**\n\n- **活性氧的生成**: 当我们呼吸时，体内进入的氧气会与营养素结合，产生活性氧。\n- **影响**: 活性氧会破坏皮肤细胞，导致皮肤质变。\n\n### 2. **不良习惯**\n\n- **例如**: 酗酒、吸烟、压力。\n- **影响**: 导致皮肤松垂，产生皱纹。\n\n### 3. **表情因素**\n\n- 在说话或露出笑容时，持续的表情会使皱纹成型。\n\n### 4. **皮肤干燥**\n\n- 使皮肤失去弹性，加深皱纹。\n\n## 如何预防皱纹 😊\n\n1. 充分使用**保湿剂**和**防晒霜**。\n2. 尝试使用**抗老化产品**。\n3. 保持充足的睡眠，特别是在每天晚上十点到凌晨两点。\n\n## 黑头粉刺的成因与处理 😫\n\n### 1. **成因**\n\n- 当油脂没有全部排出毛孔时，会在皮肤内凝固，形成黑头粉刺。\n\n### 2. **处理方法**\n\n1. **热毛巾敷面**: 先让毛孔扩张。\n2. **轻轻挤压**: 用棉花棒挤出皮肤表面的白色油脂硬块。\n3. **使用鼻膜**: 利用膜片的粘性来拔出黑头。\n4. **泥浆面膜**: 也有预防黑头粉刺增生的效果。\n\n","n":0.083}}},{"i":144,"$":{"0":{"v":"Run","n":1}}},{"i":145,"$":{"0":{"v":"Pain","n":1},"1":{"v":"\n# 髂胫束综合症\n\n## why\n\n髂胫束综合征 (iliotibial band syndrome, ITBS) 的原因为髂胫束在股骨外上髁上方滑动造成反复摩擦，伸膝时髂胫束向前移动，屈膝时向后移动，并在屈、伸膝时均保持张力。\n\n髂胫束综合征。红色标记表示损伤部位：髂胫束插入股骨外上髁并刚好位于其近端。（BF：股二头肌；GMAX：臀大肌；GT：大转子；ITB：髂胫束；TFL：阔筋膜张肌；VL：股外侧肌）\n\n![](/assets/images/2022-07-20-08-55-30.png)\n\n![](/assets/images/2022-07-20-08-55-56.png)\n\n过度的摩擦会使髂胫束充血水肿、增厚挛缩变硬，弹性降低、紧张性增强，更加加剧摩擦，导致恶性循环，越跑越痛。就这样看来，似乎跑量大的跑友稍有不注意就容易产生髂胫束摩擦综合征。\n\n![](/assets/images/2022-07-20-08-57-59.png)\n\n因为疼痛在大约膝关节弯曲30度，足着地时最为明显，为了减少疼痛，跑友只好减少弯曲，呈现直腿走路这一异常步态。\n\n## 如何缓解\n\n在消炎镇痛方面，可以采用涂抹非甾体类消炎药（如扶他林）\n\n加强髂胫束拉伸可以松解髂胫束紧张，从而减少绷紧的髂胫束和股骨表面的摩擦\n\n![](/assets/images/2022-07-20-09-15-13.png)\n\n我们更建议跑友采用泡沫滚筒进行髂胫束滚揉放松，但是这个动作做不好反而加剧髂胫束紧张，主要是由于受力过大导致肌肉保护性痉挛\n\n![](/assets/images/2022-07-20-09-15-40.png)\n\n\n## 如何拉伸\n\n加强臀中肌训练就显得特别重要，练好臀中肌可以控制下肢骨骼的运动轨迹、骨盆的位置，并且确保髂胫束不会被“拉离”膝盖或过度紧张。近年来随着研究深入，臀中肌功能受到越来越多重视，所以练好臀中肌才能从根本上甩掉膝外侧疼痛。\n\n侧卧位直腿上摆\n\n侧卧，将一侧腿稍后伸，向上尽可能抬起至最高处，再控制其缓慢下落但不触地。注意保持骨盆不动，脚尖朝前而不能朝上翻转。16次1组，完成2-3组。\n\n![](/assets/images/2022-07-20-09-16-56.png)\n\n贝壳式\n屈髋屈膝并腿侧卧，发力将上腿如同贝壳打开。保证脊柱和骨盆不动。（小窍门：后背贴墙可以防止骨盆翻转哟~）。16次1组，完成2-3组。\n\n![](/assets/images/2022-07-20-09-17-12.png)\n\n仰卧挺髋\n仰卧挺髋是一个经典的锻炼大腿后群肌肉和臀肌的训练动作，这两块肌肉是跑步时发力蹬地的主要肌肉，练好它们可以有效减轻髂胫束压力。屈膝仰躺于瑜伽垫上，足跟靠近臀部，勾脚尖，用上背部和足跟作为支撑点将臀部尽量抬高。16次1组，完成2-3组。\n\n![](/assets/images/2022-07-20-09-17-28.png)\n\n侧臀桥\n侧躺，肘撑地，臀部发力将躯干抬起至身体成一条直线，缓慢还原至初始位置但髋部不要触地。保证骨盆的稳定性，同时腰背挺直。一侧完成20次左右，做2-3组。\n\n![](/assets/images/2022-07-20-09-20-49.png)\n\n单腿下蹲\n单腿练习可以有效训练下肢稳定性，缓慢下蹲至膝关节约45度。同时注意保持腰背挺直和骨盆的中立位。下蹲与站起的动作要缓慢且有控制，并保证下蹲时膝盖方向与脚尖方向一致，切勿内扣。一边完成12次左右，做2-3 组。\n\n\n![](/assets/images/2022-07-20-09-20-59.png)\n\n髋部提拉\n这是一个看上去简单，但实际上很能考验肌肉控制能力的练习，单腿站立于一个稍高于地面的平面（以左腿站立为例）。首先将骨盆保持在中立位，缓慢下降右侧腿，使骨盆向右倾斜。然后臀肌发力，使骨盆再次回到中立位（即仅靠臀肌力量使骨盆回位中立位）。注意是利用骨盆控制完成该动作，而不是躯干侧倾。16次1组，完成2-3组。\n\n![](/assets/images/2022-07-20-09-21-11.png)","n":0.302}}},{"i":146,"$":{"0":{"v":"Food","n":1},"1":{"v":"\n6月6日 6月1-3日①、尽量多摄入蛋白质和蔬菜（鱼肉、瘦肉、鸡蛋类、牛奶都是不错的选择）②、尽量少吃米饭、面包、面条等碳水化合物食品③、注意每天至少2根香蕉，多补充果糖。\n\n\n\n6月4--5日①、多吃碳水化合物食物（如：米饭、面条、面包、土豆、番薯、玉米、小麦）②、少吃肉类，适当搭配新鲜蔬菜③、现在开始最好要远离辛辣、刺激性的饮食，减少油脂摄入，大鱼大肉需要饮酒的应酬能不去就不去。要点：积极备战，储备能量。\n\n\n\nTips：赛前糖原储存法——3+3原则：即前三天低糖饮食，后三天高糖饮食，可以有效提高糖原储备。","n":0.707}}},{"i":147,"$":{"0":{"v":"Mindfulness","n":1},"1":{"v":"\n时刻注意自己的思想和情绪。\n\n因为情绪会像星星之火可以燎原，所以在初期就应该注意到然后扑灭。\n\n一些强烈的情绪都是从一点点开始的。\n\n注意到自己情绪的初期，之后思考如何往哪里走。都是自己可以引导的。\n\n# 练习\n\n- 呼吸\n- 做事情的时候注意到自己在做什么","n":0.5}}},{"i":148,"$":{"0":{"v":"Hair","n":1},"1":{"v":"\n\n\n### 洗头发的顺序\n\n1. **梳理头发**\n2. **用温水沾湿头发**\n3. **冲洗一遍**\n4. **倒出适量的洗发水并搓熟出泡沫**\n5. **轻轻揉搓头发和头皮**\n6. **用流水冲洗，直到泡沫完全洗净**\n7. **使用润发剂或护发剂**\n8. **再次冲洗**\n9. **用毛巾擦干头发**\n10. **用吹风机吹干剩余水汽**\n\n#### 关于润发剂（Conditioner）\n\n- 均衡pH值\n- 增加柔顺性\n- 提供油分\n- 注意：避免接触头皮，油性头皮不建议使用\n\n### 如何使用头发定型剂\n\n#### 发蜡\n\n1. 用吹风机定型\n2. 涂抹少量发蜡在手上\n3. 抹到头发上，创造高低起伏\n\n#### 发胶\n\n- 非常强的固定力\n- 适合头发较粗的人\n\n#### 摩斯（Mousse）\n\n1. 摇晃容器\n2. 挤出适量摩斯\n3. 抹到头发上并用手指塑造造型\n4. 用吹风机吹干\n\n#### 喷雾剂\n\n- 快干\n- 适合发型细软和稀疏的头发\n\n","n":0.174}}},{"i":149,"$":{"0":{"v":"Body","n":1},"1":{"v":"\n\n# 正确的姿势\n\n\n总体来说，这种坐姿会引起颈部和腰背的各种疼痛问题，力学上间接改变了膝关节的受力，提升了膝关节受伤的风险。另外膈肌的下降还会导致呼吸不良，使得心脏承担过度供氧的责任，于是心跳过快，焦虑，高血压都从这个坐姿而来。\n\n正确的坐姿依次是下巴和头收回落肩上，两侧肩胛骨向后收缩同时大臂稍微外旋让胸打开 ，同时肩胛骨下沉尽量让锁骨拉平成一条直线。脊椎拉直让上半身重心落坐骨上，腰腹保持一定程度的收紧来维持脊椎的姿势。而脚落膝盖正前方，双脚，双膝都冲正前方。另外这个坐姿如果维持时间过长，一些肌肉开始疲劳，骨盆会出现不稳定，因此需要考虑将后背靠在椅背上，以正确坐姿为前提。以这个正确坐姿为基础，看手机的时候需要把手机拿高，避免低头。\n\n![](/assets/images/2022-07-10-22-05-56.png)\n\n## 久坐\n\n![](/assets/images/2022-07-10-22-06-47.png)\n\n危害：弯曲后极大的增大腰椎颈椎压力。\n\n成因：久坐造成稳定肌肉疲劳，往前没有支撑，往后有椅背，且前倾难度大于后倾，于是骨盆后倾放松稳定肌，腰就弯了，眼睛又需要看屏幕，头就抬起来，颈椎又弯了。\n\n解决办法：坐时屁股尽量坐到椅子后面，增加腰部支撑和定时起来活动。平常多拉伸，尤其是髂腰肌与股四头肌。\n\n* 长时间保持坐姿 ，会扳动肌细胞内的生化开关，从而提高了心力衰竭的病发概率，同时使致死心脏疾病的发病率提高了 27%，致死癌症的发病率提高 21%，即使你经常保持锻炼，也是如此。\n* 从而使脂蛋白脂肪酶（促进新城代谢）的活动下降最多 95%。其结果就是，身体燃烧的糖分和脂肪减少，健康风险因而飙升。\n\n## 锻炼方法\n\n* 平板支撑\n* 上厕所\n* 跑楼梯\n* 原地踏步\n* 起立，坐下，然后重复这一动作。背部需要挺直，而双手放在身体两侧，或者向前平举\n* 也可以保持站立。当你的身体处于站立状态时，所需的能量比坐着多 30%。","n":0.236}}},{"i":150,"$":{"0":{"v":"Food","n":1}}},{"i":151,"$":{"0":{"v":"Turkish","n":1},"1":{"v":"\n# 土耳其菜\n\n今天的土耳其菜很大程度上延续了奥斯曼帝国的美食传统。正是因为奥斯曼帝国这样一个强盛一时、幅员辽阔、文化多元的帝国的存在，才有了融汇东西、菜式丰富的土耳其菜。奥斯曼帝国的统治阶层信仰伊斯兰教，说着源于中亚的突厥语以及当时通行于中东的波斯语，在政治体制和文化上，则承了很多来自东罗马的遗产，在饮食文化上同样如此。\n\n## 土耳其烤肉 kebap\n\n虽然通常称作烤肉，但土耳其式的Kebab有用碎肉制成的，有炒熟的，也有炖熟的，做法非常多样。\n\n## 其他\n\nManti：这道菜的名字来源于中文的馒头，看上去有点像中国的饺子。\n\n葡萄叶包饭（Dolma）：东地中海和中东地区自古就有制作酿蔬菜（比如茄子塞肉、青椒塞肉）的传统。\n\n土耳其披萨（Lahmacun）：数千年来，烤制的面饼一直都是中东的主食。在奥斯曼帝国兴起之前，中东就出现了放入馅料烤制的大饼，后来逐渐演变成了加入碎肉、蔬菜、香料烤制的薄饼Lahmacun（但不加芝士）。Lahmacun看上去有点像以前流行的土家掉渣饼，关于其起源，有土耳其和亚美尼亚两种说法。\n\n![](/assets/images/2021-09-10-18-15-38.png)\n\n土耳其皮塔饼（Pide）:Pide是另一种被俗称为土耳其披萨的面饼。Pide起源于中东的皮塔饼，土耳其的Pide一般做成潜艇型，肉类、洋葱和芝士是其中常见的馅料，类似的馅饼在巴尔干和高加索也很流行。\n\n![](/assets/images/2021-09-10-18-15-57.png)\n\n土耳其软糖（Lokum）：土耳其软糖是土耳其最有代表性的甜点之一。\n\n![](/assets/images/2021-09-10-18-16-17.png)\n\n果仁蜜饼（Baklava）：这是种用坚果、糖浆、油酥等制成的层次丰富的甜点。","n":0.447}}},{"i":152,"$":{"0":{"v":"Thai","n":1}}},{"i":153,"$":{"0":{"v":"Korean","n":1}}},{"i":154,"$":{"0":{"v":"Japan","n":1}}},{"i":155,"$":{"0":{"v":"Italian","n":1}}},{"i":156,"$":{"0":{"v":"Indian","n":1}}},{"i":157,"$":{"0":{"v":"Health","n":1},"1":{"v":"\n\n# 断食\n\n轻断食的学名为“间歇性禁食（Intermittent Fasting, IF）”，是一种交替进食和延长禁食的做法。\n\n目前，在生活中或学术界比较常见的间歇性禁食有4种方案：\n\n- 16-8轻断食：限定每日的进食时间跨度在连续的8小时以内，剩下的16小时为禁食期；\n- 5:2轻断食：每周5天进食，2天为禁食日，限制热量在500-600kcal；\n- 6:1轻断食：类似于上一种，但每周6天进食，1天禁食；\n- 隔日断食法：每隔1天就禁食24小时，但不限制饮水及其他无热量饮品的摄入。\n\n\nMark Mattson博士在文章中指出，一系列动物和人类研究表明，间歇性禁食的许多健康益处不仅仅是减少自由基产生或减轻体重，还会引发进化上保守的适应性细胞反应，也就是说会触发代谢转换机制，有利于细胞健康。细胞健康了，对多种慢性疾病就具有强大的疾病修饰功效，体现在改善葡萄糖调节、降低氧化应激以及抑制炎症等。此外，间歇性禁食还会降低血压、改善血脂水平，产生的酮体刺激脑源性神经营养因子基因的表达，对大脑健康以及精神和神经退行性疾病有益。\n\n# 饮食\n\n进一步研究表明，在所有的饮食模式中，全因死亡率风险最低的饮食方式为：10-30g高纤维、14-30%蛋白质、10-25%单不饱和脂肪酸、5%-7%多不饱和脂肪酸以及20%-30%淀粉摄入。\n最优能量来源配比：<24%淀粉，15%-17%蛋白质，>15%单不饱和脂肪酸，<15%糖，6%饱和脂肪酸，6%多不饱和脂肪酸，30g+高纤维","n":0.316}}},{"i":158,"$":{"0":{"v":"Spice","n":1},"1":{"v":"\n2017年Plos One 的另一项来自美国的研究以16179名，年龄在18岁以上的人群为对象，并对其进行了高达19年的随访，发现在4946例死亡患者中，食用辣椒的参与者的全因死亡率为21.6％，而未食用辣椒的参与者的全因死亡率为33.6％。相较于不吃辣或很少吃（少于每周两次）的人群，每周吃辣＞4次的人群总死亡风险降低23%，心血管死亡风险降低34%。\n","n":0.577}}},{"i":159,"$":{"0":{"v":"Nut","n":1},"1":{"v":"\n通过分析发现，经常食用核桃可以延长寿命，降低心血管疾病死亡风险。比起不吃核桃，每周食用核桃5份以上（1份28克）的健康预期寿命延长1.3岁，全因死亡风险降低14%，心血管疾病死亡率降低25%。\n\n\n研究人员发现，每周吃树坚果低于1盎司份量的人，死亡率降低7％。而每周吃了1盎司份量的人，减少11％的死亡率；每周吃2份量的人，减低13％；每周5至6份量者，减少了15％；一周7份以上的人，死亡率则减少20％。\n\n另外两篇发表在《公共科学图书馆在线期刊》(Public Library of Science Online Journal)和《生物医学中心》(BioMed Central)上的医学预科研究论文，展示了试验开始时的横断面数据。这两项研究都评估了7,216名对象，以及他们食用坚果的频率和数量之间的关系。那些每周食用三份以上坚果(包括开心果)的研究对象的死亡率降低39%。\n\n","n":0.378}}},{"i":160,"$":{"0":{"v":"Meat","n":1},"1":{"v":"\n## 肉类\n\n### 红肉\n\n包括：加工红肉和非加工红肉\n\n（1） 非加工红肉包括：非腌制的猪肉、牛肉和羊肉。简单的来说就是畜肉类，包括猪、牛、羊等的肌肉和内脏。畜肉的肌色较深呈暗红色,故有“红肉”之称。\n\n蛋白质含量一般为10%-20%,牛羊肉含量较高,可达20%;猪肉较低一般为13.2%左右。畜肉蛋白质氨基酸组成与人体需要也较接近,利用率高,含有较多的赖氨酸,宜与谷类食物搭配食用。畜肉类脂肪含量较高,平均为15%,猪肉最高,羊肉次之,牛肉最低。脂肪组成除猪肉外,多以饱和脂肪酸为主。内脏胆固醇含量高于肌肉,其中脑中胆固醇含量最高,一般每100g动物脑中含2400mg以上,其他脏器每100g含有300mg左右,是肌肉中含量的2-3倍。\n\n（2）加工红肉包括：培根、热狗、腊肠、萨拉米香肠、肉酱以及其他腌制类红肉。\n\n### 白肉\n\n禽肉和鱼虾蟹贝肉（1） 禽类经常供人类食用的禽类主要有鸡、鸭、鹅等,以白质含量为16%-20%,其中鸡肉的含量最高。 鸭肉相对较低脂肪含量在9%-14%之间;禽类脂肪酸构成以单不饱和脂肪酸油酸为主，肝中胆固醇含量一般达350mg/100g左右,约是肌肉中含量的3倍。\n\n 鱼虾蟹贝类\n\n 人们平日经常食用的水产动物是鱼虾、蟹和贝类。此类合物高含优质蛋白质,脂类,维生素和矿物质。蛋白质含量为15%-22%;碳水化合物的含量较低,约1.5%; 脂肪含量为1%-10%，鱼类脂肪多由不饱和脂肪酸组成。\n\n## 影响\n\n\n1）增加红肉摄入与死亡风险相关。八年内平均每天增加至少半份红肉摄入（半份红肉相当于14g加工红肉或40g非加工红肉）的调查对象，在接下来八年内全因死亡风险增加10％（HR, 1.10; 95%CI, 1.04-1.17）。\n\n2）加工红肉（如培根、热狗、香肠、腌肉等）与非加工红肉（未经腌制加工的猪牛羊肉）的摄入量增加均与死亡风险显著相关，而加工红肉的效应更加显著。\n\n3）红肉摄入增加与心血管疾病和呼吸系统疾病死亡风险呈正相关。\n","n":0.267}}},{"i":161,"$":{"0":{"v":"Fruit","n":1},"1":{"v":"\n每天摄入200克新鲜水果可使死亡率降低17%，糖尿病大血管并发症（如中风、缺血性心脏病等）风险降低13%，及糖尿病小血管并发症（如糖尿病肾病、糖尿病眼病、糖尿病足病等）风险降低28%\n\nBondonno博士说道“吃不同蔬菜、水果补充，不同种类的黄酮类化合物是很重要的，这很容易通过饮食实现：一杯茶、一个苹果、一个橘子、100克蓝莓，或100克西兰花，就能提供各种黄酮类化合物，并且总含量超过500毫克。\n\n黄酮是一种天然存在于很多植物中的化合物，它们属于一大类被称为多酚的化学物质。黄酮类食物对健康有很多好处，比如可以帮助减少炎症、改善心血管健康，甚至还有助于抗氧化呢！✨\n\n这些食物包括：\n\n- 水果：比如蓝莓、草莓、樱桃、苹果。\n- 蔬菜：比如洋葱、青椒、西红柿。\n- 黑巧克力和可可\n- 茶：比如绿茶和黑茶。\n- 坚果和种子：比如亚麻籽、芝麻。","n":0.408}}},{"i":162,"$":{"0":{"v":"Egg","n":1},"1":{"v":"\n每天多吃半个蛋，增加7%的全因和心血管死亡风险？在假设性替代分析中，研究者发现，用等量的蛋清/鸡蛋替代物、家禽、鱼、乳制品、坚果和豆类分别替代半只全蛋（25克/天）可以降低6%、8%、9%、7%、13%和10%的全因死亡率。","n":1}}},{"i":163,"$":{"0":{"v":"Drink","n":1},"1":{"v":"# drink\n\n## 乳制品\n\n与不食用乳制品的人相比，每天摄入两份乳制品（一份指244克牛奶/酸奶，15克奶酪或5克黄油）的人，全因死亡风险下降了17%，心血管死亡风险下降23%，中风风险下降33%\n\n## 茶\n\n纳入分析的438 443例研究对象随访11.1年共发生死亡34 661例。与从不饮茶者相比，当前非每日饮茶者和每日饮茶者全因死亡HR值（95%CI）依次为0.89（0.86-0.91）和0.92（0.88-0.95）。分性别分析显示，饮茶对全因死亡风险的保护作用主要见于男性（交互P<0.05）\n\n## 无糖饮料\n\n相比于软饮料摄入量＜1杯/月的参与者，混合软饮料摄入≥1杯/天的参与者死亡风险增加18%，而摄入含糖软饮料或无糖软饮料会令死亡风险分别增加11%和27%。\n\n## 有糖饮料\n\n每天1杯含糖饮料增加7%全因死亡率，2杯21%\n在34年的随访中，研究人员发现，相比那些一个月喝1杯或者更少含糖饮料的人，每天喝2杯的人总体死亡风险升高了21%，心血管疾病死亡风险升高了31%，癌症死亡风险上升了16%。\n只要每天多喝一杯含糖饮料，总体死亡风险将增加7%，心血管疾病的风险将增加10%，癌症相关的死亡风险将16%。\n发表在国际顶级期刊《BMJ》上的一篇论文就证明了含糖饮料会在增加患癌风险，当然这篇文章验证的不仅仅是果汁，奶茶也有份——和含糖饮料相关的总体患癌风险要高出通常值18%，100%的鲜榨果汁也会使得整体的患癌风险上升12%。\n\n- 每天多摄入一份12盎司的含糖饮料，全因死亡率风险增加11%；\n- 每天多摄入一份12盎司的果汁，全因死亡率风险增加24%。\n\n## 咖啡\n\n咖啡摄入量与各种原因的死亡率，CVD和癌症死亡率之间存在非线性关系，每天摄入两杯咖啡的癌症死亡率最低(RR = 0.96)，CVD最低的死亡率，每天2.5杯(RR= 0.83)，全天最低死亡率为每天3.5杯(RR= 0.85)，并且随着咖啡消费量的增加，死亡率没有进一步降低或增加","n":0.258}}},{"i":164,"$":{"0":{"v":"French","n":1}}},{"i":165,"$":{"0":{"v":"China","n":1}}},{"i":166,"$":{"0":{"v":"Cooking","n":1}}},{"i":167,"$":{"0":{"v":"Communication","n":1},"1":{"v":"\n# 分享\n\n- 经常主动地分享知识和资源，并且不求回报，这是大有裨益的。\n\n# 朋友\n\n- “接触老朋友是建立联系的有效方式，你已经了解这些人，所以这并不难，”巴克说。 “那些人可以向更多人介绍你。”如果您想与某人保持朋友关系，请至少每两周一次建立一次联系。制作和保持朋友需要时间，最好的方法是将它放在你的日历上\n\n# 两性\n\n女性的沟通是隐蔽的，男性的沟通是公开的。男人传达信息，女人传达感觉。在涉及信息时，男性优先考虑内容，女性优先考虑背景。在过去的四分之一个世纪里，女性化所造成的一个巨大的混淆是这种期望，即女性和男性一样理性，一样倾向于分析解决问题。这是一种平等主义心态的结果，它误导男性相信女性的沟通方式与男性没有区别。这并不是要贬低女性本身是精通问题解决的人，但它违背了女性如何设定一个专门的女性沟通形式。\n\n你不需要通灵来理解女性的隐秘交流，你需要的是观察力。这往往需要一种大多数男人根本没有的耐心，所以他们把女人写成两面派、善变或纵容，如果这个名字适合的话。隐蔽的交流使我们感到沮丧，就像公开的交流使妇女感到沮丧一样。\n\n只要女人仍然是不可知的、随机的、非理性的生物，男人不可能希望理解（但总是可以原谅），她们就可以不受阻碍地实现她们的目标。\n\n女人享受交流的过程，而不是被传递的信息。这不是一个需要解决的问题，主要是沟通。当一个傻瓜一下子向她提供所有的东西时，我们会想，是的，神秘感消失了，他不再是一个挑战，她为什么会感兴趣？这是真的，但好奇心消失的原因是没有更多的潜力来刺激交流的需要或她的想象力。\n当女人为她们的目的服务时，她们并不排斥使用公开的交流方式。\n\n用你的行为进行沟通。永远不要公开地告诉女人任何事情。让她自己得出你想要的结论。她的想象力是你游戏工具箱中最好的工具。学习如何使用它。\n\n这是一般受挫的笨蛋的最大失败：他们把自己的一切都吐出来，把自己的全部真相透露给女人，错误地认为女人渴望这种真相，作为他们亲密关系或持久承诺的资格基础。学习\n\n女人永远不希望完全披露。间接沟通是有效游戏的基础。","n":0.378}}},{"i":168,"$":{"0":{"v":"Story_telling","n":1},"1":{"v":"\n1：细节。一个故事要让他听起来像是真的，必须得有细节。比如：“我躺在床上，被子都没有盖（细节）。然后拿出手机瞄了一眼，我还清楚的记得那时候是凌晨3点15分（细节）。接着我翻了一个身。。。。。。”\n\n\n2：展示价值（可选）。故事是最好的让人了解你的方式。比如你想要让对方知道你很有钱。你可以直接的说：“我是个土豪。”\n\n当然你也可以讲一个故事：“我最近惨死了，前两天车被别人撞了一下，今天他打电话给我让我去签一份协议。我心想，修个车还签什么破协议。结果我一看，上面写着如果部件在运输过程中遭到损坏。要自行承担。我那个时候才知道，这破车的零件只能从意大利进口。国内买不到。哎，苦逼的我这几个月没车开了。”\n\n\n如此，别人自然知道你开的是好车。而且很有钱。\n\n\n3：起伏。平淡的故事没有人爱听。这就需要你有一定编剧的能力。如果没有，那不妨讲出来之前先编排好吧。\n\n举个例子：“你知道吗？昨天有个妹纸咨询我，她说她男朋友的那里太小，只有牙膏那么大。我一听就怒了。和她说，你别天真了好么？有牙膏那么大已经很大啦！！结果她弱弱的说，你见过宾馆的牙膏么。。。。”\n\n\n\n4： 创造世界画面，背景。这就像是在布景，你的故事最好需要有画面感。不然人们会索然无味。很多小说可以很好的做到这一点。\n\n比如：“二楼的空间并不大，零零散散的摆了几张桌子。余光告诉我，有几个身材火辣的美女正坐在这里吃饭。我没敢抬头扫视四周，默默的跟在哥们后面走到一个空餐桌面前坐下。\n\n　　坐定之后我抬起头。在我的斜对面，两点钟方向有一桌三个女生组成的小团体。其中一个女生面对我。\n\n　　作为一个心理健康的死娘炮，我惯性的瞄了她几眼。\n\n　　黄色的中分，很平顺。一身清凉至极的露肩装。露出圆润滑腻的珍珠肩。两条大长腿白的反光。脚底穿着一双透明彩丝带的玻璃凉鞋。足踝浑圆线条优美，十个脚趾头上丹蔻朱红，抹着鲜艳的指甲油。”\n\n\n\n相信你已经可以想象到小说想要描述的画面了。\n\n\n\n5：加入感情。一个好的故事没有一个好的述说方式也是行不通的。试想，如果机器人瓦力没有感情，它大概不会有那么多的粉丝。\n","n":0.707}}},{"i":169,"$":{"0":{"v":"Presuade","n":1},"1":{"v":"\n1. feature\n2. advantages\n3. benefit","n":0.5}}},{"i":170,"$":{"0":{"v":"Presentation","n":1},"1":{"v":"\n1. Stick to what you know. Presentations fail when you try to present yourself as an expert on something you aren’t.\n2. Tell stories, and don’t bother scripting them. Stories are easy to remember so you won’t mess them up. Script your transitions, and you’ll be set.\n3. Practice more than you think you need to. Long, boring practice is what sets professional speakers apart from amateurs.\n4. Chunk your speeches. Don’t get stuck thinking you have to work through it in a linear fashion.\n5. Slow your brain down. When your brain is moving too fast, you start to stumble on your words.\n6. Don’t wander. The temptation to step off the trail will be high. Once you do, it will be difficult to come back.\n7. Always save a few moments for your pre-talk calming routine. Never go on stage without doing this first.\n8. Ignore your mistakes. Context is more important than perfect delivery. If you mess up, keep going.\nRemember the audience wants you to succeed. Everything is easier when you remember everyone is on your side.","n":0.076}}},{"i":171,"$":{"0":{"v":"Logic","n":1},"1":{"v":"\n![](/assets/images/2021-05-03-21-59-25.png)\n\n![](/assets/images/2021-05-03-21-59-33.png)\n\n![](/assets/images/2021-05-03-21-59-44.png)\n\n![](/assets/images/2021-05-03-21-59-51.png)\n\n![](/assets/images/2021-05-03-21-59-58.png)\n\n• 壹：列你想说的东西\n• 写下你的目标，是影响思维，还是影响行为，具体是什么\n• 写下你的对象关心的东西，浓缩成你的论点（把没有的都删掉）\n ","n":0.5}}},{"i":172,"$":{"0":{"v":"Phone","n":1},"1":{"v":"\n打电话时说的第一个字：\n喂 第二声\n\n打电话时的第二句话：\n您现在说话方便不？\n\n打电话时尽量少说口头语：\n不用 嗯 啊 哦 用是的，好的，明白\n\n重要的事项学会复述、确认：\n您刚才说的这几点，不知我理解的对不对\n\n等着对方先挂电话：\n\n耐心等\n    \n轻轻挂","n":0.378}}},{"i":173,"$":{"0":{"v":"Listener","n":1},"1":{"v":"\n绝大多数时候，人们闲聊的最大驱动力并不是想交流意见拓宽思路。他们只是想表达自己。进而求得认同。\n\n# 倾听者的需求\n\n第一个方法，就是了解你说话对象的需求，这个就是所谓的情商，知道别人要什么。\n\n第二，了解人类的共同需求.其实我们是一样的，有一些需求是人类的共同需求。比如我们需要被人爱，需要安全感，这些都是我们需要的东西，所以两种情况出发，可以帮助你去思考对方需要什么。\n\n感受得到越多，情绪的传达和接收就越容易到位\n\n# 换位思考\n\n\n第一个方法，叫做**观察自己觉得厌恶跟不舒服的时刻**，大部分人都是正常人，你身上有一部分是人类共性，你要学会观察自己，就是别人跟你说什么话的时候，你会觉得特别不爽。别人开什么玩笑，你会特别难堪，这些你都应该记下来，大概需要记多久，其实半年到一年的时间，就可以了。\n\n比如你从 20 岁开始，有意识做这件事情，你记到 21 岁就会发现，在这一年当中，你就会把一个人在说话上所能遭受的不舒服情况遇个差不多，在以后的人生当中，不过是重复这些场景而已。\n\n所以你要学会去观察跟记录自己觉得厌恶、不舒服的时刻，然后记得这些话是你绝对不能跟别人讲的，这是换位思考的第一个方法。\n\n第二个方法，就是**通过提问和反馈**。其实很多时候，对方的需求是可以直接问出来的，你大胆去问就可以。很多时候你不正面问，靠猜，就越猜越错，话越说越错。\n\n而且更多时候，你要去观察对方的反馈，你不要怕说错话，说错话了对方给你一个不好的反馈，你就记得下一次不要这么说，所以你要把对方的反馈给记下来“我这次跟别人开了一个玩笑，感觉别人特别不开心，那么以后这个玩笑，我绝对不可以再开”。\n\n\n第三个方法，就是**收集第三者证据**。平时你会看到很多人发朋友圈，也会看到你的朋友发微博，他们会在朋友圈跟微博当中吐槽很多，他们在生活当中不舒服的时刻，甚至你会看到一篇文章会吐槽作者跟他朋友之间的一些事情。\n\n其实这些都是你应该注意起来的，就是说什么话，别人会不高兴，通过这三方面的收集，收集自己觉得厌恶、不舒服的时刻，去提问和收集对方的反馈，收集第三人的证据，通过这种收集下来，你会发现你真的不会说太多令人不舒服的话了，你的情商真的会提高。\n\n## 方法\n\n当我们可以展开讲讲，别人就更容易站在自己的角度去想象和思考\n而不是翻来覆去的，只有简单描述和抱怨的时候\n\n就不会满脑子疑问——“所以呢？”\n可以知道关键的细节——“原来是这样！”\n\n当我们可以让别人展开讲讲，我们就可以更好地理解对方的情绪\n而不是只有简单的回应和等待\n\n就不会满脑子疑问——“这有什么好说的？”\n可以从更丰富的细节中找到共鸣——“对对对，就是这样”","n":0.354}}},{"i":174,"$":{"0":{"v":"Hard","n":1},"1":{"v":"\n# 艰难的对话\n\n\n## 批评别人的话\n\n第一个步骤，让对方先说，你为什么会这么做？你当时是怎么想的？\n\n先让对方充分去说原因、理由跟做事过程，说完了之后，你从中挑出不对的环节做个替换。比如「你朋友不开心，你不一定要陪他去网吧，你可以陪他去打球的。你为什么一定要在网吧彻夜不回，这样让大家都很担心。」\n\n你可以通过他的充分陈述，抓住其中的错误环节。第二个步骤，给出建议和替代的方法。\n\n最后一个步骤，对他表达出期待，这个方法可厉害了，就是你批评完他之后「你不应该这么做，你应该那么做」。然后你对对方表达出你的期待「我之所以这么说，是因为我对你太看好了，我觉得你一定能够做好的。」\n\n这种话非常有魔力，通过我们这样批评别人，第一个步骤，让对方去做充分陈述；第二，找出错误环节做出建议，给出替代的方法；第三，表达对对方的期待。\n\n通过样三个步骤，你就会把一个本来会让别人不高兴的批评，变成一个让别人听了之后感觉不错，甚至感觉很好，并且自愿去改正的一段话。\n\n## 反对\n\n我们反对一个人，人家肯定是不会开心的，人家肯定不会欢迎你反对他，很少有人真心实意喜欢被别人反对他，反对的话应该怎么说？\n\n两个步骤，第一个步骤，先合理化对方的感受；第二个步骤，从自己的经历和角度出发，再去提反对意见。 \n\n举个例子，比如 A 跟她男朋友吵架了，决定回去把她男朋友给砍了，然后你反对这么做。\n\n你记得先去合理化对方的感受，千万不要把他的行为给合理化。如果人家做这个行为是合理的，那你就不好反对了，所以你先去合理他的感受「你的男朋友那么过分，所以你这么愤怒」。\n\n接下来讲：「在这样一个愤怒的情况下，你这么想，我是理解的。」合理化对方的感受。就是对方提了一个方案，你不同意，然后你应该说「从你的经历出发，能提出这个方案，我觉得是很合理的。」把它变成一个主观合理的东西。\n\n这是我们做的第一步，就是从主观上先合理对方。\n\n你再从自己的经历跟角度出发，去提出反对意见「我反对你，并不是说你就是错的，你说的话都是没用的，只是说从我自己的经历，从我自己所见过的证据来说，这样做更合理。」\n\n其实这样的反对，对方就比较容易接受了，因为被反对的时候，最痛苦的就是你认为我说的话都是没用的，因为你的才是会被采用的，你觉得你说的才是对的。\n\n所以我们在反对的时候，其实最重要的一个步骤，就是从主观上，去合理化对方的观点，而且我们也向对方表达了「我反对你，并不是因为我代表正义，代表正确，而是从我自己的经历跟角度出发，我觉得这样的观点，或者这样的解决方案，可能更好一些。」\n\n以上，就是反对的话应该怎么说。\n\n## 说服\n\n你说服一个人，对方也会不舒服的，没有人喜欢被说服，因为说服就意味着对方是弱势的，对方被你征服了。\n\n所以说服别人有快感，但是被说服的人没有快感，那我们应该怎么说服别人？两个方法。\n\n第一个方法，先让一步，再进一步。\n\n比如你希望别人 100 块钱买你这个东西，你上来先不要提 100 块，你先提 120 块买不买，然后对方直接把你给拒绝否定了，你再去提 100 块，对方这时候答应的概率就会增大。\n\n所以在日常生活当中，我们想说服一个人的时候，先让一步，让对方去否定你一次，让他获得快感，然后你再进一步去征服对方，这样的话，他的感受就不会有那么差了。\n\n还有说服的时候，要按照三个环节去说服，我们要先讲道理，再讲利益，最后讲情感，以情感结束是最好的，因为以情感结束，对方的痛感最低，如果你以道理结束的话，对方就会觉得「我被你说服，岂不是因为我没有道理」。\n\n所以大家明白这个顺序的意义，就是先讲道理。再讲利益，最后讲情感。 \n\n## 请求\n\n我请别人帮我一个忙，那我等于是让别人付出，我这句话并没有给对方什么价值，就让对方来帮我去扫地，这时候应该怎么说，把请求变成一个价值很高的话？\n\n首先，你绝对不能用祈使句，我们讲了，你说的这句话「你帮我扫地」对对方来说，一点价值都没有，你还用祈使句，那岂不是对方会讨厌死你吗？应该怎么说？三种方式，可以把请求变成一个价值很高的话。\n\n第一种方式，叫做如果你要这么做的话，会出现什么好的结果。\n\n「如果你可以帮我扫扫地的话，我们家一定会特别干净的，我们俩在里面肯定会特别开心的。」\n\n这是第一种说法，叫做如果你要这么做的话，出现的好的结果是什么。\n\n第二种请求的方式，叫做非你不可，只有你能帮我扫地，别人都不行。\n\n这种非你不可的感觉，也会让对方得到满足，也会给对方提供价值，所以这个方式也是可以用的。\n\n还有第三种话，当然就是感谢，提前把你的感谢说出来「帮我扫地，谢谢你了。」其实等于是你把有价值的话，附加在没价值的话上了，也会让你的请求变得好一些。\n\n这是请求的三种方式。\n\n## 安慰\n\n安慰风险可高了，如果你比对方好，一场考试你考好了她没考好，你去安慰她，这个风险特别高，你很容易引起对方的消极感受。\n\n即便你没有比对方好，由于被安慰的人，一般是处于一个情绪不稳定的情况之下，你不知道他要什么，而且他的感受可能一会这样，一会那样，很难满足他的需求，很难给他提供价值的。\n\n所以安慰本身是一个风险很高的话，大家千万不要随便去安慰别人，觉得我安慰你，我是来给你提供价值了，我怎么就不能随便说了。不行的，安慰风险很高。 \n\n我们在安慰的时候，应该注意什么？\n\n第一，不要上来就分享自己的经历跟感受，很多人安慰别人的时候，喜欢讲：「你这个情况，我也遇到过」，然后了 15 分钟，这样会让对方感受特别差。\n\n因为他失去了注意力，他的痛苦是需要被关注的，如果他失去了这种关注的话，他会不开心。\n\n所以安慰别人的时候，最忌讳的就是上来讲一大堆自己的经历跟感受。\n\n第二，不要上来就提建议。因为安慰的人处于一个很弱的心理水平，如果你上来就给他提建议的话，他就进一步觉得自己很弱，感受很不好，好像你行，我不行一样，所以上来不要去提建议。\n\n第三，就是一定要去肯定跟支持对方的感受，这种话是永远不会出错的。 \n\n比如对方离婚了，很伤心，你应该去支持对方的感受：「遇到这种情况，肯定是会伤心的，我觉得你这个伤心是无可厚非的，肯定会特别难受，换了谁不难受。」这种话就叫做肯定跟支持对方的感受。\n\n在安慰别人的时候，最容易犯什么错误？忽略对方感受。\n\n我给大家讲两种情况，你就能感受到一个人在安慰别人的时候会犯什么错误了。\n\n比如 A 家的小狗丢了，B 就跟他说：「不是什么事，没关系。」我们安慰别人的时候，是不是经常说「没关系」，但「没关系」这个话其实特别冒犯别人。\n\n「怎么就没关系了？我的感受就那么不应该？我就是觉得这个情景下应该难过，你告诉我没关系？」\n\n其实「没关系」这种话，都是没有支持对方的感受，会让人不舒服。所以「没关系」这种话我们是不能说的，我们一定要学会肯定跟支持对方的感受。\n\n还有一种情况，就是别人考不好很难过，你上来跟别人讲：「考不好不应该难过的。」你没有说「没关系」，你跟别人讲「不应该难过，应该开心，因为考不好你才知道自己什么地方有问题，才能改正进步。」\n\n这种比「没关系」更严重，直接点出了不应该，这两种情况都会引起别人的消极感受。\n\n所以我们在安慰别人的时候，**一定要学会肯定跟支持对方的感受「你此刻的情绪，都是对的，都是应该的。」这样的话，他会觉得很安慰**。\n\n还有最后一个方法，如果你真的不知道说什么，你不妨在行动上关心她。「我也不知道说什么，那我就去帮你买点吃的。」\n\n所以这也是一个很好的方法，也是直接提供价值的一个方法。\n\n这是第五种风险高的话应该怎么说，叫做安慰。\n\n## 拒绝\n\n拒绝别人，肯定是风险很高的，肯定是不提供价值的，肯定别人是不爱听的，应该怎么做？\n\n第一个步骤，理解对方的困境：「我知道你现在遭遇了经济上的困难，这时候肯定需要借钱。」\n\n第二个步骤，如果可能的话，找出拒绝他之后对他好的方面。\n\n比如「你这次来找我帮忙，我觉得不应该帮你的，因为我要帮你的话，你在这个方面永远都学不会自己应该怎么做，我觉得你这时候应该自己解决这个问题，这样的话对你更好。」\n\n但是这种话，对方一般都不接受，没关系，上来就来第三个步骤了。\n\n第三个步骤，告对方什么情况下，自己一定会提供帮助。\n\n「如果你下一次还解决不了这个问题的话，我一定会帮你的。」或者说：「借钱这个事我帮不了，但是如果你需要人的话，我一定去。」\n\n这样的话，你的拒绝就等于在最后又为对方提供了价值，不会让对方那么难以接受了。\n\n这是三个步骤，第一，理解对方的困境，对方来找你帮忙，其实他是把自己的姿态放低了，所以你要理解他的困境，帮助他把这个姿态给提高上来「一般人碰到你这个问题，都会来找人帮忙」。第二个步骤，拒绝之后，找出对他好的方面，如果可以的话告诉他。第三个方面，表明自己在什么情况下，一定会提供帮助。\n\n在这，我们需要注意一点，就是你一定要强调出自己的不变。很多时候，你拒绝别人说的很模糊，这种模糊会让对方觉得，你本来是可以帮他的，就是不帮他。\n\n所以在这三个环节之前，或者在最后一个环节之前，你要找出一个机会去强调自己哪里不方便，所以才不帮他的。一定要清晰地说出自己不便的状况，一定要说，不说的话效果不好，说出来之后，你再可以说最后一步，我现在不方便，什么情况下一定会帮你的。\n\n还有一种方法，就是我不告诉你在什么情况下一定会帮你，但是我可以找出其他的解决方案，帮你解决这个问题。 \n\n比如我有朋友来找我借钱，我有自己的不便之处，我告诉他我确实不能借这个钱，然后我给他介绍了一个做小额贷款的朋友，其实这也是帮他找到了解决办法。\n\n这种拒绝也没有那么难受，因为拒绝本身是非常伤人的，如果你不想失去这个朋友的话，一定要有拒绝的智慧，因为本身别人就是把姿态放低了，来找你帮忙，然后你还把他拒绝，等于进一步把它的姿态再踩下去。\n\n所以如果不处理好拒绝的话，是很影响感情的。\n\n","n":0.189}}},{"i":175,"$":{"0":{"v":"Gift","n":1},"1":{"v":"\n真诚第一原则！！\n\n送礼物的原因\n\n\t1. 把感情具体化的一种方式，是个愉悦的过程\n\t2. 送礼物的人看重礼物的交换价值\n\t3. 收礼物的人看重礼物的实用价值\n\n错误的做法\n\n\t1. 惊喜，希望意想不到，没有十足的把握不要送惊喜\n\t2. 鲜花是即使享受的礼物，收到的满足会稍纵即逝，\n\t3. 实物，价值交换，可能被替换，容易被忘掉\n\t4. 反映对方特点，没必要，送礼品卡也是一种选择\n\t5. 手工制作，准备时间长，时间成本大，但是收礼物的人不会理会，\n\t6. 酷的，其实只是满足自己的需求而已\n\t\n正确的做法\n\n\t1. 相对贵的，简单直观感受到价格\n\t2. 不舍得买，超过自己消费能力的。从个人的愧疚变成享受\n\t3. TA需要的（购物车里的） 不是我需要ta有的\n\t4. 长期价值的礼物（菜谱..）\n\t5. 体验类的礼物（外餐，郊游，影响深刻）\n\n提高礼物的附加值\n\n\t1. 很难去的地方\n\t2. 告诉对方礼物的来由，你挑选礼物的原因\n","n":0.236}}},{"i":176,"$":{"0":{"v":"Empathy","n":1},"1":{"v":"\n“你是不是感觉 。。？”\n\n1. 认同情绪 > 分析事实\n2. 不要辨析行为或情绪的对错，而是帮她把她难过的点讲出来\n3. ","n":0.408}}},{"i":177,"$":{"0":{"v":"Chat","n":1},"1":{"v":"\n1. 态度   友好的沟通态度  看对方的反应 想社交的心态\n2. 情绪    释放自己的情绪  表达别人可以接受的情绪  寒暄之后表达情绪（夸张的语言表达情绪）\n3. 想法  表达内心对于事物的看法\n\n# 技巧\n\n1. 提醒自己要多发问——发问是会聊天的一种手段吧。即使在讲自己的故事，多说”你觉得呢？“ ”换你你会这样做吗？“也会让别人更有参与感，更加舒服呢。这样也避免了自己非常傻的滔滔不绝……\n2. 即使再不认同对方，永远也不要在对话中出现讽刺和挖苦\n3. 沉默是好事，沉默是金，好好享受它。\n4. 愿意聊天的人总喜欢把话题说得更具体，而不想聊天的人则会顺着话题的方向直接概括出结论，言下之意是“我已经都知道，你不用再多说。”\n5. **下切、具体细节、表达感受、描述问题、关注过去、对照眼前、罗列现象、就事论事、开放肯定、忘却目的**、活在当下、以自我为标准。\n\n\n# 错误\n\n## 连续提问\n\n\n导致连续提问有两个原因：\n\n其一，有些男人遇到喜欢的女孩，想尽快投其所好，于是就开启提问模式，像猎人发现了猎物马上就收集猎捕信息。\n\n其二，试图用提问来逃避无话可说，我问你答短暂产生了聊得不亦乐乎的错觉。\n\n\n但实际上，连续提问是在透支社交的耐心和礼貌。正常的聊天应该是你来我往、互通有无的，你可以向别人索取信息，但也应该向别人提供信息。尽管在对话刚开始的时候人家可以出于礼节向你单方面提供一些信息，但如果你总是没有回馈，这就打破了社交的平衡，对方就会觉得跟你聊天不舒服。\n\n要想避免这个问题，可以在每次对方回答了你的问题之后，你都给予一定的响应（即自己在这个话题上的相关信息，状态或感受）\n\n## 不说自己\n\n聊天的主要作用应该是让双方互相了解，但很多男人都认为自己的生活没什么值得说的，他们更喜欢谈论对方或者第三方。虽说这样也不是不能展示自己，比如你有独特的表达方式，但能达到这个境界的人毕竟凤毛鳞爪。\n\n正确的做法是在回答时多用状态+感受\n\n## 情感过度\n\n情感过度就是你在聊天中传递出来的情感超出了你们现有关系，从而让对方觉得别扭。\n\n\n情感过度的表现形式分为两种，一种是过于细致琐碎的状态表达，比如我今天做什么吃什么买什么看什么，事无巨细唠唠叨叨，但你忘了别人也许对这些根本不感兴趣；一种是过分强烈的感受表达，比如男孩对一个刚刚认识的女孩说“今天满脑子想的都是你”，但他意识不到女孩可能会因此觉得尴尬。\n\n情感过度的原因有两点：1，追求表达的极致效果，恨不得每句话都一语惊人直捣芳心。2，对真诚的错误理解，认为真诚就是把自己做的和想的毫无保留地告诉对方。但人际关系是在平衡中的推进，单方面的冒进反而会破坏稳定\n\n## 随意评价\n\n随意评价包括对别人的情绪、意愿、能力、性格、角色进行不由分说的主观判定，产生的原因往往是当事者为了说出有趣的话题，自己先去设定一个前提，然后再想象伸延去表达一个意义。但问题是这个前提常常与事实不符，并且还是指向对方的，这就给别人自以为是的感觉。\n\n“用客观事实淡化主观意愿”，讲一些客观事实。 而随意评价的人干的事情就属于——“用主观判断覆盖客观事实”，正好是反其道行之。","n":0.204}}},{"i":178,"$":{"0":{"v":"Humor","n":1},"1":{"v":"\n## 小技巧\n\n1. 情景带入\n   1. 想象彼此在某个场景里进行对话，就像电影里的情节一样\n   2. 情景触及+联想表达\n2. 歪曲意思：故意歪曲给人出其不意的感觉\n3. 故意夸张：表达的时候将事物的特点夸大，让人觉得很有趣\n","n":0.333}}},{"i":179,"$":{"0":{"v":"Body","n":1},"1":{"v":"\n1. 手放在嘴中间：我不买账，不想听你说\n2. 女性把手放脸边，45度，assessment behavior 看你说的对不对\n3. 握手时升高音调，表明欺骗\n4. Cheat wife: 表现的比平时更好\n5. 女性听靠视觉，男性听靠听觉，一般并排坐：靠近男性有一定的角度，靠近女性direct\n6. 握手\n    a. 伸手\n    b. Use direct eye contact\n    c. Show your teeth, smile\n    d. Give verbal greeting\n7. 握手的时候左手比较积极，运动：表达喜欢\n8. 倾听：tell me about yourself, tell me more about yourself\n9. Head nodding: 男性表示同意，女性只是表达理解，不一定同意\n10. Head tilting better listener\n11. 二郎腿，如果男性之前坐，后来放下，说明达成协议机会很大\n女性坐在椅子上，往前坐，说明有兴趣","n":0.149}}},{"i":180,"$":{"0":{"v":"Stand","n":1},"1":{"v":"\n# 站位\n==\n\n获取左侧优势    \n\n当两位领导人并肩站立，面对媒体摄影时，无论是从身材体型而言，还是从服饰穿着来说，他们都希望自己能够与对方平分秋色。然而，在旁观者看来，权势的天平却总是偏向于画面左侧的那位领导者。在旁观者看来，权势的天平却总是偏向于画面左侧的那位领导者。导致这一现象的原因就在于，画面左侧位置上的领导人在握手的时候能够更加轻松地以强势的握手方式压制对方，获得控制\n\n![](/assets/images/image80.png)\n\n# 脚\n\n\n腿部动作主要服务于两种目的：一是向前走以获得食物，二是在遇到危险时逃跑。由于人类的大脑直接关联着这两种基本目的，走向自己想要的东西和远离自己讨厌的东西，所以人们的双腿和脚部能够显示他们内心的动向。换句话说，通过观察别人的腿部，你就能知道对方到底愿不愿意跟你继续交谈。不互相交叉或者大幅叉开的双腿展现出一种开放的姿态，或是处于支配的地位；而交叉的双腿则显示出一种保守的姿态，或是没有把握的态度。  \n\n1. 立正的姿势\n\n这是一个非常正式的站姿，显示出一种中性的态度，不表达任何或去或留的倾向。在异性间的面谈中，女人比男人更常使用这个姿势，直立紧闭的双腿传达出“不置可否”的信号。\n\n![](/assets/images/image39.png)\n\n2.  双腿叉开    \n\n正如前面所提到的，这是一个传达支配意味的动作，属于非常典型的男性身体语言，如同展示胯部的站姿。这个站姿会把双脚坚实地踩在地面，仿佛在清晰地告诉别人，自己毫无离开的打算。展示胯部的站姿之所以成为典型的男性姿势，是因为这个动作能够强调男性的生殖器官，而这一点使得这个站姿显得颇有男子气概。\n\n![](/assets/images/image81.png)\n\n3.  稍息的姿势    \n\n稍息的姿势：伸出的脚尖所指向的方向，就是内心所向往的地方   把身体的重心放在一侧的臀部和腿上，这样就能让另一只脚伸向前方，稍作休息。这个姿势非常有助于我们判断一个人当下的打算，因为人们伸出的脚尖所指向的方向，往往就是他们内心里想要去的地方，而且，这个姿势看起来也就像是一个人正要准备迈步的样子。如果是和一群人在一起聚会，我们伸出的那只脚，总是会朝向最幽默或是最吸引我们的那个人；但是如果我们想要离开的话，那只脚就会朝向离我们最近的一个出口。  \n\n![](/assets/images/image84.png)\n\n4.  双腿交叉\n\n双腿叉开的姿势展现出开放或者支配的态度；双腿交叉的姿势则显示了保守、顺从或是戒备的态度，因为这种姿势象征着拒绝任何人接近自己的生殖器。  \n\n![](/assets/images/image42.png)      ![](/assets/images/image44.png)\n\n剪刀型站姿：表达“不置可否”的态度，但并不打算就此离开对于女人而言，剪刀型站姿或是单腿交叉（一条腿保持直立，另一条腿弯曲与直立的腿形成交叉）的站姿传达出了两个信息：第一，她会继续待在原地，没有离开的打算；第二，持有拒绝接近的态度。不过，如果是男人做出这样的姿势，虽然同样意味着留在原地的想法，但同时还表达出另一个意图：希望对方不要攻击自己的弱点。叉开的双腿是为了凸显男人的雄性气概，而交叉的双腿则是企图保护男人的雄性资本。如果一个男人在和另一个男人会面时，觉得对方不如自己强悍，那么展示胯部的站姿就显得非常合适；可如果他是和一个比自己强悍的男人打交道，这样的站姿就会让他显得争胜好斗，而且他自己也会感觉容易受到对方的攻击。研究显示，\n\n# 腿\n\n\n坐着的时候把一条腿轻巧地放置在另一条腿上。在商务交际中，如果一个人在坐着的时候双臂和双腿都保持交叉状态，那么他就会倾向于使用短句，对他人的建议也更多地持否定态度，而且对于大家所讨论的细节问题会有些漫不经心。大约有 70 ％的人在做这个动作时，是将左腿放置在右腿上。\n\n男人在摆出这种坐姿时，不仅能体现自己的自信和支配地位，同时也能显得放松和年轻。可是，在中东和亚洲的某些地区，“4字腿”的坐姿却被视为对他人的一种侮辱，因为这种姿势会将鞋底展示在众人眼前，而人们在行走的时候难免会让鞋底沾上污垢。  \n\n![](/assets/images/image14.png)\n![](/assets/images/image10.png)\n\n大部分人在做出重大决定时，都喜欢保持双脚踩在地面的姿势，所以当别人的坐姿是“4字腿”时，最好不要立刻要求他做出决定。    \n\n![](/assets/images/image1.png)\n\n用手固定住“4字腿”的姿势，表明这个人是一个特别有主见而且相当顽固的人，他不会认同任何人的观点，只会相信自己。  \n\n# 脚踝相扣  \n------\n\n![](/assets/images/image41.png)\n![](/assets/images/image4.png)\n\n男人在做出脚踝相扣的动作时，双手通常会紧握拳头并置于膝盖上，或者是紧紧抓住椅子的扶手，同时还会摆出展示胯部的姿势（如下图所示）。而女人在脚踝相扣时，身体动作略有不同：她们会把双膝并拢，两只脚置于身体同一侧，双手并排或是交迭着轻轻放在位于上方的那条腿上。\n\n这个动作显示出他正在努力抑制某种消极情绪，也许是缺乏把握或者是恐慌害怕。这个动作显示出他正在努力抑制某种消极情绪，也许是缺乏把握或者是恐慌害怕。\n\n且发现大部分应聘者在面试的过程中，都曾经做出过脚踝相扣的动作。这就说明，当做出这一动作时，他们正在尽力抑制自己的某种情绪或是态度。尼伦伯格和卡莱罗发现，在政治谈判中，如果某位政要做出脚踝相扣的动作，那往往意味着他已经有了给以重大让步的打算，但仍然在竭力克制自己做出这一决定。他们指出，这个时候只要掌握恰当的提问技巧，很可能就会诱导这位政要松开自己的脚踝，并最终做出让步。  \n\n通过提出积极的问题引导对方的情绪转向乐观，往往就能让对方松开自己的脚踝。  \n\n恰当的提问技巧能够有效地（成功率为 42 ％）让交谈对象松开自己的脚踝，并恢复自然放松的状态。恰当的提问技巧能够有效地（成功率为 42 ％）让交谈对象松开自己的脚踝，并恢复自然放松的状态。除此之外，如果会见者走到交谈对象的身边，并在一旁的椅子上坐下来，也会让交谈对象感到放松，因为在互相交流的两个人之间没有了桌子这一屏障。于是，随着情绪的平复，交谈对象的脚踝就会松开，整个谈话的气氛也会变得更加开放和亲切。  \n\n![](/assets/images/image52.png)\n\n两腿交叉而小腿保持平行，这一坐姿被男性评选为最钟爱的女性坐姿     一条腿紧紧地贴在另一条腿上，这样的姿势使腿部看起来显得更加健康和年轻，而且会因为极具性感而无比吸引男人。在举止礼仪课和模特培训课上，都会教给女人这种坐姿。有的女人在跟心仪的男人相处时，总是频繁地交叉和松开两腿。虽然她在两腿交叉时也会保持小腿平行的坐姿，但这样的做法可不能与小腿保持平行的端庄坐姿混为一谈，因为这些女人这样做只是为了将男人的注意力吸引到自己的腿上。  \n\n当我们对交谈话题或者交谈对象感兴趣的时候，我们会把脚伸向前方，缩短和交谈对象之间的距离。倘若我们不感兴趣或者不想发言，我们就会缩回自己的脚；如果是坐着的话，还会把脚缩到椅子底下。当我们对交谈话题或者交谈对象感兴趣的时候，我们会把脚伸向前方，缩短和交谈对象之间的距离。倘若我们不感兴趣或者不想发言，我们就会缩回自己的脚；如果是坐着的话，还会把脚缩到椅子底下。    \n\n![](/assets/images/image61.png) ","n":0.152}}},{"i":181,"$":{"0":{"v":"Laugh","n":1},"1":{"v":"\n\n他发现，人的笑容是由两套肌肉组织控制的：以颧肌为主的肌肉组织可以使嘴巴微咧，双唇后扯，露出牙齿，面颊提升，然后再将笑容扯到眼角上；而眼轮匝肌可以通过收缩眼部周围的肌肉，使眼睛变小，眼角出现皱褶，即我们常说的“鱼尾纹”。  因为开心而发出的笑容不仅会使双唇后扯，嘴角上提，而且还会同时带动眼部周围肌肉的收缩，而敷衍或虚假的笑容则只能引起双唇四周肌肉的收缩。  \n\n假如你想知道对方的笑容是否真诚，首先就应该观察他的眼睛，观察他的眼角是否有“鱼尾纹”。\n\n![](/assets/images/image55.png)\n\n真心的笑容是一种下意识的面部动作，不受大脑的控制，而这就意味着真笑是肌肉自主运动的结果。当你感到快乐的时候，这一信号便会传送至大脑调控情感的区域，产生出一种舒心愉悦的情感。这种情感使你的嘴部肌肉收缩，双唇微咧，面颊提升，同时眼部也会因为肌肉的收缩而产生细纹，眉毛也随之微微下沉，会心的笑容由此产生。  \n\n微笑是一种顺从的信号\n\n撒谎者的笑容出现速度比发自内心的真笑要快，而且持续的时间也更长，看上去就好像是戴着一个笑眯眯的面具。如果是假笑，由于我们的左右两个半脑都希望能使笑容看起来显得更加真实，所以在意识的控制之下，我们的左侧脸庞与右侧脸庞的表情并不完全相同，其中一侧的表情会显得更加夸张。\n\n![](/assets/images/image29.png)\n\n1.  抿唇笑     女人在微笑时双唇紧闭，那就意味着她心中有不愿与你分享的秘密人\n\n在其他女性看来，这种微笑其实就是一种非常明显的拒绝信号。然而，大多数的男性却甚少能明白微笑背后的深意。  \n\n![](/assets/images/image21.png)\n\n2. 歪脸笑  \n\n![](/assets/images/image5.png)\n\n这种歪脸的微笑是西方人的专利，大都是人脑意识作用的结果，其所传递的信息也只有一个 —— 挖苦讽刺。\n\n3.  开口大笑    \n\n这种笑容看起来有些不太自然。人在开口大笑时，嘴巴张开，下巴低垂，嘴角上扬，给人一种很开心的感觉\n\n![](/assets/images/image58.png)\n\n4.  斜瞄式的微笑    \n\n微笑时双唇紧闭，同时还低下头，歪向一侧，并且斜着眼睛向上望，这样的笑容不禁会让人联想到少年时的俏皮和心思暗藏。无论何时何地，女性都喜欢在异性面前露出这种略有些腼腆害羞的笑容，因为这样做很容易引发男性体内的保护欲，使他萌生出保护她不受伤害，呵护她的念头。\n\n![](/assets/images/image25.png)\n\n不开心地撇嘴    \n\n人们用嘴角上扬的表情来表达心中的快乐之情，与此相反，当人们不开心的时候，他们就会表现出一种嘴角下垂的不高兴的表情，也就是我们常说的撇嘴。只要感到不开心，沮丧，绝望，愤怒或紧张，人们的脸上就会浮现出这样的撇嘴表情。然而，我想告诉有这一习惯的人们一个不幸的消息：如果一个人总是把这种负面、消极的表情写在脸上，久而久之，他的嘴角就会永远保持一种下垂的状态，看起来总是一副没精打采的沮丧样子。  \n\n![](/assets/images/image35.png)\n\n在恋爱的过程当中，大多数的笑声都来源于女性的一方，而男性则显少微笑。事实上，在婚姻问题当中，笑声是一种衡量夫妻关系是否融洽、婚姻是否成功的标准。简单一点儿说，丈夫让妻子笑得越多，在妻子心中丈夫的魅力和吸引力就越大。这是因为，让他人发笑的能力常常会被认为是力量和权威的标志，而女性则通常更加青睐于那些强势的男性。不过，在男性的眼中，更可爱、更有魅力的却往往是那些温婉恭顺的女性。同时，布诺温还发现，下属常常会用笑声来取悦上级，而上级则会让下属发笑（不过，他自己却并不笑）来维系自身的优势。  研究表明，女性会在自己认为有吸引力的男性面前笑声连连，而男性则通常被那些在自己面前微笑的女性所吸引。  \n\n当你向他人露出笑容的同时，对方通常都会回以一个同样灿烂的笑脸。如此一来，出于因果效应的作用，双方心中便都会自然生出一种对对方的好感。研究证实，会面时，双方如果都面露笑容，就能够使绝大多数的会谈都能进行得更加顺利，会谈的时间也会相对延长，而且会谈最后通常也能获得对双方都更加有利的结果，使双方关系更进一步。而想获得这所有的一切，你需要做的就是慷慨地展露自己的笑脸，并且让微笑成为自己的一种生活习惯。  \n","n":0.2}}},{"i":182,"$":{"0":{"v":"Head","n":1},"1":{"v":"\n1. \n![](/assets/images/image65.png)\n\n最常见的动作就是将手移至脸旁，用拇指支撑着下巴，食指保持一种向上的姿势贴在脸颊上，而剩下的三个手指则正好将嘴巴挡住。另外，双腿紧紧交叉，而双臂也以类似的姿势环抱于胸前（一种防御的状态），与此同时，他的头和下巴均保持一种下垂的姿势（一种否定或不友善的态度）。种种迹象都表明该聆听者已经对所听到的内容做出了自己的评价。聆听者通过这一连串的肢体语言“群组”，就是想告诉对方“我对你的话不感兴趣”、“我不同意你的说法”或“虽然我对你的话很不满意，但是我正在努力克制自己的不满情绪”。  \n\n![](/assets/images/image3.png)\n\n2. 头部倾斜    \n\n把头部向一侧倾斜是一种顺从的表示，因为这个姿势不仅暴露出人们的喉咙和脖子，还会让人显得更加弱小和缺乏攻击性。\n\n![](/assets/images/image51.png)\n\n3. 低头耸肩    \n\n低头弓背的姿势，努力让自己显得更微小，以免打扰到其他人   向上耸肩，同时把头低下，缩在两肩之间，这样的姿势能够保护柔弱的脖子和喉咙免受攻击。\n\n\n","n":0.302}}},{"i":183,"$":{"0":{"v":"Hand","n":1},"1":{"v":"\n\n# 在撒谎时最常见的八种手势      \n\n* 用手遮住嘴巴    \n\n用手遮住嘴巴的手势下意识地用手遮住嘴巴，表示撒谎者试图抑制自己说出那些谎话。有时候人们是用几根手指或者紧握的拳头遮着嘴，但意思都是一样的。  \n\n![](/assets/images/image43.png)\n\n* 触摸鼻子的手势    \n\n触摸鼻子的手势一般是用手在鼻子的下沿很快地摩擦几下，有时甚至只是略微轻触，几乎令人难以察觉。女人在做这个手势时比男人的动作幅度更小，或许是为了避免弄花脸上的妆容。     我们必须牢记一点，触摸鼻子的手势需要结合其他的身体语言来进行解读，有时候人们做出这个动作只是因为花粉过敏或者感冒。  \n\n![](/assets/images/image2.png)\n\n当一个成年人看到某件令人倒胃口的事情时，他很可能做出摩擦眼睛的手势。大脑通过摩擦眼睛的手势企图阻止眼睛目睹欺骗、怀疑和令人不愉快的事情，或者是避免面对那个正在遭受欺骗的人。男人在做这个手势时往往会使劲揉搓眼睛；如果他试图掩盖一个弥天大谎，则很可能把脸转向别处。\n\n![](/assets/images/image90.png)\n\n*  抓挠耳朵    \n\n让我们试想一个场景。你对某人说：“这个东西只要四千多块钱。”对方则抓挠着自己的耳朵，把头转向一侧，说道：“可这对我来说似乎是很大一笔钱。”在这里，抓挠耳朵的手势就表示出听话人“非礼勿听”的企图，即通过用手盖住耳朵或者拉扯耳垂来阻止自己听到那些不愿入耳的话语。我们在前面提到过，小孩为了逃避父母的责骂会用两只手堵住自己的耳朵，抓挠耳朵的手势则是这一肢体语言的成人版本。抓挠耳朵的手势也有多种变化，包括摩擦耳廓背后，把指尖伸进耳道里面掏耳朵，拉扯耳垂，把整个耳廓折向前方盖住耳洞。和触摸鼻子的手势一样，抓挠耳朵也意味着当事人正处在焦虑的状态中。\n\n![](/assets/images/image87.png)\n\n*  拉拽衣领    \n\n撒谎会使敏感的面部与颈部神经组织产生刺痒的感觉，于是人们不得不通过摩擦或者抓挠的动作消除这种不适。\n\n![](/assets/images/image40.png)\n\n# 交流时\n\n* 手指放在嘴唇之间    \n\n将手指放在嘴唇之间的手势，与婴孩时代吸吮母亲的乳头有着密切的关系，是潜意识里对母亲怀抱里的安全感的渴望。人们常常在感受到压力的情况下做出这个手势。\n\n大部分用手接触嘴唇的动作都与撒谎和欺骗有关，但是将手指放在嘴唇之间的手势却只是内心需要安全感的一种外在表现。所以，遇到做出这个手势的人，不妨给予他承诺和保证，这将是非常积极的回应。\n\n![](/assets/images/image74.png)\n\n当听众做出**用手支撑着头的动作**时，表示他们心中已经产生了厌倦情绪，用手作为支撑，就是为了不让脑袋低下去，以免自己在不知不觉中睡着。很多职业演说家误以为听众用手指敲击桌面和用脚频繁地轻叩地板，是厌倦情绪的反应，实际上，这些动作是急躁的表现。\n\n![](/assets/images/image60.png)\n\n思考的手势是将握住的手放在下巴或者脸颊处，通常还会将食指竖立起来。当人们开始对说话人的话题失去兴趣，然而出于礼貌又想装作感兴趣的样子时，这个手势就会悄悄发生变化。随着厌倦袭来，原本轻挨着脸部的手腕渐渐成为了头部的支撑。\n\n![](/assets/images/image38.png)\n\n表现出兴趣的思考手势：头部保持着直立的姿势，手轻轻地靠在脸颊上\n\n![](/assets/images/image59.png)\n\n抚摸下巴以后如果有机会在众人面前发言的话，你不妨在阐述观点的同时仔细观察下面的听众，你会发现大部分听众在聆听的过程中，都会将一只手放在脸颊旁边，这意味着他们正处在思考当中。随着你的演讲接近尾声，请求听众们就你的观点提出意见和建议时，听众们往往会停止思考的手势，转而用手抚摸下巴。这一体语言是表示他们正在考虑如何做出决定。  \n\n![](/assets/images/image18.png)\n\n![](/assets/images/image54.png)\n\n抓挠后颈和拍击头部的手势    \n\n这个手势表示：“真是麻烦啊”  \n\n“Pain in the neck”在字面意思上是脖子痛，但这句俗语却是用来指讨厌的人和麻烦的事。脖子痛与讨厌的人和事之间为什么能够扯上关系呢？这是因为当你觉得某个人很讨厌时，脖子后面微小的肌肉组织就会呈现乳突状 —— 我们经常将之称为鸡皮疙瘩。\n\n![](/assets/images/image27.png)\n\n在拍击自己的头部时，习惯于拍击后颈的人很可能个性较为内向或者为人比较刻薄；而那些习惯于拍击前额的人则可能更加外向而且容易相处得多。\n\n![](/assets/images/image50.png)\n\n# 手掌\n\n\n![](/assets/images/image63.png)\n\n为了表示自己的清白或者展示自身的诚意，人们通常会摊开手掌，向对方说一些“我没做过”，“如果是我做错了，我道歉”或者“坦白告诉你吧”之类的话。在人们开始袒露心扉，或者想说真话的时候，他们很可能会在无意间露出全部或部分手掌。与大多数传递微小信息的肢体动作一样，这完全是一个下意识的动作。而当你看到这样的动作，你的“直觉”就会告诉你，他没有撒谎。    \n\n每当孩子们撒了谎，或隐瞒了什么事情，他们通常都会把自己的手藏在身后。当一个女人想隐瞒某事的时候，她通常会刻意地回避这个问题，或是谈论其他与之毫无关系的话题，与此同时，她很可能还会做一些其他的事情，从而分散对方的注意力。  \n\n将双手置于口袋之中也是男人们比较偏爱的一种姿势，可是，你知道这个姿势背后的含义吗？当男人摆出这个姿势的时候，他其实是想借此告诉你，他并不想加入到这次的谈话中来。\n\n举例来说，如果你觉得有人想侵犯自己，出于自卫，你很有可能就会将双臂交叉抱于胸前。不过，尽管任何事情都没发生，但是只要你摆出了同样的姿势，一种自卫的感觉便会油然而生。\n\n借助手掌来传达指示的动作主要有三种：手心向上、手心朝下以及有一根手指在外的握拳状。\n\n手心向上是一种用来表示妥协、服从和善意的手势；同时，这也是乞丐乞讨时惯用的一种表达哀求之意的动作。从人类社会的发展角度来看，人们通常以此来告知对方：我的手中并没有武器。当你向某人提出移动某物的要求时，对方肯定不会因为你的要求而有感到有压力，更不会因此而有被胁迫的感觉。\n\n如果你希望他人开口说话，你可以向他伸出右手，摆出一个手心向上的手势以示“谈话权的移交”，从而告知对方你希望他能继续你的谈话，而你也已经做好了在接下来的谈话中常当听众的准备。  \n\n![](/assets/images/image75.png)\n\n一旦你将手掌反过来，摆出手心朝下的手势，你在对方眼中的权威性就会立刻大增。对方不仅会马上感觉到你是在命令他将这件东西搬走，而且很有可能会萌生出一种抗拒心理。不过，这种抗拒心理的产生最终还是由你和对方之间的关系，或是你与他在工作中的职位级别来决定的。翻转手掌，使原本向上的手心朝下。这样一个看似简单的手势的变化却能够彻底改变他人对你的看法和态度。  \n\n当一对夫妻手牵手散步的时候，居于支配地位的一方 —— 通常为男性一方会稍稍走在另一方的前面一点，而他的手也就自然而然地压在了跟在他后面的妻子的手的上方，其手心也就很自然地面朝后方。至于他的妻子，由于位置稍稍靠后，其手心也就会很自然地向前迎合丈夫朝后展开的手掌了。尽管这只是一个很小的细节，但是对于一名肢体语言观察者而言，它所提供的信息已经足以让他判断出谁是这家的一家之主了。  \n\n![](/assets/images/image28.png)\n\n伸出的手指  = “ 立刻照做，不然试试看”第三种手势合掌伸指。当你将手握成一个拳头，只留出一个手指时，这惟一的一个突出于拳头之外的手指就仿佛凝聚了整个手掌的全部力量，一触即发。当你在说话的同时将这根手指指向他人的时候，对方马上就会感觉到隐藏在手指背后的那种迫使人妥协的力量。这样的手势往往会在对方的潜意识中制造出一种负面的影响，因为该手势之后必然会伴随有举臂，挥拳等动作，而对大多数灵长类动物而言，这通常是攻击对方的前奏曲。  这种合拳伸指最容易引发听话人的反感，尤其是当这根手指随着说话人的话语节奏而抖动的时候，这种反感之意就会变得更加强烈。\n\n在谈话中习惯使用第三种手势的人通常会给人一种“咄咄逼人”，“爱挑衅生事”且“鲁莽”的印象，而且经由他们传递的信息和话语也最不受观众的重视。当演说者用这一手势直接指向观众时，观众们往往会将注意力转移到对该人的评价上，而不再关心他演讲的内容。\n\n\n# 手指\n\n\n通常来说，习惯于用右手的人会在谈论到自己所青睐的观点时用右手辅以手势来说明，而左撇子们则恰好相反。\n\n![](/assets/images/image67.png)\n\n摩拳擦掌”这一动作表示此人无比期待的心情。摩擦手掌的速度暗示出了做此动作者心目当中的受益者。  \n\n![](/assets/images/image6.png)\n\n摩擦手指\n\n“我们肯定能挣钱的”人们通常会用揉搓拇指和食指指尖的动作来暗指金钱，或是表达索取金钱的意愿。\n\n![](/assets/images/image72.png)\n\n![](/assets/images/image47.png)\n\n于是，我们这才知道，紧握双手的动作体现的其实是一种拘谨、焦虑的心理，或是一种消极、否定的态度。\n\n![](/assets/images/image26.png)\n\n尖塔形的手势经常出现在上下级之间的交谈中，而这一手势代表的是信心或是一种自信的态度。他对自己的答案很有信心惯于使用该手势的人有时候还会将它演变为一种祈祷式的手势，试图让自己看起来就像万能的上帝。总体说来，如果你想说服对方，或是赢得他人对你的信心，你就应当尽量避免使用尖塔形的手势，因为这一手势有时候会给人造成一种自鸣得意、狂妄自大的感觉。  尖塔形手势分为两种：举起的尖塔，人们通常会在发表自己的观点意见或说话时使用该手势；放下的尖塔，使用该手势者正在聆听他人的观点和谈话。  \n\n![](/assets/images/image46.png)\n\n托盘式的姿势\n\n这一动作本身并无任何负面色彩，在向心仪的对象表达爱意时，还能发挥积极的正面效应。使用这一姿势的多为女性以及男同性恋者，他们通常都是借此来吸引心仪男性的注意力。假如对面的男子颇让自己心动时，女性常常会不由自主地将一只手搭在另一只手上，然后用双手撑住下巴，微微抬头，将脸迎向对方。那情形就好像是把自己的脸当成了摆在底座上的精美工艺品，端到了对方的面前，希望他能细细品味。\n\n托盘式的姿势：为了表示倾慕之意，她将自己的脸迎了上去  \n\n![](/assets/images/image91.png)\n\n握住手腕的动作标志着此人内心充满了挫败感，希望能够借此动作来找自控权。\n\n![](/assets/images/image20.png)\n\n握住另一只手的那只手抓握的位置越高，此人心中的挫败感或愤怒情绪就越强烈。\n\n![](/assets/images/image8.png)\n\n双手插入马甲口袋，只留拇指在外面   拇指有关的手势\n\n正如我在前面提到过的，大拇指象征着权威和优势。在手相术里，拇指代表的是力量和自我，而与拇指有关的肢体语言也通常带有自恃甚高的意味在里面。我们习惯用拇指来体现自身的强势地位，以及胸有成竹的自信心理或是带有侵略色彩的勃勃野心。拇指在外面喜欢玩弄拇指手势的人也喜欢以脚跟为轴心，前后摇摆，从而吸引他人的注意力，体现他们身份的高贵和与众不同。  \n","n":0.134}}},{"i":184,"$":{"0":{"v":"Face","n":1},"1":{"v":"\n# 七种基本的微表情\n\n## 开心\n\n![](/assets/images/2022-11-01-21-16-33.png)\n嘴唇上扬\n\n![](/assets/images/2022-11-01-21-16-47.png)\n\n同样的高度 两眼有鱼尾纹\n\n## Contempt 蔑视\n\n![](/assets/images/2022-11-01-21-17-17.png)\n\n嘴唇一边比较高\n\n自己觉得骄傲也会\n\n## disgust 觉得恶心\n\n![](/assets/images/2022-11-01-21-17-37.png)\n\n鼻子旁的皱纹\n\n![](/assets/images/2022-11-01-21-17-42.png)\n\n感觉是想捂鼻来不用手\n\n上嘴唇也上扬\n\n## 生气\n\n![](/assets/images/2022-11-01-21-18-14.png)\n\n眼睛变窄，可能是为了专心\n\n![](/assets/images/2022-11-01-21-19-46.png)\n\nbrows lowered and eyelids narrow\n\n![](/assets/images/2022-11-01-21-20-06.png)\n\n怒目圆睁\n\n![](/assets/images/2022-11-01-21-20-16.png)\n\n 下颚向前\n\n![](/assets/images/2022-11-01-21-20-27.png)\n\n抿嘴唇 但是眼睛还是专注于那个东西、人\n\n\n### 失望\n\n![](/assets/images/image16.png)  眉毛上扬\n\n![](/assets/images/image32.png)\n\n![](/assets/images/image78.png) 嘴唇向下\n\n![](/assets/images/image73.png)噘嘴\n\n![](/assets/images/image62.png)眼神向下 拒绝eye contact 没力量了 抿嘴\n\n### 害怕\n\n![](/assets/images/image49.png)upper eyelid 上扬，时间长\n\n![](/assets/images/image36.png)皱眉\n\n![](/assets/images/image30.png) stress, high\n\n![](/assets/images/image13.png) month open and tense\n\n![](/assets/images/image79.png)lips stretched\n\n### 惊讶\n\n![](/assets/images/image53.png) upper eyelid raise a little\n\n![](/assets/images/image64.png) short and no stress\n\n![](/assets/images/image34.png)drop in a relax way\n\n## 唇\n\n### 蹙唇（有意反驳）\n\n蹙唇（有意反驳）\n\n  没有人会读心术，但人们可以通过观察非语言线索尽可能地了解对方的心思。一些非语言线索相对明显。明显的线索更容易被观察者发现并解读。同样地，明显的线索更容易被发言人把握，用于掩饰自己的真实想法。嘴唇是可以泄露这些微妙线索的身体部位之一。\n\n蹙唇是几乎察觉不到的唇部轻微起皱或嘟起（见下页照片）。这个姿态释放的是有异议和不认同的信号。蹙唇越明显，有异议或不认同的程度越深。蹙唇意味着此人已经在头脑中形成了与所讲内容或所采取行动截然相反的想法\n\n![](https://tczimg.s3.amazonaws.com/vscode/0277f4c3dd0c4b0ba58c4cb7e826f0de.png)\n\n了解一个人的想法能给你带来优势。其诀窍是，在人们有机会表达反对意见之前转变他们的想法。一旦有人明确表达了某种意见或做出了某种决定，根据一致性心理学原则，要改变他的看法会更加困难。决策过程会导致某种程度的紧张感。\n\n我们再次强调一下，为什么留意并观察蹙唇线索如此重要：一旦某人对你的想法或建议明确地说“不”，或者发表了负面评论，“一致性”原则就开始发挥作用，意味着听讲者现在很难背弃他们的语言回应，并很难改变他们的想法了。蹙唇线索能让你发现即将出现的负面回应，让你有机会在对方说出口之前予以应对，说服对方接受你的看法或计划。\n\n### 咬唇（有话想说）\n\n咬唇（有话想说）\n\n  “读心”的另一个技巧是留意咬唇线索。咬唇是用牙齿轻咬或轻扯上嘴唇或下嘴唇。这种非语言姿态表明：此人有话要说，但因为各种原因正在犹豫。因此，“咬住你的嘴唇”这句古老的格言依然有效，它是指闭紧嘴巴，什么也别说。我经常在讲课时看到学生做咬唇动作，我会把它当作组织移情表述的信号，告诉对方“看来你想补充一下讲话内容”，以鼓励学生发表自己的看法。大多数学生都很吃惊，因为我能读懂他们的心思，而且由于我在关注他们，他们会获得良好的自我感觉\n\n### 触碰嘴唇（不愿讨论）\n\n敛唇（不愿说出）\n\n  敛唇和咬唇的意思相似，但有更消极的含义，当上嘴唇和下嘴唇紧压在一起时，就会出现敛唇动作：表明你的谈话对象有话要说，但又不愿意说。在嫌疑人招供之前，我经常能看到敛唇动作。嫌疑人想说些什么，但他们收敛了双唇，免得有话脱口而出。\n\n触碰嘴唇（不愿讨论）\n\n用手、手指、铅笔或其他物体触碰自己的嘴唇，表明此人不适应正在讨论的话题。刺激嘴唇能使人的注意力瞬间脱离敏感话题，从而减轻焦虑感。嫌疑人往往在无意中给我释放信号，表明我刚刚提出的问题是一个敏感话题，或者让他们感到了不适","n":0.144}}},{"i":185,"$":{"0":{"v":"Eye","n":1},"1":{"v":"\n\n在面对面的交谈中，我们的目光大部分时间都停留在对方的脸上，所以眼睛所传递的信息，是能够帮助我们解读对方态度与想法的最佳利器。当人们初次见面的时候，会在很短的时间里形成对新朋友的第一印象，而这个印象主要取决于人们的眼睛所看到的东西。  \n\n相同的灯光条件下，随着态度和情绪从积极转向消极，瞳孔就会由扩张转向收缩，反之亦然。当人们处在兴奋的状态中时，瞳孔会比原始尺寸扩大四倍。相反，如果人们处在生气或者其他消极的情绪中时，瞳孔就会收缩，变成我们平时常说的“如小圆珠般的眼睛”或者是“蛇眼”。浅色瞳孔的眼睛往往更吸引人，因为浅色的瞳孔在扩张时给人的感觉更加明显。  \n\n**当人们看到令人心情愉快或是痛苦的东西时，瞳孔也会产生类似反应**。比如，看到美食和政界要人时瞳孔会扩张；反之，看到残疾儿童和战争场面时瞳孔会收缩。赫斯还指出，瞳孔的扩张也与心理活动密切相关。如果人们正在努力解决某个难题，那么当这个难题最终攻克时，瞳孔就会扩张到极限尺寸。  \n\n在恋爱期间，眼睛是最能传神的器官。女人们给眼部化妆，也是为了更加突出眼睛的神采。如果一个女人想要吸引一个男人的注意，她就会在注视那个男人时瞳孔扩张，而这个男人很可能会心照不宣地读懂女人发出的信号。为什么罗曼蒂克的相遇总是发生在灯光朦胧的地方呢？瞳孔扩张就是答案。在微暗的光线中，人们的瞳孔会不由自主地扩张，从而让相遇的两个人互相产生吸引力，成就罗曼蒂克的爱情。当情侣们深情地互相凝视时，他们是在不知不觉地寻找对方瞳孔扩张的信号，而且彼此都会被对方扩张的瞳孔激发出兴奋的情绪。  \n\n## 瞳孔测试    \n\n感知瞳孔扩张的能力是直接与大脑相关联的，而且完全属于自发的反应，不受主观意志的控制。女人的瞳孔就会迅速产生反应，从而显现和善亲切的形象。  \n\n在跟别人交流想法或者是谈判时，“要好好看着对方的眼睛”。在跟别人交流想法或者是谈判时，“要好好看着对方的眼睛”。但是我们觉得更好的做法是“好好看着对方的瞳孔”，因为瞳孔会把他们心中最真实的感受告诉你。    \n\n![](/assets/images/image19.png)\n\n## 轻抬眉毛   \n\n轻抬眉毛是在距离稍远处向人打招呼的姿势。**对看到的人轻抬眉毛，是一种下意识的反应**。这表示你对出现在面前的这个人持有首肯的态度。而且这个动作很可能与惊讶和害怕的情绪相关，就仿佛你在说“见到您真是让我又惊又怕”，也可以理解为“我非常敬畏您，并且对您很有好感”。我们不会对擦肩而过的陌生人以及自己讨厌的人做出这个动作。如果别人在见到你的一刹那没有对你轻抬眉毛，那就表示他可能怀有挑衅的情绪。  如果你喜欢他，就向他轻抬眉毛；如果你想让他喜欢你，还是向他轻抬眉毛。这可是一条黄金准则。\n\n## 注视 \n\n**你的目光投向哪儿只有当两个人彼此眼神相交时，才算是真正形成了互相沟通和交流的基础。**只有当两个人彼此眼神相交时，才算是真正形成了互相沟通和交流的基础。在我们和别人交谈时，有的人会带给我们舒服愉快的感觉，有的人则会令我们局促不安，甚至还有一些人会让我们觉得不可信赖。这些感觉的产生都是从眼神开始的，而且往往取决于对方注视我们的时间有多长或者面对我们注视的目光，对方有着怎样的反应，等等。  一般来说，当我们和别人说话时，约有 40 ％至 60 ％的时间里，我们会和对方目光相接；而在聆听别人说话时，这个比例会上升至 80 ％。但是，这个普遍规律并不通行于全世界，在日本和某些亚洲、南美国家，长时间的注视会被认为是挑衅或者失礼的行为。日本人在和别人交谈时，常常将脸转向一旁或是看着对方的咽喉部位。如果是对日本文化不了解的欧美人，碰到这样的情况一定会相当局促不安。  \n\n当两个人在交谈中产生第一次目光接触时，往往是弱势的一方会先把视线移开。这也就说明，保持注视对方的姿态，是以一种微妙的方式传达出挑战的意味。如果是当对方表达自己的意见或者观点时，你久久地注视对方，那就表示你不同意他的看法。假设你和一个地位比你高的人谈话，例如你的老板，在你想表达反对意见时，你就可以把注视他的时间拉得比平时稍长一点，这样他就会明确地感觉到你的态度。当然，如果你还想保住自己的饭碗，就不要老是玩这招了。  \n\n当一个女人对房间另一端的某个男人产生兴趣时，她会有意与这个男人眼神相交，以吸引男人的注意。通常她会注视男人两三秒钟，然后将目光移开并且垂下眼睑。女当女人终于抓住了男人的注意力后，她往往会小幅度地做出轻抬眉毛的动作，同时还不忘微微张大自己的眼睛，给予男人更为明确的爱慕信号。     或许，在遇上反应迟钝的男人时，更高效的方法是直接走到男人跟前，面对面地对他说：“你好，我对你的感觉很不赖！”\n\n转移目光是屈服的表示，几乎所有的灵长类动物都认同这一身体语言。如果一只猩猩要展示它的威力或者想要发出攻击，就会把目光死死地盯着攻击对象。为了避免遭受攻击，感受到威胁的弱小猩猩会把目光移开，并且把身体缩成一团，让自己看起来显得更加瘦弱。  \n\n长久的注视会激发亲密的情感\n\n![](/assets/images/image76.png)\n\n","n":0.183}}},{"i":186,"$":{"0":{"v":"Body","n":1},"1":{"v":"\n男人们经常会对女性做出两手叉腰的姿势，以此显示自己充满男子气概的自信风度。    \n\n两手叉腰的姿势能够让你显得更加魁梧和打眼，因为你占据了更多的空间。  \n\n![](/assets/images/image57.png)\n\n![](/assets/images/image69.png)\n\n西部牛仔的姿态    \n\n把拇指塞进皮带或者放在裤子口袋里，突出展示男性的生殖器部位，很多男人都用这种姿态来表现带有性意味的攻击性态度。在西部电影中，最厉害的神枪手通常都是用这样的姿势向观众显示自己的男性气概\n\n![](/assets/images/image68.png)\n\n![](/assets/images/image37.png)\n\n男人们通常用这种姿势给其他人施压，或者故意营造出一种轻松自如的假象，以此麻痹你的感官，让你错误地产生安全感，从而在不知不觉中踏上他预先埋好的地雷。  \n\n![](/assets/images/image31.png)\n\n准备就绪的坐姿准备就绪的坐姿是谈判代表最该学会辨认的姿势之一。准备就绪的坐姿是谈判代表最该学会辨认的姿势之一。举例来说，假设你为对方提出了一个建议，如果对方在听完你的陈述后做出准备就绪的坐姿，而且交谈的气氛又相当融洽，那么这个时候你可以大胆地询问对方的想法。你多半能够得到肯定的回答。  \n\n![](/assets/images/image89.png)\n\n![](/assets/images/image7.png)\n\n起跑者的姿势准备就绪的姿势也传达出结束会谈的愿望。表达这种愿望的肢体语言包括身体前倾，双手分别放在两个膝盖上，或者身体前倾的同时两只手抓住椅子的侧面，就像在赛跑中等待起跑的运动员一样。在你和别人交谈的过程中，只要你看到他们做出了这样的动作，那么你最好重新引导他们对你所推销的商品产生兴趣，或者尝试转换话题的方向，又或者干脆结束你们的会谈。  \n","n":0.333}}},{"i":187,"$":{"0":{"v":"Arm","n":1},"1":{"v":"\n当一个人感到紧张不安想保护自己，或不愿接受他人意见的时候，他很可能会将双臂交叉，紧紧抱于胸前，借此告知对方他有些紧张或不安。当你将双臂交叉抱于胸前时，你的可信度也会随之大大降低。  \n\n![](/assets/images/image12.png)\n\n因此，当你与他人交谈时，如果看到对方摆出了双臂交叉的姿势，那么你就应该立刻意识到自己是不是说了一些与对方观点不同的话。在这样的情况下，即使对方口头上表示赞同你的观点，你也已经没有必要再将谈话继续下去了。因为，他的肢体语言已经很明确地告诉你，他并不赞成你的话。事实就是，肢体语言远比有声的话语更加诚实可靠。  \n\n一个既简单又有效的方法，可以帮你轻轻松松解开对方交叉的双臂：找一件物品让他握着，或是找一件事情让他做。譬如说，你可以在说话的时候，给下面的听众们一只笔、一本书、一本手册、一件样品，或是让他们做一些笔头测试，从而使得他们没有机会交叉双臂。同时，你的这些要求也会迫使他们不得不将身体前倾，从而使他们无法与你保持一定距离。所有的这一切无非只是想让听众们能够以一种更加开放的姿势聆听你的谈话，而这样做的目的就是希望他们能够以更加开放的态度接受你的意见和请求。    \n\n![](/assets/images/image22.png)\n\n代表强烈的敌意当一个人在将双臂交叉抱于胸前的同时，两只手也紧紧地攥成拳头夹于腋下，那就表示此时的他除了具有相当强烈的防御意识之外，还带有十分明显的敌意。\n\n![](/assets/images/image77.png)\n\n抓握式的双臂交叉法：显示出了此人的不安与紧张，暗示了他将不会购买你推销的产品   这是另一种交叉双臂的方式，其最大的特点就是在交叉双臂环抱于胸前的同时，两只手紧紧抓住另一只手的上臂，增大了呈交叉状态的双臂的力量，使这一姿势更加牢固，从而能够更加有效地保护人体的胸部。\n\n![](/assets/images/image11.png)\n\n向上的拇指 —— 出于防御的心理。不过，做此手势的人也相当自信，觉得自己也很棒   如果某人在双臂交叉的同时，露出向上竖立的大拇指，这就表示此人自我感觉良好，觉得自己很棒，一切尽在掌握中。在他说话的过程中，他还会用两个大拇指来强调自己说话的重点。我在上文中曾经提到过，拇指向上的手势代表做该手势的人十分自信，而交叉的双臂则能够保护自我，给人以安全的感觉。  \n\n![](/assets/images/image17.png)\n\n通常而言，女性会用一种较为隐晦的方式来替换这种过于明显的肢体语言，如单臂交叉抱于胸前的姿势，即只使用一只手臂，这只手臂在身体前部弯曲后抓住另一只手臂，从而在自己与对方之间形成一道障碍，拒绝对方的进入，看起来就好像是在拥抱自己。\n\n如果一个人感到焦虑不安，或是意识到自己的外表或行为有所不妥，他很可能也会不断地调整表带，翻查钱包，双手紧握，摆弄衣袖，或是做任何可以使双臂在胸前交叉的动作。\n\n以细微的动作来充当防御工具的方法有很多种，其中最常见的一种就是用双手握住茶杯。\n\n![](/assets/images/image83.png)\n\n## 接触\n\n如果你在与他人握手的同时，用左手轻轻接触对方的某些身体部位，那么，你很有可能会得到意想不到的结果。有技巧地接触对方的手肘，将会使对方达成你心愿的几率提高三成。\n\n\n其一，人们都觉得，手肘属于公共空间的范畴，尚不属于个人的私隐空间；其二，在大多数国家里，人们通常都不会轻易地与陌生人发生肢体接触，所以，一旦接触，就会给对方留下一个较为深刻的印象；其三，一次轻轻的，时间不超过三秒钟的肘部接触能够在原本素不相识的两人之间建立一种瞬时的联系，拉近二人之间的距离。  \n\n\n手肘接触法，只要使用得当，不仅能够起到吸引对方的注意力，加强印象，强调本人观点的作用，而且还能增强你对他人的影响力以及他人对你的印象，从而帮助你在每个人的心目中树立起一个良好的形象。\n\n","n":0.267}}},{"i":188,"$":{"0":{"v":"Basic","n":1},"1":{"v":"\n# 原则\n\n- 说话的本质其实是一场**交易**，这些话其实都在跟倾听者做交易\n- 沟通 = 结果+情绪和人际关系\n- 描述事情从他人的角度来讲\n- 作为一个倾听者，更容易给别人价值。如果我在听的时候，再给对方一些很好的反馈「你说得真棒，你说得真好」，这个反馈更增大了对方的积极感受，这时候很容易给别人留下好印象。\n- 我们应该多说一些**价值高的话**。比如表扬、感谢，还有承诺等等，这些都是价值比较高的话，这些话都会让别人觉得从你的话当中获得了价值，平时我们可能会忽略这些话的表达。\n  - 说话价值理论有什么意义？它可以成为你说话的一个底层逻辑，可以指导你说话的方向。\n  - 你以后说了一些话，自己可以去判断一下，这段话有给对方价值吗？如果没有的话，对方为什么要听？\n  - 用这样一个标准去衡量，你会发现很多话可能都是无用、无聊的话，就不必要说了。很多时候你的话没有给人家价值，你还剥夺了人家，还造成了人家的不愉快，当然你就不会受对方欢迎了。\n\n\n# 无意义的谈话\n\n1. 就是无用、无聊。你在每一次跟别人说话的时候，都想想，你说这段话对别人有用吗？有什么用？或者你说的这段话，让别人开心吗？别人会不会觉得无聊？\n\n无用、无聊的话，就是典型的无价值谈话，别人听到之后，其实不会有什么不适感受，但由于付出了成本，他会觉得不耐烦。 \n\n比如我是一个听众，如果我听到演讲者在台上讲「我有点紧张，我不知道应该说什么」这种话，我就会觉得是无用、无聊的话。\n\n因为你说这段话，除了缓解自己的紧张之外，对我来说没有任何意义，没有任何用，这种无用、无聊的话就不要说。\n\n所以你想想看，自己说的哪些话，无用、无聊。\n\n2. 无价值谈话的典型，叫做直接引起对方消极感受。\n\n比如你跟对方说你这个月的工资不发了，这不仅是无价值了，这是从对方身上要东西了，所以对方肯定会不高兴。\n\n还有很多冒犯的话，都是会引起对方的消极感受。\n\n还有一些话其实给了对方价值，但是就是会引起对方消极感受，比如批评的话。\n\n「我未来是为了你好」，其实这句话对方也不欢迎。\n\n注意，我们今天说的说话技巧，只从一个角度去考评你的说话行还是不行，就是受不受欢迎，所以批评的话也不被对方欢迎。\n\n3. 就是提示对方未来风险。\n\n比如我当着 A 说了 B 的坏话，其实我并没有说 A，我并没有剥夺 A 的什么东西，可能你说 B 的坏话，会提示 A 未来有风险，就是我能对着你说他的坏话，我也能对着别人说你的坏话。\n\n# 移情表述\n\n情表述是指将谈话焦点放在你的谈话对象而不是你本人身上\n\n你今天好像过得不太好”“你今天看起来很高兴”等移情表述，能让对方明白有人不仅在倾听他们，还在某种程度上关心他们是否幸福。这种关注能让我们获得良好的自我感觉，更重要的是，能促使我们喜欢关注我们的人\n\n移情表述还能叫停谈话周期。人们发言时会希望得到反馈，借以了解他们的信息是否已被接收和理解。使用并行语言反馈对方的谈话内容，可以结束这个沟通周期。一旦成功地传达某个信息，人们就会获得良好的自我感觉。\n\n组织移情表述需要你认真倾听对方讲话。全神贯注地倾听对方讲话，能够证明你真正关注发言人，也理解他们的谈话内容。\n\n**组织移情表述的基本公式是“那么你……”**\n\n简单的移情表述可能包括“那么你觉得今天的情况还不错”或者“那么你今天过得不错”。我们往往会不假思索地说出“我理解你的感受”这样的话。然后对方会不由自主地想：不，你不知道我的感受，因为你不是我\n\n使用移情表述实现“友谊黄金法则”目标时，要避免逐字重复对方的讲话内容\n\n# 说话角度\n\n1. 从感受的角度表达自己的观点\n2. 层次联想法\n   1. 表面\n   2. 实际\n   3. 本质\n3. 时间联想\n   1. 过去\n   2. 现在\n   3. 未来\n4. 角度联想法\n   1. 信息点\n   2. 身份角度\n\n","n":0.137}}},{"i":189,"$":{"0":{"v":"Askquestions","n":1},"1":{"v":"\n1. 封闭式  节省时间 控制谈话方向 但是信息有限\n2. 开放式   信息全面 但是浪费时间","n":0.354}}},{"i":190,"$":{"0":{"v":"Appreciation","n":1},"1":{"v":"\n# 赞美\n\n第一点，具体。你要跟他讲哪里好，越具体越好，因为在表扬这个事情上，可信度高很重要。\n\n「你人真好」就不如说「你今天做的某一个事，真的让我觉得你特别善良。」\n\n如果你真的找不出什么具体的地方表扬他的话，你可以用这种话来表扬他：「你这个人的个性就是这样的。」\n\n这种个性化的认可，也会让对方觉得你的话效果好，价值很高。\n\n所以这个方法，叫做认可对方的个性，要学会说这种话，可信度很高，因为个性就意味着跟别人不一样。\n\n在表扬这个方面，总之大家就记得，可信度高很重要。\n\n\n## tip\n\n外表的认同和赞扬，她的发型妆容配饰服装鞋子包甚至脸上动的部位，都是我的话题，延伸后表情、肢体语言，关键点在于两点：细节，以及发现其他男人未曾发现的点。\n\n在聊天过程中可以抓住女生的一个隐形价值点进行认同肯定，例如女生的独立、聪慧、善良等。\n\n# 感谢\n\n「我谢谢你」是可以的，感谢的时候可以加上表扬，效果更佳：「你这个人怎么这么棒，你怎么这么厉害。」\n\n所以感谢可以加表扬，感谢也可以加承诺：「如果下一次你来找我，我一定帮你。」也是为对方提供了价值。\n\n这是感谢的话应该怎么说，两种方式，感谢加表扬，效果好；第二种方式，就是感谢家承诺，效果好。\n\n1. 具体化\n2. 从否定到肯定\n3. 指出他人的变化\n4. 信任","n":0.354}}},{"i":191,"$":{"0":{"v":"Car","n":1}}},{"i":192,"$":{"0":{"v":"Punishment","n":1},"1":{"v":"\n# 收到罚单的处理方法\n\n1、认罪、交罚款；\n2、不认罪、申诉；\n3、认罪、但是找个理由求情，希望法官减少甚至撤销罚款。\n\n# 罚单\n\n![](/assets/images/2021-11-06-15-45-13.png)\n\n第一项为 Ciation Number : Ciation number 是这张罚单的罚单号，你可以根据此号码在 DMV 系统里查询具体罚单信息。\n\n第二项为 Violation Code : 这一项是写书面声明 Written Declaration 最重要的一项，你要根据警察在上面书写的交通法编码具体了解你违反了哪像法律法规，法律的具体内容规定又是什么，因此才可以知道怎样为自己进行有效的无罪辩护。常见的 Violation Code 包括 22349,22350 超速；22450 Stop Sign 未停等。\n\n第三项为 Court Date : 这一日期是你的出庭日期，在这个时间之前的任意一天，都可以选择递交 Written Declaration。\n\n第四项为 Court Address : 这一地址为你应上庭的法院地址，一般也为你上交书面辩护的地方。\n\n# Top 10 Traffic Violations\n\n1. Speeding\n2. Failure to stop at a red light\n3. violating pedestrian right-of-way in a crosswalk\n4. running stop signs\n5. failing to yield while turning. \n","n":0.126}}},{"i":193,"$":{"0":{"v":"Writter_declaration","n":1},"1":{"v":"\n![](/assets/images/2021-11-06-15-45-59.png)\n\n第一项为固定标题结尾 : 标题结尾请按照模板的具体内容，一字不差地摘抄上去哟！这是法院规定的开头结尾，记得写好打印出来之后，在最下方签字并标上书写日期。\n\n开头：I plead Not Guilty to violating citation code. Please review my statement as evidence below:\n\n结尾：Please dismiss my citation in the interest of justice. I declare under penalty of per jury under the laws of the State of Californiathat the foregoing is true and correct.\n\n第二项为场景陈述模板 : 这一项记得对当时的开车场景进行具体描述。如哪年哪月大约几点，天气交通状况，以及当时是否有其他人同你一起在车内等情况，并描述自己是如何被警察 pull over 等等，细节越细，可信度就越高。\n\n第三项为法律条款: 这一项就要根据你的 ticket 上面的 violation code 来进行分情况叙述啦！首先的建议为摘抄一遍这条法律条款的原文，然后根据法律条款里的规定进行咬！文！嚼！字！对，没错！就是使劲儿抓它的叙述漏洞！如果你认为你的英文水平不够，没关系，google “how to fight violation code xxxx”，总有一波好心大神在网站上造福人类~\n\n第四项为固定说法模板: 这一固定说法写在事实陈述段落的最后一句，Therefore, based upon the evidences I listed, I do not think I violate California traffic code xxxx.\n\n除去书面申诉，其他任何你认为有帮助解释被 Pull over 时交通情景的照片、图表、医生假条以及视频等任何形式的证据都可以成为呈堂证供，随 written declaration 一起上交给法院。\n\n# 流程\n\n进入法院后，首先前往 Traffic Clerk‘s Office 进行排队，等待窗口人员办理业务。\n\n轮到你后，请向办公人员递交罚单、驾照并且记得说 “Can I request the form of Trial by Written Declaration? ”，随后工作人员便会帮助你查询罚单信息，获取表格。\n\n交保释金，领取收据\n虽然 Trial By Written Declaration 是完全免费的，但是在你申请获取表格时，仍需要首先支付 Bail 也就是保释金。保释金的数额是罚单的罚款，但是放心，一但最后法官判定是 Not Guilty，这一笔保释金会立即以支票的形式退还给你~ 所以前往法院时，不要忘记准备一张个人支票。\n\n按照办公人员的要求填写好个人支票上交后，你就会领到表格开始填写啦！\n\n![](/assets/images/2021-11-06-15-47-21.png)\n\n第一项为法院填写项，你不用填任何信息！ \n\n第二项为辅助证据项：如果有准备除 Statements of Facts 以外的照片、图表、医生证明等额外证据，需要在这里进行勾选。\n\n第二页需要填写自己的姓名，以及邮寄地址 (一定要填写收信地址哟！之后的判决结果以及退还的支票都会退还给这个地址)，在Statements of Facts 那里书写 “Please Review Attachment 1” 等字样，最后签名标注当天日期。并把所有已经准备的证据和书写申辩放在标的最后，交给工作人员。\n\n等待法院判决结果\n法院一般会在递交书面申请书后的一个半月至两个月内给出判决结果，会以信件的形式邮寄给你，所以请记得注意查收哟！\n\n法院判决结果为 Not Guilty，那么恭喜你，怎样交出去的钱，就怎么样收回来！如果结果为减少罚款金额或者仍未全额付款，没关系，你还可以选择上庭申诉以此来拖延时间。\n\n以支票形式退换保释金\n如果法官的判决结果为 Not Guilty 无罪，那么你将在收到法官判决书的 1-2 星期收到法院给你寄来的保释金退款支票。注意，支票并不是和判决书一起，所以请耐心等待，你的支票分分钟回到你的口袋~\n\n","n":0.087}}},{"i":194,"$":{"0":{"v":"Automation","n":1},"1":{"v":"\n我自己有一些好用的automation的service，这里记录一下怎么用\n","n":1}}},{"i":195,"$":{"0":{"v":"Xiaoaigpt","n":1},"1":{"v":"\n# Xiaoaigpt\n\n使用xiaoai 和gpt相结合做的。\n\n## source code\n\nhttps://github.com/cczhong11/xiaogpt.git\n\n## set up\n\n1. use docker\n2. `sudo docker build -t tczhong24/xiaogpt .`\n3. `sudo docker run tczhong24/xiaogpt --config=/app/xiaogpt.config --use_chatgpt_api --use_command`\n\n## rerun every 20 minutes script\n\n```bash\n#!/bin/bash\nCONTAINER_NAME=\"6639477c3c3c\"\n\nsudo docker stop $CONTAINER_NAME\nsudo docker start $CONTAINER_NAME\n```\n\nadd to sudo crontab","n":0.167}}},{"i":196,"$":{"0":{"v":"Photohub","n":1}}},{"i":197,"$":{"0":{"v":"Photobackup","n":1},"1":{"v":"\n# Photobackup\n\n## 备份核心硬盘\n\nMy Book\n\n## 数据库\n\n- table /Users/tianchenzhong/Dropbox/TCCode/script/img/summary_my_photo/db_model.py\n- main db /Volumes/My Book/my_life_summary.db\n\n## 程序\n\n1. 分类程序 /Users/tianchenzhong/Dropbox/TCCode/all_in_one_backend/util_moving_img_video_files.py\n2. 手机分类 /Users/tianchenzhong/Dropbox/TCCode/all_in_one_backend/util_phone_moving_img_video_files.py\n3. 插入数据库 /Users/tianchenzhong/Dropbox/TCCode/script/img/summary_my_photo/main.py\n4. 看看文件有没有被删 /Users/tianchenzhong/Dropbox/TCCode/script/img/summary_my_photo/check_delete.py\n\n## 手机照片\n\n- iphone 12：2024-1-6\n- iphone 13 pro：204-1-29\n\n### 清理\n\n/Users/tianchenzhong/Dropbox/TCCode/script/img/delete_duplicate_iphone_photo.py","n":0.192}}},{"i":198,"$":{"0":{"v":"Personal_backend","n":1},"1":{"v":"\n# backend\n\n/Users/tianchenzhong/Dropbox/TCCode/webserver/personal_dashboard_backend\n\nflask RESTFUL backend\n\nDB is in the file system and json format\n\nbackup to s3 twice a day\n\n## api to show random text\n\nrandom sample some static text file\n## location db\n\none api to log my current location with iphone scriptable \n\n## docker\n\ndocker run -p 219:219 -d -v $PWD/data:/app/data/ tczhong24/personal_backend\n\n# frontend\n\npath: /Users/tianchenzhong/Dropbox/TCCode/webserver/personal_dashboard\n\nuse github page to host\n\nuse ant-design components","n":0.135}}},{"i":199,"$":{"0":{"v":"Memo","n":1},"1":{"v":"\nhttps://github.com/usememos/memos\n\n\nuse docker\n\ndata is backed up to s3 twice a day\n\nhttps://s3.console.aws.amazon.com/s3/buckets/backup-tcz?region=us-west-1&prefix=db/&showversions=false","n":0.316}}},{"i":200,"$":{"0":{"v":"Macos_log","n":1},"1":{"v":"\n# why\n\n想记录自己的macos使用情况，以便自动知道自己每天在做什么\n\n# how\n\n在/Users/tianchenzhong/Dropbox/TCCode/chronos/applescript/what_i_do.py 里我使用了applescript来获取当前的活动窗口，然后记录到dropbox/生活/个人/整理 总结/macos_log\n\n# setup\n\n在crontab需要注册","n":0.408}}},{"i":201,"$":{"0":{"v":"Indeed","n":1},"1":{"v":"\n# Indeed\n\n分为两部分，原因是反爬虫机制比较强\n\n## search page\n\n通过indeed job search api 获取数据，存在sqlite中\n\n## get detail info\n\n获取每个job的详细信息，存在sqlite中\n\n## sqlite column\n\n```\nTable(\"indeed\", metadata,\n          Column('Id', String, primary_key=True, nullable=False),\n          Column('Date', Date), Column('Company', String),\n          Column('Title', String), Column('Review', Float),\n          Column('Experience', String),\n          Column('Citizen', Boolean),\n          Column('Type', String),\n          Column('H1B', String), Column('Fulltime', String),\n          Column('City', String), Column('State', String),\n          Column('Link', String),\n          Column('Clicked', Integer),\n          Column('Liked', Integer),\n          Column('Disliked', Integer),\n          Column('ApplyLink', String),\n          Column('Expire', Boolean),\n          Column('TestCount', Integer),\n          Index('date_index', 'Date'), Index('state_index', 'State'))\n\n```","n":0.131}}},{"i":202,"$":{"0":{"v":"Cmu_assistant","n":1},"1":{"v":"\npath: /Users/tianchenzhong/Dropbox/TCCode/webserver/mp_server \n\nsudo python main_mp.py\n\nsave data in the /home/ubuntu/data","n":0.333}}},{"i":203,"$":{"0":{"v":"Chatgpt","n":1},"1":{"v":"\n# telegram\n\npath: /Users/tianchenzhong/Dropbox/TCCode/webserver/chatgpt\n\n`python main.py`\n\nuse openai python api and telegram to build telegram bot\n# wechat\n\npath: /Users/tianchenzhong/Dropbox/TCCode/webserver/mp_server\n\n`sudo python main_mp.py`\n\nuse a new class to cache the result\n\n# self host web\n\n## english improve\n\n/Users/tianchenzhong/Dropbox/TCCode/webserver/openai_app\n\nnpm start\n\n","n":0.183}}},{"i":204,"$":{"0":{"v":"Book","n":1},"1":{"v":"\npath: /Users/tianchenzhong/Dropbox/TCCode/ML/summary\n\n1. use `load_book.py` to use qdrant and openai api to get embedding and save to local db\n2. use `webui.py` to use gradio to ask question with openai api\n","n":0.186}}},{"i":205,"$":{"0":{"v":"Archivebo","n":1},"1":{"v":"\nhttps://archivebox.io/\n\n1. setup `docker run -v $PWD/data:/data -it archivebox/archivebox:dev init --setup docker run -v $PWD/archive_box_data:/data -it archivebox/archivebox:dev init --setup`\n\n\nhttps://github.com/ArchiveBox/ArchiveBox/wiki/Configuration#archive-method-toggles\n\n```\nSAVE_PDF=False\nSAVE_GIT=False\nSAVE_SCREENSHOT=False\nSAVE_MERCURY=False\nSAVE_READABILITY=False\nSAVE_WARC=False\n```\n\n","n":0.236}}},{"i":206,"$":{"0":{"v":"All_in_one","n":1},"1":{"v":"\n# base component\n\n- DataFetcher\n- DataReader\n- DataWriter\n- DataPusher\n- DataExtractor\n\n# use case\n\n1. 1point3arces to telegram\n2. amc to notion\n3. gmail to google sheet\n4. google sheet to rss\n5. inoreader to tag\n6. google sheet to toggle\n7. book to rss\n","n":0.171}}},{"i":207,"$":{"0":{"v":"Dropbox","n":1},"1":{"v":"\ndropbox的auth 流程比较麻烦。\n\n1. https://www.dropbox.com/oauth2/authorize?client_id=[clint_id]&response_type=code&token_access_type=offline 拿到access token\n2. https://api.dropboxapi.com/oauth2/token 拿到refresh token\n3. 在python client里用app key ， app secret， refresh token 拿到access token","n":0.236}}},{"i":208,"$":{"0":{"v":"Development","n":1}}},{"i":209,"$":{"0":{"v":"Lang","n":1}}},{"i":210,"$":{"0":{"v":"Python","n":1}}},{"i":211,"$":{"0":{"v":"Test","n":1},"1":{"v":"\nI found one of my unittest always return the prod data and it is very strange to me.\n\nAfter digging into the python unittest I finally know why.\n\nFor example\n\n```py\n# file1.py\n\ndef foo():\n\treturn \"2\"\n\n# file2.py\nfrom file1 import foo\n\ndef bar()\n\treturn foo()\n\n```\n\nNow we want to test it\n\nif we do this\n```\n@patch(\"file1.foo\", return_value=\"3\")\ndef test_bar(self, mock:MagicMock):\n\tself.assertTrue(bar(), \"3\")\n```\n\nIt would throw errors\n\nWe need to do this\n\n```\n@patch(\"file2.foo\", return_value=\"3\")\ndef test_bar(self, mock:MagicMock):\n\tself.assertTrue(bar(), \"3\")\n```\n","n":0.129}}},{"i":212,"$":{"0":{"v":"Web","n":1},"1":{"v":"\n\n# whole picture\n\nuser request -> server -> Database\n\n## How request get to server\n\n1. Network layer\n2. Network protocl\n3. Load balancing\n\n\n## How server organize together\n\n1. Distributed System\n","n":0.2}}},{"i":213,"$":{"0":{"v":"Secure","n":1},"1":{"v":"\n# https\n\n![](/assets/images/2022-10-18-22-21-09.png)","n":0.707}}},{"i":214,"$":{"0":{"v":"Tools","n":1}}},{"i":215,"$":{"0":{"v":"Zsh","n":1},"1":{"v":"# install\n\n```\nbrew install zsh\n```\n\noh-my-zsh\n\n```\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n```\n\n## themes\n\nclone到  ~/.oh-my-zsh/themes\n修改`~/.zshrc` ZSH_THEME=\" \"\n\n- git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\n- powerlevel10k/powerlevel10k\n\n## plugin\n\n- autojump \n  - brew install autojump\n- zsh-autosuggestions\n  - git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n- zsh-syntax-highlighting\n  - git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n- bat\n  - add syntax in cat\n- sudo\n  - type esc esc twice to add sudo\n## tip\n\n- 在当前目录下输入 .. 或 ... ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。\n- 目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。\n- 命令参数补全。键入 kill <tab> 就会列出所有的进程名和对应的进程号\n- 通配符搜索：ls -l **/*.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find。使用 **/ 来递归搜索\n- zsh_stats: Get a list of the top 20 commands and how many times they have been run.\n- take: Create a new directory and change to it, will create intermediate directories as required.\n- x / extract: Extract an archive (supported types: tar.{bz2,gz,xz,lzma}, bz2, rar, gz, tar, tbz2, tgz, zip, Z, 7z).\n- osx\n\n## alias \n\n| Flag | Description                                    |\n| ---- | ---------------------------------------------- |\n| L    | print each alias in the form of calls to alias |\n| g    | list or define global aliases                  |\n| m    | print aliases matching specified pattern       |\n| r    | list or define regular aliases                 |\n| s    | list or define suffix aliases                  |\n\n## Directory\n| Flag  | Description                           |\n| ----- | ------------------------------------- |\n| ..    | cd ..                                 |\n| ...   | cd ../..                              |\n| ....  | cd ../../..                           |\n| ..... | cd ../../../..                        |\n| /     | cd /                                  |\n| ~     | cd ~                                  |\n| md    | mkdir -p                              |\n| rd    | rmdir                                 |\n| d     | dirs -v (lists last used directories) |\n\n## osx\n| Flag        | Description                                         |\n| ----------- | --------------------------------------------------- |\n| tab         | Open the current directory in a new tab             |\n| split_tab   | Split the current terminal tab horizontally         |\n| vsplit_tab  | Split the current terminal tab vertically           |\n| ofd         | Open the current directory in a Finder window       |\n| pfd         | Return the path of the frontmost Finder window      |\n| pfs         | Return the current Finder selection                 |\n| cdf         | cd to the current Finder directory                  |\n| pushdf      | pushd to the current Finder directory               |\n| pxd         | Return the current Xcode project directory          |\n| cdx         | cd to the current Xcode project directory           |\n| quick-look  | Quick-Look a specified file                         |\n| man-preview | Open a specified man page in Preview app            |\n| showfiles   | Show hidden files in Finder                         |\n| hidefiles   | Hide the hidden files in Finder                     |\n| itunes      | DEPRECATED. Use music from macOS Catalina on        |\n| music       | Control Apple Music. Use music -h for usage details |\n| spotify     | Control Spotify and search by artist, album, track… |\n| rmdsstore   | Remove .DS_Store files recursively in a directory   |","n":0.049}}},{"i":216,"$":{"0":{"v":"Vim","n":1},"1":{"v":"\n# move\n\n- h,j,k,l\n- w,b,e\n- G: go to top\n- gg: go to end\n- { }, skip a block of code\n- V: select line\n- ctrl-v: select block of code (same column)\n- ^: begin line, $: end of line \n- t/f + char: go to the specific char in the line\n- %: go to specific parenthese\n- *: search for other instance\n\n# change\n\n- u: undo\n- ctrl+r: redo\n- yy: Copy line\n- p: paste below\n- P: paste above\n- dd\n- dw\n- D: delete to the end of line \n- o: insert line below\n- O: insert line above\n- c: change \n- x: delete char\n- ~: change the case of char \n- r: replace char\n- > < : 增加缩小缩进\n- yt+char:复制到那个char\n\n# search\n\n替换改行的第一个old单词为new\n:s/old/new\n\n替换改行的所有old单词为new\n:s/old/new/g\n\n替换两个# 之间的单词\n`:#,#s/old/new/g`\n\n替换文件中所有的单词\n:%s/old/new/g\n\n每一个替换之前都需要确认的话，在命令末尾加一个 c\n:%s/old/new/gc\n\n\n# Config\n\n## basic\n\n- filetype on  \n  - \" Enable type file detection. Vim will be able to try to detect the type of file in use.\n- filetype plugin on\n- filetype indent on\n- syntax on\n- set number\n  - show line number\n- set cursorline\n  - Highlight cursor line underneath the cursor horizontally.\n- set shiftwidth=4\n- set tabstop=4\n- set hlsearch\n- set incsearch\n    - While searching though a file incrementally highlight matching characters as you type.\n- set showmatch\n  - Show matching words during a search.\n- set history=1000\n  - Set the commands to save in history default number is 20.\n- set wildmenu\n  - Enable auto completion menu after pressing TAB.\n- set wildmode=list:longest\n- set wildignore=*.docx,*.jpg,*.png,*.gif,*.pdf,*.pyc,*.exe,*.flv,*.img,*.xlsx\n- set ttyfast\n- set showmode\n- set encoding=utf-8\n- \n## status bar\n\n```\n\" STATUS LINE ------------------------------------------------------------ {{{\n\n\" Clear status line when vimrc is reloaded.\nset statusline=\n\n\" Status line left side.\nset statusline+=\\ %F\\ %M\\ %Y\\ %R\n\n\" Use a divider to separate the left side from the right side.\nset statusline+=%=\n\n\" Status line right side.\nset statusline+=\\ ascii:\\ %b\\ hex:\\ 0x%B\\ row:\\ %l\\ col:\\ %c\\ percent:\\ %p%%\n\n\" Show the status on the second to last line.\nset laststatus=2\n\n\" }}}\n```\n\n%F – Display the full path of the current file.\n\n%M – Modified flag shows if file is unsaved.\n\n%Y – Type of file in the buffer.\n\n%R – Displays the read-only flag.\n\n%b – Shows the ASCII/Unicode character under cursor.\n\n0x%B – Shows the hexadecimal character under cursor.\n\n%l – Display the row number.\n\n%c – Display the column number.\n\n%p%% – Show the cursor percentage from the top of the file.\n## key mapping\n\nmap_mode <what_you_type> <what_is_executed>\n\nnnoremap – Allows you to map keys in normal mode.\ninoremap – Allows you to map keys in insert mode.\nvnoremap – Allows you to map keys in visual mode.\n\n## use\n\n- add `~/.vimrc`\n- load `:so %`","n":0.051}}},{"i":217,"$":{"0":{"v":"Tmux","n":1},"1":{"v":"\n# basic concept\n\n\n在Tmux逻辑中，需要分清楚Server > Session > Window > Pane这个大小和层级顺序是极其重要的，直接关系到工作效率：\n\n- Server：是整个tmux的后台服务。有时候更改配置不生效，就要使用tmux kill-server来重启tmux。\n- Session：是tmux的所有会话。我之前就错把这个session当成窗口用，造成了很多不便里。一般只要保存一个session就足够了。\n- Window：相当于一个工作区，包含很多分屏，可以针对每种任务分一个Window。如下载一个Window，编程一个window。\n- Pane：是在Window里面的小分屏。最常用也最好用\n\n# common command \n\n```bash\n\n#启动新session：\n$ tmux [new -s 会话名 -n 窗口名]\n\n#恢复session：\n$ tmux at [-t 会话名]\n\n#列出所有sessions：\n$ tmux ls\n\n#关闭session：\n$ tmux kill-session -t 会话名\n\n#关闭整个tmux服务器：\n$ tmux kill-server\n\n# 列出所有快捷键，及其对应的 Tmux 命令\n$ tmux list-keys\n\n# 列出所有 Tmux 命令及其参数\n$ tmux list-commands\n\n# 列出当前所有 Tmux 会话的信息\n$ tmux info\n\n# 重新加载当前的 Tmux 配置\n$ tmux source-file ~/.tmux.conf\n```\n\n## system\n\n| 前缀   | 指令   | 描述                                   |\n| ------ | ------ | -------------------------------------- |\n| Ctrl+b | ?      | 显示快捷键帮助文档                     |\n| Ctrl+b | d      | 断开当前会话                           |\n| Ctrl+b | D      | 选择要断开的会话                       |\n| Ctrl+b | Ctrl+z | 挂起当前会话                           |\n| Ctrl+b | r      | 强制重载当前会话                       |\n| Ctrl+b | s      | 显示会话列表用于选择并切换             |\n| Ctrl+b | :      | 进入命令行模式，此时可直接输入ls等命令 |\n| Ctrl+b | [      | 进入复制模式，按q退出                  |\n| Ctrl+b | ]      | 粘贴复制模式中复制的文本               |\n| Ctrl+b | ~      | 列出提示信息缓存                       |\n\n## window\n\n| 前缀   | 指令 | 描述                                     |\n| ------ | ---- | ---------------------------------------- |\n| Ctrl+b | c    | 新建窗口                                 |\n| Ctrl+b | &    | 关闭当前窗口                             |\n| Ctrl+b | 0~9  | 切换到指定窗口                           |\n| Ctrl+b | p    | 切换到上一窗口                           |\n| Ctrl+b | n    | 切换到下一窗口                           |\n| Ctrl+b | w    | 打开窗口列表，用于且切换窗口             |\n| Ctrl+b | ,    | 重命名当前窗口                           |\n| Ctrl+b | .    | 修改当前窗口编号（适用于窗口重新排序）   |\n| Ctrl+b | f    | 快速定位到窗口（输入关键字匹配窗口名称） |\n\n## panel\n\n| 前缀   | 指令        | 描述                                                           |\n| ------ | ----------- | -------------------------------------------------------------- |\n| Ctrl+b | \"           | 当前面板上下一分为二，下侧新建面板                             |\n| Ctrl+b | %           | 当前面板左右一分为二，右侧新建面板                             |\n| Ctrl+b | x           | 关闭当前面板（关闭前需输入y or n确认）                         |\n| Ctrl+b | z           | 最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）       |\n| Ctrl+b | !           | 将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效） |\n| Ctrl+b | ;           | 切换到最后一次使用的面板                                       |\n| Ctrl+b | q           | 显示面板编号，在编号消失前输入对应的数字可切换到相应的面板     |\n| Ctrl+b | {           | 向前置换当前面板                                               |\n| Ctrl+b | }           | 向后置换当前面板                                               |\n| Ctrl+b | Ctrl+o      | 顺时针旋转当前窗口中的所有面板                                 |\n| Ctrl+b | 方向键      | 移动光标切换面板                                               |\n| Ctrl+b | o           | 选择下一面板                                                   |\n| Ctrl+b | 空格键      | 在自带的面板布局中循环切换                                     |\n| Ctrl+b | Alt+方向键  | 以5个单元格为单位调整当前面板边缘                              |\n| Ctrl+b | Ctrl+方向键 | 以1个单元格为单位调整当前面板边缘（Mac下                       |\n| Ctrl+b | t           | 显示时钟                                                       |\n\n# config\n\n- set-option -g mouse on\n  - 支持鼠标\n- 状态栏\n\n```\nset -g base-index 1           # start windows numbering at 1\nset -g status-utf8 on # 状态栏支持utf8\nset -g status-interval 1 # 状态栏刷新时间\nset -g status-justify left # 状态栏列表左对齐\nsetw -g monitor-activity on # 非当前窗口有内容更新时在状态栏通知\nset -g set-titles on          # set terminal title\nset -wg window-status-format \" #I #W \" # 状态栏窗口名称格式\nset -wg window-status-current-format \" #I:#W#F \" # 状态栏当前窗口名称格式(#I：序号，#w：窗口名称，#F：间隔符)\nset -wg window-status-separator \"\" # 状态栏窗口名称之间的间隔\n```\n- vim 模式\n\n```\n# vi模式，v开始选择，y 复制选择内容到剪贴板\n# Use vim bindings\nsetw -g mode-keys vi\n```\n\n- 调整窗口大小\n\n```\n# ctrl + k/j/h/l 调整pane大小\n# resize pane\nbind -r ^k resizep -U 10 # upward (prefix Ctrl+k)\nbind -r ^j resizep -D 10 # downward (prefix Ctrl+j)\nbind -r ^h resizep -L 10 # to the left (prefix Ctrl+h)\nbind -r ^l resizep -R 10 # to the right (prefix Ctrl+l)\n```\n\n```\nbind r source-file ~/.tmux.conf \\; display '~/.tmux.conf sourced'\nset -g prefix2 C-a                        # GNU-Screen compatible prefix\nbind C-a send-prefix -2\n```\n\n\n# good one\n\n- https://github.com/gpakosz/.tmux\n\n# save tmux session\n\n- https://github.com/tmux-plugins/tmux-continuum","n":0.047}}},{"i":218,"$":{"0":{"v":"Service_mesh","n":1},"1":{"v":"\n[reference](https://philcalcado.com/2017/08/03/pattern_service_mesh.html)\n\nA service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the service mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.\n\n![](/assets/images/2021-05-06-22-27-43.png)\n\nIn such model, each of your services will have a companion proxy sidecar. Given that services communicate with each other only through the sidecar proxy, we end up with a deployment similar to the diagram below:\n\n![](/assets/images/2021-05-06-22-27-11.png)\n\n下面以 Istio 为例讲解 Service Mesh 如何工作，后续文章将会详解 Istio 如何在 Kubernetes 中工作。\n\n1. Sidecar（Istio 中使用 Envoy 作为 sidecar 代理）将服务请求路由到目的地址，根据请求中的参数判断是到生产环境、测试环境还是 staging 环境中的服务（服务可能同时部署在这三个环境中），是路由到本地环境还是公有云环境？所有的这些路由信息可以动态配置，可以是全局配置也可以为某些服务单独配置。这些配置是由服务网格的控制平面推送给各个 sidecar 的，\n2. 当 sidecar 确认了目的地址后，将流量发送到相应服务发现端点，在 Kubernetes 中是 service，然后 service 会将服务转发给后端的实例。\n3. Sidecar 根据它观测到最近请求的延迟时间，选择出所有应用程序的实例中响应最快的实例。\n4. Sidecar 将请求发送给该实例，同时记录响应类型和延迟数据。\n5. 如果该实例挂了、不响应了或者进程不工作了，sidecar 会将把请求发送到其他实例上重试。\n6. 如果该实例持续返回 error，sidecar 会将该实例从负载均衡池中移除，稍后再周期性得重试。\n7.如果请求的截止时间已过，sidecar 主动标记该请求为失败，而不是再次尝试添加负载。\n8. SIdecar 以 metric 和分布式追踪的形式捕获上述行为的各个方面，这些追踪信息将发送到集中 metric 系统。\n","n":0.085}}},{"i":219,"$":{"0":{"v":"Hugo","n":1},"1":{"v":"\n# hugo template\n\n基于[go html template](https://pkg.go.dev/text/template)\n\n## variables\n\n```go\n{{ .Title }}\n{{ $address }}\n{{ $address := \"123 Main St.\" }}\n```\n\n## functions\n\n```go\n{{ FUNCTION ARG1 ARG2 .. }}\n{{ add 1 2 }}\n```\n\n## include\n\n```go\n{{ partial \"header.html\" . }}\n{{ template \"_internal/opengraph.html\" . }}\n```\n\n## logic\n\n```go\n// iteration\n{{ range $array }}\n    {{ . }} <!-- The . represents an element in $array -->\n{{ end }}\n\n{{ range $elem_val := $array }}\n    {{ $elem_val }}\n{{ end }}\n\n{{ range $elem_index, $elem_val := $array }}\n   {{ $elem_index }} -- {{ $elem_val }}\n{{ end }}\n\n{{ range $array }}\n    {{ . }}\n{{else}}\n    <!-- This is only evaluated if $array is empty -->\n{{ end }}\n// condition\n{{ with .Params.title }}\n    <h4>{{ . }}</h4>\n{{ end }}\n\n{{ with .Param \"description\" }}\n    {{ . }}\n{{ else }}\n    {{ .Summary }}\n{{ end }}\n\n{{ if (isset .Params \"description\") }}\n    {{ index .Params \"description\" }}\n{{ else }}\n    {{ .Summary }}\n{{ end }}\n\n{{ if (and (or (isset .Params \"title\") (isset .Params \"caption\")) (isset .Params \"attr\")) }}\n```\n\n## pipes\n\n```go\n\n{{ (seq 1 5) | shuffle }}\n{{ index .Params \"disqus_url\" | html }}\n```\n\n## context\n\nThe most easily overlooked concept to understand about Go Templates is that {{ . }} always refers to the current context.\n\nIn the top level of your template, this will be the data set made available to it.\nInside of an iteration, however, it will have the value of the current item in the loop; i.e., {{ . }} will no longer refer to the data available to the entire page.\n\n\n`$` to access global context\n```go\n<ul>\n{{ range .Params.tags }}\n  <li>\n    <a href=\"/tags/{{ . | urlize }}\">{{ . }}</a>\n            - {{ $.Site.Title }}\n  </li>\n{{ end }}\n</ul>\n```\n\n## whitespace\n\n```go\n<div>\n  {{- .Title -}}\n</div>\n\n<div>Hello, World!</div>\n```","n":0.062}}},{"i":220,"$":{"0":{"v":"Configeration_management","n":1},"1":{"v":"\n# CM\n\nThe software configuration management (SCM) process is looked upon by practitioners as the best solution to handling changes in software projects. It identifies the functional and physical attributes of software at various points in time, and performs systematic control of changes to the identified attributes for the purpose of maintaining software integrity and traceability throughout the software development life cycle.\n\nThe SCM process further defines the need to trace changes, and the ability to verify that the final delivered software has all of the planned enhancements that are supposed to be included in the release. It identifies four procedures that must be defined for each software project to ensure that a sound SCM process is implemented. They are:\n\nConfiguration identification\nConfiguration control\nConfiguration status accounting\nConfiguration audits\nThese terms and definitions change from standard to standard, but are essentially the same.\n\nConfiguration identification is the process of identifying the attributes that define every aspect of a configuration item. A configuration item is a product (hardware and/or software) that has an end-user purpose. These attributes are recorded in configuration documentation and baselined. Baselining an attribute forces formal configuration change control processes to be effected in the event that these attributes are changed.\nConfiguration change control is a set of processes and approval stages required to change a configuration item's attributes and to re-baseline them.\nConfiguration status accounting is the ability to record and report on the configuration baselines associated with each configuration item at any moment of time.\nConfiguration audits are broken into functional and physical configuration audits. They occur either at delivery or at the moment of effecting the change. A functional configuration audit ensures that functional and performance attributes of a configuration item are achieved, while a physical configuration audit ensures that a configuration item is installed in accordance with the requirements of its detailed design documentation.\n","n":0.058}}},{"i":221,"$":{"0":{"v":"Chef","n":1},"1":{"v":"\n# chef \n\n- 环境管理\n- 以自动化的方式进行服务器环境初始化或变更工作\n\n## environment\n\nChef环境由三个部分组成：Chef server，Workstation, Node（Client）。\n\nChef server是Chef环境的中枢，其中存储了基础设施环境的信息。你可以使用开源Chef server，也可以使用Chef官方提供的商业服务：Enterprise Chef。\n\nWorkstation是你的工作台，一般情况下就是你的开发机器。你会在Workstation中创建cookbook，并且上传到Chef server，以及其他与Chef相关的工作。\n\n一个Node就是你基础设施环境中的一台服务器，也就是你用Chef来管理的机器。\n\n一个Node可以是一台物理机器，一个虚拟机，也可以是cloud环境中的一个instance，甚至是你网络环境中的一个交换机或路由器。\n\n如果你想要在Node上部署环境，那么Node会与Chef server进行交互获取信息，并在Node上执行环境初始化操作。\n\n## recipe\n\n\n每个cookbook都会包含一到多个recipe（默认是default.rb）。一个recipe就是实现cookbook所描述场景的步骤。看以下这个简单的recipe：\n```\npackage 'apache2' do\n  action :install\nend\n\nservice 'apache2' do\n  action [ :enable, :start ]\nend\n\ncookbook_file '/var/www/index.html' do\n  source 'index.html'\n  mode '0644'\nend\n```\n\n可以看出这个recipe分为三个步骤，分别是安装apache2、启动apache2、拷贝文件。\n\n## resource和provider\n\nresource就是recipe中的配置项，可以是package、service、bash等等。provider就是为这些resource提供实现的程序。以编程语言来描述的话，resource定义了接口，provider提供了不同平台的实现。","n":0.177}}},{"i":222,"$":{"0":{"v":"Cicd","n":1},"1":{"v":"\nContinuous Integration and continuous Delivery (CI/CD) is a set of software practices and techniques that enable the frequent release of small batches of code changes, with extensive visibility and traceability. It typically involves the creation of a largely automated pipeline that orchestrates the build, test and deployment of software across staged environments, ultimately leading to deployment in production.\n\nCI\n\nDuring this process, developers identify bugs at early stages of the development cycle, fix them, and test in an iterative manner. Every time there is a new code change or a bug fix, the build or code compilation process takes place in the developer's private workspace. The developer then integrates the changes into the main code base. Depending on the size of the development team, these multiple builds could be running in parallel. Shorter build times lead to developer creativity that can breed innovation.\n\nCD\n\nAfter the build process and packaging in the CI phase, the final build package is automatically deployed for user acceptance testing before it is released to production. More and more modern applications are running as microservices and containers as the unit of deployment on a platform. The platforms could be any public-cloud environment or containers for platform-as-a-service like Red Hat OpenShift or Pivotal Cloud Foundry. As containers are portable, platform is synonymous with standard operating system like Red Hat, Ubuntu, and others, abstracting the cores and memory required at application run time\n\nContinuous Deployment - refers a system that allows deployment of every new changes that comes in source code from a developer.\nContinuous Delivery - refers the automation of entire software release process.\n\none example with github action [link](https://medium.com/@michaelekpang/creating-a-ci-cd-pipeline-using-github-actions-b65bb248edfe)\n\n## fb \n\n[video](https://www.youtube.com/watch?v=qN6BiLzZGfs)","n":0.061}}},{"i":223,"$":{"0":{"v":"Chef","n":1},"1":{"v":"\nChef is a powerful automation platform that transforms infrastructure into code. Chef is a tool for which you write scripts that are used to automate processes.\n\nChef Server: The Chef Server is the central store of your infrastructure’s configuration data. The Chef Server stores the data necessary to configure your nodes and provides search, a powerful tool that allows you to dynamically drive node configuration based on data.\nChef Node: A Node is any host that is configured using Chef-client. Chef-client runs on your nodes, contacting the Chef Server for the information necessary to configure the node. Since a Node is a machine that runs the Chef-client software, nodes are sometimes referred to as “clients”.\nChef Workstation: A Chef Workstation is the host you use to modify your cookbooks and other configuration data.","n":0.088}}},{"i":224,"$":{"0":{"v":"Bash","n":1},"1":{"v":"\n# key\n\n- ctrl-a:  go to begin of line\n- ctrl-w: 删除前一个单词\n- ctrl-u: 删至行首\n- Option + Left Arrow – to move the cursor backward by a word. \n- Option + Right arrow – to move the cursor forward by a word.","n":0.16}}},{"i":225,"$":{"0":{"v":"Alfred","n":1},"1":{"v":"\n# alfred workflow\n\n\n- Triggers: Activate Alfred from a hotkey, another Alfred feature or an external source.\n- Inputs: Keyword-based objects used to perform an action, on its own or followed by a query.\n- Actions: The objects that do most of the work in your workflows; opening or revealing files and web searches, running scripts and performing commands.\n- Utilities: Utilities give you control over how your objects are connected together and how the arguments output by the previous object is passed on to the next object.\n- Outputs: Collect the information from the earlier objects in your workflow to pop up a Notification Centre message, show output in Large Type, copy to clipboard or run a script containing the result of your workflow.\n\n\n## script filter format in workflow\n\nwe need to return a json like this\n\n```\n{\n    \"items\":[\n        {\n            \"title\":xxx,\n            \"subtitle\":xxx,\n            \"arg\":\"https://xxx\"\n            \"icon\":\"xxx\"\n        }\n    ]\n}\n```\n\n## short key\n\n- option+command+c clipboard history","n":0.083}}},{"i":226,"$":{"0":{"v":"System","n":1}}},{"i":227,"$":{"0":{"v":"Linux","n":1}}},{"i":228,"$":{"0":{"v":"Philosophy","n":1},"1":{"v":"\n1. Small is beautiful. Small things have tremendous advantages over their larger counterparts. Among these is the ability to combine with other small things in unique and useful ways, ways often unforeseen by the original designer.\n2. Make each program do one thing well. By focusing on a single task, a program can eliminate much extraneous code that often results in excess overhead, unnecessary complexity, and a lack of flexibility.\n3. Build a prototype as soon as possible. Most people would agree that prototyping is a valuable element of any project. But whereas prototyping is only a small part of the design phase under other methodologies, under Unix it is the principal vehicle for generating an effective design.\n4. Choose portability over efficiency. When Unix broke new ground as the first portable operating system of any significance, it was big news. Today portability is taken for granted as a necessity in any modern software design, an example of a tenet that has gained wide acceptance on other systems besides Unix.\n5. Store data in flat text files. The choice between portability and efficiency addresses the value of portable code. Portable data is at least as important as-if not more important than-portable code. Portable data is the often-neglected part of the portability formula.\n6. Use software leverage to your advantage. Many programmers have only a superficial understanding of the importance of reusable code modules. Code reuse helps one take advantage of software leverage, a powerful concept that some Unix developers use to create numerous applications in a comparatively short time.\n7. Use shell scripts to increase leverage and portability. Shell scripts are double-edged swords for enhancing both software leverage and portability in a design. Whenever possible, writing a script instead of a complete C program is the way to go.\n8. Avoid captive user interfaces. Some commands have user interfaces known to Unix developers as \"captive\" user interfaces. These prevent the user from running other commands while the command is in use, effectively making the user a captive to the system for the duration of the command. In a graphical user interface world, such interfaces would be called \"modal.\"\n9. **Make every program a filter.** The fundamental nature of all software programs is that they only modify data; they do not create it. Therefore, they should be written to perform as filters since they are filters.\n","n":0.051}}},{"i":229,"$":{"0":{"v":"Virtualization","n":1},"1":{"v":"\n# VM\n\nVirtual machines are based on computer architectures and provide functionality of a physical computer. Their implementations may involve specialized hardware, software, or a combination.\n\n- System virtual machines (also termed full virtualization VMs) provide a substitute for a real machine. They provide functionality needed to execute entire operating systems. A **hypervisor** uses native execution to share and manage hardware, allowing for multiple environments which are **isolated** from one another, yet exist on the same physical machine. Modern hypervisors use hardware-assisted virtualization, virtualization-specific hardware, primarily from the host CPUs.\n- Process virtual machines are designed to execute computer programs in a platform-independent environment. A process VM provides a high-level abstraction – that of a high-level programming language (compared to the low-level ISA abstraction of the system VM). Process VMs are implemented using an interpreter; performance comparable to compiled programming languages can be achieved by the use of just-in-time compilation. JVM\n- Operating-system-level virtualization: docker.  physical server is virtualized at the operating system level, enabling multiple isolated and secure virtualized servers to run on a single physical server. The \"guest\" operating system environments share the same running instance of the operating system as the host system. Thus, the same operating system kernel is also used to implement the \"guest\" environments, and applications running in a given \"guest\" environment view it as a stand-alone system\n\nThe hypervisor sits in between the physical machine and virtual machines and provides virtualization services to the virtual machines. \n\n## How does virtualization work?\n\nSoftware called hypervisors separate the physical resources from the virtual environments—the things that need those resources. Hypervisors take your physical resources and divide them up so that virtual environments can use them.\n\n![](/assets/images/2021-05-03-15-30-39.png)\n\nResources are partitioned as needed from the physical environment to the many virtual environments. Users interact with and run computations within the virtual environment (typically called a guest machine or virtual machine). The virtual machine functions as a single data file. And like any digital file, it can be moved from one computer to another, opened in either one, and be expected to work the same.\n\nWhen the virtual environment is running and a user or program issues an instruction that requires additional resources from the physical environment, the hypervisor relays the request to the physical system and caches the changes—which all happens at close to native speed (particularly if the request is sent through an open source hypervisor based on KVM, the Kernel-based Virtual Machine).\n","n":0.05}}},{"i":230,"$":{"0":{"v":"Containerization","n":1},"1":{"v":"\n# containerization\n\ncode developed on one machine might not work perfectly fine on any other machine because of the dependencies. This problem was solved by the containerization concept. So basically, an application that is being developed and deployed is bundled and wrapped together with all its configuration files and dependencies. This bundle is called a container. Now when you wish to run the application on another system, the container is deployed which will give a bug-free environment as all the dependencies and libraries are wrapped together. Most famous containerization environments are Docker and Kubernetes.\n\n## difference between virtualization\n\nContainers provide an isolated environment for running the application. The entire user space is explicitly dedicated to the application. Any changes made inside the container is never reflected on the host or even other containers running on the same host. Containers are an abstraction of the application layer. Each container is a different application.\n\nWhereas in Virtualization, hypervisors provide an entire virtual machine to the guest(including Kernal). Virtual machines are an abstraction of the hardware layer. Each VM is a physical machine.\n\n![](/assets/images/2021-05-04-23-12-48.png)\n\n## docker\n\nDocker is a containerization platform which packages your application and all its dependencies together in the form of containers so as to ensure that your application works seamlessly in any environment, be it development, test or production. Docker containers, wrap a piece of software in a complete filesystem that contains everything needed to run: code, runtime, system tools, system libraries, etc. It wraps basically anything that can be installed on a server. This guarantees that the software will always run the same, regardless of its environment.\n\nDocker image is the source of Docker container. In other words, Docker images are used to create containers. When a user runs a Docker image, an instance of a container is created. These docker images can be deployed to any Docker environment.\n\nDocker Architecture consists of a Docker Engine which is a client-server application with three major components:\n\n- A server which is a type of long-running program called a daemon process (the docker command).\n- A REST API which specifies interfaces that programs can use to talk to the daemon and instruct it what to do.\n- A command line interface (CLI) client (the docker command).\n- The CLI uses the Docker REST API to control or interact with the Docker daemon through scripting or direct CLI commands. Many other Docker applications use the underlying API and CLI.\n\n\n![](/assets/images/2021-05-04-23-13-20.png)\n\nDocker can build images automatically by reading the instructions from a file called Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Using docker build, users can create an automated build that executes several command-line instructions in succession.\n\nDocker Compose is a YAML file which contains details about the services, networks, and volumes for setting up the Docker application. So, you can use Docker Compose to create separate containers, host them and get them to communicate with each other. Each container will expose a port for communicating with other containers.\n\nDocker Swarm is native clustering for Docker. It turns a pool of Docker hosts into a single, virtual Docker host. Docker Swarm serves the standard Docker API, any tool that already communicates with a Docker daemon can use Swarm to transparently scale to multiple hosts.\n\n### namespace\n\nA namespace is one of the Linux features and an important concept of containers. Namespace adds a layer of isolation in containers. Docker provides various namespaces in order to stay portable and not affect the underlying host system. Few namespace types supported by Docker – PID, Mount, IPC, User, Network\n\n### interview question\n\nWill you lose your data, when a docker container exists?\nNo, you won’t lose any data when Docker container exits. Any data that your application writes to the container gets preserved on the disk until you explicitly delete the container. The file system for the container persists even after the container halts.\n\nWhere all do you think Docker is being used?\n\nWhen asked such a question, respond by talking about applications of Docker. Docker is being used in the following areas:\n\nSimplifying configuration: Docker lets you put your environment and configuration into code and deploy it.\nCode Pipeline Management: There are different systems used for development and production. As the code travels from development to testing to production, it goes through a difference in the environment. Docker helps in maintaining the code pipeline consistency.\nDeveloper Productivity: Using Docker for development gives us two things – We’re closer to production and development environment is built faster.\nApplication Isolation: As containers are applications wrapped together with all dependencies, your apps are isolated. They can work by themselves on any hardware that supports Docker.\nDebugging Capabilities: Docker supports various debugging tools that are not specific to containers but work well with containers.\nMulti-tenancy: Docker lets you have multi-tenant applications avoiding redundancy in your codes and deployments.\nRapid Deployment: Docker eliminates the need to boost an entire OS from scratch, reducing the deployment time.\n\n\nIs it a good practice to run stateful applications on Docker?\nThe concept behind stateful applications is that they store their data onto the local file system. You need to decide to move the application to another machine, retrieving data becomes painful. I honestly would not prefer running stateful applications on Docker.\n\n What changes are expected in your docker compose file while moving it to production?\nThese are the following changes you need make to your compose file before migrating your application to the production environment:\n\nRemove volume bindings, so the code stays inside the container and cannot be changed from outside the container.\nBinding to different ports on the host.\nSpecify a restart policy\nAdd extra services like log aggregator\n\n## Kubernetes\n\nKubernetes is an open-source container management (orchestration) tool. It’s container management responsibilities include container deployment, scaling & descaling of containers & container load balancing.\n\n[reference](https://www.edureka.co/blog/what-is-kubernetes-container-orchestration)\n\n![](/assets/images/2021-05-04-23-30-50.png)","n":0.032}}},{"i":231,"$":{"0":{"v":"Understand","n":1},"1":{"v":"\n# templeate to understand the service\n\n## service context\n\n1. what does the system do\n2. who is the customer, what is their primary use case?\n3. what is the user flow for the primary use case\n4. how is the customer impacted when the system is degraded\n5. what service level objectives have set in order to achieve the desired customer experience\n6. what service level indicators do we use to measure teh experience we want to deliver\n\n## pre-game checklist\n\nbefore blueprint phase\n\n1. toolbox\n   1. runbooks\n   2. pagerduty service\n   3. datadog dashboards\n2. complete the service context\n3. verify the test environment is healthy\n4. prepare and validate load generation test\n5. prepare failure injection with Gremlin\n\n\n## gameday\n\n- roles and responsibility\n  - gameday coordinator\n  - oncall / triage engineers\n  - attendees (observe and validate the situation)\n","n":0.089}}},{"i":232,"$":{"0":{"v":"Scalability","n":1},"1":{"v":"\n# Scalability\n\ndescribe a system’s ability to cope with increased load.\n\n## Load\n\nLoad can be described with a few numbers which we call load parameters\n\nThe best choice of parameters depends on the architecture of your system\n\n## Performance\n\n- When you increase a load parameter and keep the system resources (CPU, memory, network bandwidth, etc.) unchanged, how is the performance of your system affected?\n- When you increase a load parameter, how much do you need to increase the resources if you want to keep performance unchanged?\n\n- throughput (the number of records we can process per second)\n- response time (the time between a client sending a request and receiving a response.)\n\n## scale\n\n- scaling up (**vertical scaling**, moving to a more powerful machine) \n- scaling out (**horizontal scaling**, distributing the load across multiple smaller machines).","n":0.088}}},{"i":233,"$":{"0":{"v":"Reliability","n":1},"1":{"v":"\n# Reliability\n\n- continue to work correctly\n- fault tolerate\n\n\n## Hardware faults\n\n- add redundancy\n  - Disks may be set up in a RAID configuration\n  - servers may have dual power supplies and hot-swappable CPUs\n  - datacenters may have batteries and diesel generators for backup power.\n  - When one component dies, the redundant component can take its place while the broken component is replaced.\n\n## Software errors\n\nbug, process uses up resources, service depends on slow down, cascading failures\n\n- carefully thinking about assumptions and interactions in the system\n- thorough testing, process isolation\n- allowing processes to crash and restart\n- measuring, monitoring and analyzing system behavior in production\n\n\n## human errors\n\nhumans are known to be unreliable.\n\nDesign systems in a way that minimizes opportunities for error.\n\nDecouple the places where people make the most mistakes from the places where they can cause failures. In particular, provide fully featured non-production sandbox environments where people can explore and experiment safely, using real data, without affecting real users.\n\nAllow quick and easy recovery from human errors, to minimize the impact in the case of a failure.","n":0.076}}},{"i":234,"$":{"0":{"v":"Performance","n":1},"1":{"v":"\n![](/assets/images/2021-05-03-16-22-48.png)\n[reference](http://www.brendangregg.com/linuxperf.html)\n\n\n## 2. dmesg | tail\n\n```\n$ dmesg | tail\n[1880957.563150] perl invoked oom-killer: gfp_mask=0x280da, order=0, oom_score_adj=0\n[...]\n[1880957.563400] Out of memory: Kill process 18694 (perl) score 246 or sacrifice child\n[1880957.563408] Killed process 18694 (perl) total-vm:1972392kB, anon-rss:1953348kB, file-rss:0kB\n[2320864.954447] TCP: Possible SYN flooding on port 7001. Dropping request.  Check SNMP counters.\n```\n\nThis views the last 10 system messages, if there are any. **Look for errors that can cause performance issues**. The example above includes the oom-killer, and TCP dropping a request.\nDon’t miss this step! dmesg is always worth checking.\n\nkernel会将开机信息存储在ring buffer中.您若是开机时来不及查看信息，可利用dmesg来查看。开机信息亦保存在/var/log目录中，名称为dmesg的文件里。\n\n\n\n\n## 5. pidstat 1\n\n```\n$ pidstat 1\nLinux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    _x86_64_    (32 CPU)\n\n07:41:02 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command\n07:41:03 PM     0         9    0.00    0.94    0.00    0.94     1  rcuos/0\n07:41:03 PM     0      4214    5.66    5.66    0.00   11.32    15  mesos-slave\n07:41:03 PM     0      4354    0.94    0.94    0.00    1.89     8  java\n07:41:03 PM     0      6521 1596.23    1.89    0.00 1598.11    27  java\n07:41:03 PM     0      6564 1571.70    7.55    0.00 1579.25    28  java\n07:41:03 PM 60004     60154    0.94    4.72    0.00    5.66     9  pidstat\n\n07:41:03 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command\n07:41:04 PM     0      4214    6.00    2.00    0.00    8.00    15  mesos-slave\n07:41:04 PM     0      6521 1590.00    1.00    0.00 1591.00    27  java\n07:41:04 PM     0      6564 1573.00   10.00    0.00 1583.00    28  java\n07:41:04 PM   108      6718    1.00    0.00    0.00    1.00     0  snmp-pass\n07:41:04 PM 60004     60154    1.00    4.00    0.00    5.00     9  pidstat\n```\n\nPidstat is a little like top’s per-process summary, but prints a rolling summary instead of clearing the screen. This can be useful for watching patterns over time, and also recording what you saw (copy-n-paste) into a record of your investigation.\nThe above example identifies two java processes as responsible for consuming CPU. The %CPU column is the total across all CPUs; 1591% shows that that java processes is consuming almost 16 CPUs.\n\n\n\n## 8. sar -n DEV 1\nsar命令用于收集、报告、保存系统活动信息。sar工具是sysstat软件包的一部分。\n\n\n使用cron开启自动化记录报告的示例：\n\n```\n[root@zyg ～]# cat /etc/cron.d/sysstat\n# Run system activity accounting tool every 10 minutes\n*/10 * * * * root /usr/lib64/sa/sa1 -S DISK 1 1\n# 0 * * * * root /usr/lib64/sa/sa1 -S DISK 600 6 &\n# Generate a daily summary of process accounting at 23:53\n53 23 * * * root /usr/lib64/sa/sa2 -A\n```\nsa1命令用来将二进制数据收集和存储到/var/log/sa/sadd文件，dd参数表示当前天的日期。\n\n\n```\n$ sar -n DEV 1\nLinux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015     _x86_64_    (32 CPU)\n\n12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil\n12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00\n12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00\n12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n\n12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil\n12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00\n12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00\n12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n^C\n```\n\n\nUse this tool to check **network interface throughput**: rxkB/s and txkB/s, as a measure of workload, and also to check if any limit has been reached. In the above example, eth0 receive is reaching 22 Mbytes/s, which is 176 Mbits/sec (well under, say, a 1 Gbit/sec limit).\nThis version also has %ifutil for device utilization (max of both directions for full duplex), which is something we also use Brendan’s nicstat tool to measure. And like with nicstat, this is hard to get right, and seems to not be working in this example (0.00).\n\n## 9. sar -n TCP,ETCP 1\n\n```\n$ sar -n TCP,ETCP 1\nLinux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015    _x86_64_    (32 CPU)\n\n12:17:19 AM  active/s passive/s    iseg/s    oseg/s\n12:17:20 AM      1.00      0.00  10233.00  18846.00\n\n12:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s\n12:17:20 AM      0.00      0.00      0.00      0.00      0.00\n\n12:17:20 AM  active/s passive/s    iseg/s    oseg/s\n12:17:21 AM      1.00      0.00   8359.00   6039.00\n\n12:17:20 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s\n12:17:21 AM      0.00      0.00      0.00      0.00      0.00\n^C\n```\n\nThis is a summarized view of some key TCP metrics. These include:\nactive/s: Number of locally-initiated TCP connections per second (e.g., via connect()).\npassive/s: Number of remotely-initiated TCP connections per second (e.g., via accept()).\nretrans/s: Number of TCP retransmits per second.\nThe active and passive counts are often useful as a rough measure of server load: number of new accepted connections (passive), and number of downstream connections (active). It might help to think of active as outbound, and passive as inbound, but this isn’t strictly true (e.g., consider a localhost to localhost connection).\nRetransmits are a sign of a network or server issue; it may be an unreliable network (e.g., the public Internet), or it may be due a server being overloaded and dropping packets. The example above shows just one new TCP connection per-second.\n\n## 10. top\n\n```\n$ top\ntop - 00:15:40 up 21:56,  1 user,  load average: 31.09, 29.87, 29.92\nTasks: 871 total,   1 running, 868 sleeping,   0 stopped,   2 zombie\n%Cpu(s): 96.8 us,  0.4 sy,  0.0 ni,  2.7 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem:  25190241+total, 24921688 used, 22698073+free,    60448 buffers\nKiB Swap:        0 total,        0 used,        0 free.   554208 cached Mem\n\n   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n 20248 root      20   0  0.227t 0.012t  18748 S  3090  5.2  29812:58 java\n  4213 root      20   0 2722544  64640  44232 S  23.5  0.0 233:35.37 mesos-slave\n 66128 titancl+  20   0   24344   2332   1172 R   1.0  0.0   0:00.07 top\n  5235 root      20   0 38.227g 547004  49996 S   0.7  0.2   2:02.74 java\n  4299 root      20   0 20.015g 2.682g  16836 S   0.3  1.1  33:14.42 java\n     1 root      20   0   33620   2920   1496 S   0.0  0.0   0:03.82 init\n     2 root      20   0       0      0      0 S   0.0  0.0   0:00.02 kthreadd\n     3 root      20   0       0      0      0 S   0.0  0.0   0:05.35 ksoftirqd/0\n     5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H\n     6 root      20   0       0      0      0 S   0.0  0.0   0:06.94 kworker/u256:0\n     8 root      20   0       0      0      0 S   0.0  0.0   2:38.05 rcu_sched\n```\n\nThe top command includes many of the metrics we checked earlier. It can be handy to run it to see if anything looks wildly different from the earlier commands, which would indicate that load is variable.\n\n![](/assets/images/2022-04-19-20-20-34.png)\n\n![](/assets/images/2022-04-19-20-20-53.png)\n\n![](/assets/images/2022-04-19-20-21-07.png)\n\n![](/assets/images/2022-04-19-20-21-14.png)\n\n\n## iotop\n","n":0.033}}},{"i":235,"$":{"0":{"v":"Network","n":1},"1":{"v":"\n□　接收和发送的数据包。 这个指标用来通知你，一个给定网络接口接收和发送数据包的数量。\n\n□　接收和发送的字节。 这个指标描述了一个给定网络接口接收和发送的字节数。\n\n□　每秒钟的冲突数量。 这个值给出了在网络上连接的每个接口发生冲突的相对数量。如果发生持续冲突通常要关注网络基础设施的问题，而不是服务器。在大多数正确配置的网络中，冲突一般是非常罕见的，除非网络基础设备是由集线器（HUB）组成的。\n\n□　丢弃的数据包。 已经被内核丢弃的数据包的统计数。丢弃的原因可能是由于防火墙配置，也可能是由于缺乏网络缓冲区。\n\n□　溢出。 该指标表示网络接口溢出缓冲区空间的次数。这个指标应该结合数据包被丢弃的值使用，用来确定是网络缓冲区还是网络队列长度出现瓶颈。\n\n□　错误。 被标记为故障帧的数量。通常这些错误是由网络不匹配或是部分网络电缆中断导致的。部分网络电缆中断对于铜线千兆网络是一个明显的性能问题。\n\n## netstat、ss\nnetstat是最流行的工具之一。如果在网络上工作，你应该熟悉这个工具。它显示许多网络相关的信息，比如socket的使用、路由、接口、协议及网络统计信息等。\n\n替换netstat的是ss，替换netstat -r的是ip route，替换netstat -i的是ip -s link，替换netstat -g的是ip maddr。\n\n```\nroot@zyg ～]# netstat -n\nActive Internet connections (w/o servers)\nProto\tRecv-Q\tSend-Q\tLocal Address\tForeign Address\tState\ntcp\t0\t232\t219.168.5.38:9825\t123.120.27.173:53432\tESTABLISHED\n\nActive UNIX domain sockets (w/o servers)\nProto\tRefCnt\tFlags\tType\tState\tI-Node Path\nunix\t2\t[]\tDGRAM\t14021\t/tmp/fcoemon.dcbd.2162\nunix\t3\t[]\tDGRAM\t13943\t/var/run/lldpad/clif\nunix\t2\t[]\tDGRAM\t14025\t/var/run/fcm/fcm_clif\nunix\t15\t[]\tDGRAM\t24547910\t/dev/log\nunix\t2\t[]\tDGRAM\t9338\t@/org/kernel/udev/udevd\nunix\t2\t[]\tDGRAM\t14336\t@/org/freedesktop/hal/udev_event\nunix\t2\t[]\tDGRAM\t25205379\t\nunix\t2\t[]\tDGRAM\t24548943\t\n```\n\nActive Internet connections\n□　Proto，socket使用的协议（tcp、udp、udpl、raw）。\n\n□　Recv-Q\n\n•　Established，连接这个socket的用户程序非复制的字节数。\n\n•　Listening，从2.6.18内核开始这列包含了当前的syn_backlog。\n\n□　Send-Q\n\n•　Established，远程主机没有确认的字节数。\n\n•　Listening，从2.6.18内核开始这列包含了syn_backlog的最大值。\n\n□　Local Address，socket本地端的地址和端口号。除非指定–numeric（-n）选项，否则socket地址将被解析为规范主机名（FQDN），端口号被翻译成规范服务名称。\n\n□　Foreign Address，socket远程端的地址和端口号。类似“Local Address”。\n\n□　State，socket的状态。因为raw模式没有状态，通常没有状态用于UDP和UDPLite，这列可能保留为空。一般情况下会是以下值之一：\n\n•　ESTABLISHED，socket是一个已经建立的连接。\n\n•　SYN_SENT，socket积极尝试建立一个连接。\n\n•　SYN_RECV，从网络接收到一个连接请求。\n\n•　FIN_WAIT1，socket已关闭，并且连接关闭。\n\n•　FIN_WAIT2，连接已关闭，并且socket等待远程端关闭。\n\n•　TIME_WAIT，连接关闭之后socket等待处理的仍在网中的数据包。\n\n•　CLOSE，socket没有被使用。\n\n•　CLOSE_WAIT，远程端已经关闭，等待socket关闭。\n\n•　LAST_ACK，远程端已经关闭，并且socet已经关闭。等待确认。\n\n•　LISTEN，socket监听进来的连接。在输出中不包含这样的socket，除非你指定--listening（-l）或–all（-a）选项。\n\n•　CLOSING，两端scoket已经关闭，但是仍然没有发送所有的数据。\n\n•　UNKNOWN，socket的状态是未知。","n":0.169}}},{"i":236,"$":{"0":{"v":"Memory","n":1},"1":{"v":"\n空闲内存。 对比大多数其他操作系统，在Linux中不应该只关注空闲（free）内存的值。正如在1.2.2节讲述的，Linux内核分配大部分未使用的内存作为文件系统缓存，所以从已使用的（used）内存中减去缓冲（buffer）和缓存（cache）的内存数量，来确定（有效的）空闲（free）内存。\n\n□　使用的swap。 这个值描述了已使用的swap空间的数量。正如1.2.2节中描述的，swap空间的使用只能告诉你Linux管理内存真的有效。Swap In/Out是一个识别内存瓶颈的可靠手段。在一段持续的时间内每秒200到300以上的分页值，表明可能有内存瓶颈。\n\n□　缓冲与缓存。 缓冲被分配作为文件系统和块设备缓存。\n\n□　Slab。 其描述了内核使用的内存数。注意内核的分页不能移出到磁盘。\n\n□　活跃与非活跃内存。 关于活跃使用的系统内存信息。非活跃内存可能是kswapd守护进程swap out到磁盘的候选者。\n\n\n## free -m\n\n```\n$ free -m\n             total       used       free     shared    buffers     cached\nMem:        245998      24545     221453         83         59        541\n-/+ buffers/cache:      23944     222053\nSwap:            0          0          0\n```\n\nThe right two columns show:\nbuffers: **For the buffer cache, used for block device I/O.**\ncached: **For the page cache, used by file systems**.\nWe just want to check that these aren’t near-zero in size, which can lead to higher disk I/O (confirm using iostat), and worse performance. The above example looks fine, with many Mbytes in each.\nThe “-/+ buffers/cache” provides less confusing values for used and free memory. Linux uses free memory for the caches, but can reclaim it quickly if applications need it. So in a way the cached memory should be included in the free memory column, which this line does. There’s even a website, linuxatemyram, about this confusion.\nIt can be additionally confusing if ZFS on Linux is used, as we do for some services, as ZFS has its own file system cache that isn’t reflected properly by the free -m columns. It can appear that the system is low on free memory, when that memory is in fact available for use from the ZFS cache as needed.\n\nfree命令可以显示系统中空闲物理内存总量、已使用物理内存总量、swap空间、内核使用的缓冲和缓存信息\n\n## vmstat\n\n\n```\n$ vmstat 1\nprocs ---------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n34  0    0 200889792  73708 591828    0    0     0     5    6   10 96  1  3  0  0\n32  0    0 200889920  73708 591860    0    0     0   592 13284 4282 98  1  1  0  0\n32  0    0 200890112  73708 591860    0    0     0     0 9501 2154 99  1  0  0  0\n32  0    0 200889568  73712 591856    0    0     0    48 11900 2459 99  0  0  0  0\n32  0    0 200890208  73712 591860    0    0     0     0 15898 4840 98  1  1  0  0\n```\n\nShort for virtual memory stat, vmstat(8) is a commonly available tool (first created for BSD decades ago). It prints a summary of key server statistics on each line.\n\nvmstat was run with an argument of 1, **to print one second summaries**. The first line of output (in this version of vmstat) has some columns that show the average since boot, instead of the previous second. For now, skip the first line, unless you want to learn and remember which column is which.\nColumns to check:\nr: **Number of processes running on CPU and waiting for a turn.** This provides a better signal than load averages for determining CPU saturation, as it does not include I/O. To interpret: an “r” value greater than the CPU count is saturation.\nfree: **Free memory in kilobytes.** If there are too many digits to count, you have enough free memory. The “free -m” command, included as command 7, better explains the state of free memory.\nsi, so: Swap-ins and swap-outs. **If these are non-zero, you’re out of memory**.\nus, sy, id, wa, st: These are breakdowns of CPU time, on average across all CPUs. **They are user time, system time (kernel), idle, wait I/O, and stolen time** (by other guests, or with Xen, the guest’s own isolated driver domain).\nThe CPU time breakdowns will confirm if the CPUs are busy, by adding user + system time. A constant degree of wait I/O points to a disk bottleneck; this is where the CPUs are idle, because tasks are blocked waiting for pending disk I/O. You can treat wait I/O as another form of CPU idle, one that gives a clue as to why they are idle.\nSystem time is necessary for I/O processing. A high system time average, over 20%, can be interesting to explore further: perhaps the kernel is processing the I/O inefficiently.\nIn the above example, CPU time is almost entirely in user-level, pointing to application level usage instead. The CPUs are also well over 90% utilized on average. This isn’t necessarily a problem; check for the degree of saturation using the “r” column.\n\nvmstat用来报告关于进程、内存、分页、块IO、中断、CPU活动的信息。vmstat命令显示平均数据或实际样本。通过给vmstat命令提供一个采样频率和采样次数可启用采样模式。\n\n## pmap\n\n命令用来报告一个进程或多个进程的内存映射。可以使用这个工具确定系统是如何为服务器上的进程分配内存的。\n\n□　Mapped，进程中用于映射到文件的内存总量。\n\n□　writable/private，进程私有地址空间的数量。\n\n□　shared，进程共享给其他进程的地址空间数量。\n\n# how\n\n## 页面调度（Paging）和交换（swapping）指标\n在Linux及所有类UNIX操作系统中，页面调度和swaping是不同的。页面调度移动个别分页到磁盘上的swap空间；交换是一个较大的操作，在这个过程中移动一个进程的整个地址空间到swap空间。\n\n交换可以有两种原因：\n\n□　一个进程进入睡眠模式。这是通常发生的，因为进程依赖于交互式的操作，编辑器、shell、数据输入应用程序花费大部分时间来等待用户输入。在这段时间里，它们是非活跃的。\n\n□　一个进程表现不佳。当空闲内存分页的数量低于规定的最低额度的时候，页面调度可能是一个严重的性能问题，因为页面调度机制是无法处理物理内存分页的请求的，并且swap机制被调用释放更多的分页。这显著增加了到磁盘的I/O，并很快就会降低服务器的性能。\n\n如果总是有页面调度到磁盘（高分页移出率），可以考虑增加更多的内存。然而，系统具有较低的分页移出率，可能不会影响性能。\n\n## 性能调整选项\n如果认为存在一个内存瓶颈，可考虑执行下面其中一个或多个操作：\n\n□　调整swap空间，使用bigpages、hugetlb共享内存。\n\n□　增加或减少分页的大小。\n\n□　改进活跃和非活跃内存的处理。\n\n□　调整分页移出率。\n\n□　限制服务器上每个用户的资源使用。\n\n□　停止不需要的服务。\n\n□　增加内存。\n\n## 处理内存不足（Out-of-Memory）和OOM killer\n\n当一个次要页错误（minor page fault）发生，但是又没有空闲的分页可使用时，内核将尝试回收内存来满足请求。如果不能及时回收充足的内存，将会出现内存不足（Out-of-Memory）的情况。\n\n默认情况下，系统会调用OOM Killer（Out-of-Memory Killer）选择杀死一个或多个进程来释放内存，以满足请求。\n\n作为另一种代替，将sysctl vm.panic_on_oom设置为1而不是0。\n\n注意： 一旦系统已经出现内存不足的情况，就没有更合理的选项进行恢复了。杀掉进程释放内存，放弃和杀掉系统，死锁都是可能的选择。通常情况下，如果有可能的话，最好避免让系统进入内存不足的情况。\n\n为了确定OOM killer应该杀死哪个进程，内核为每个进程保持一个运行的不良分数（badness score），可在/proc/<PID>/oom_score中查看它。\n\n具有较高分数的进程最有可能被OOM killer杀掉。\n\n使用许多因素来计算这个分数：虚拟内存大小（不是RSS size）、进程包括所有子进程积累的虚拟内存大小、nice值（正数的nice值得到一个较高的分数）、总共运行时间（较长的总共运行时间会减少分数）、运行的用户（root进程得到轻微的保护），如果进程直接对硬件进行访问分数会降低。\n\n可以使用调整参数/proc/PID/oom_adj来手工调整oom_score。oom_adj的值从-17到15。0意味着不改变（默认），-17意味着免疫（不能杀掉），任何其他值将被用来修改oom_score，通过使用2^oom_adj乘以oom_score，使用这种方式给你的进程设置一个正数oom_adj将更有可能被杀掉。当设置一个负数的值时会有较小机会被内核终结。\n\n","n":0.039}}},{"i":237,"$":{"0":{"v":"Io","n":1},"1":{"v":"\n□　I/O等待。 CPU等待一个I/O操作的发生所花费时间。较高和持续的值很多时候可能表明存在一个I/O瓶颈。\n\n□　平均队列长度。 未完成的I/O请求数量。一般情况下，一个磁盘有2到3个队列是最佳的；较高的值可能表明有一个磁盘I/O瓶颈。\n\n□　平均等待时间。 服务一个I/O请求所测量的平均时间，以毫秒为单位。等待时间是由实际的I/O操作和它在I/O队列中等待的时间组成的。\n\n□　每秒传输。 描述了每秒钟多少个I/O操作被执行（读和写）。该指标要结合每秒kB值，以帮助你确定系统的平均传输大小。平均传输大小一般应该与你的磁盘子系统使用的条带大小相匹配。\n\n## 6. iostat -xz 1\n\n```\n$ iostat -xz 1\nLinux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015  _x86_64_ (32 CPU)\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n          73.96    0.00    3.73    0.03    0.06   22.21\n\nDevice:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util\nxvda        0.00     0.23    0.21    0.18     4.52     2.08    34.37     0.00    9.98   13.80    5.42   2.44   0.09\nxvdb        0.01     0.00    1.02    8.94   127.97   598.53   145.79     0.00    0.43    1.78    0.28   0.25   0.25\nxvdc        0.01     0.00    1.02    8.86   127.79   595.94   146.50     0.00    0.45    1.82    0.30   0.27   0.26\ndm-0        0.00     0.00    0.69    2.32    10.47    31.69    28.01     0.01    3.23    0.71    3.98   0.13   0.04\ndm-1        0.00     0.00    0.00    0.94     0.01     3.78     8.00     0.33  345.84    0.04  346.81   0.01   0.00\ndm-2        0.00     0.00    0.09    0.07     1.35     0.36    22.50     0.00    2.55    0.23    5.62   1.78   0.03\n[...]\n```\nThis is a great tool for understanding **block devices** (disks), both the workload applied and the resulting performance. Look for:\nr/s, w/s, rkB/s, wkB/s: These are the delivered reads, writes, read Kbytes, and write Kbytes per second to the device. Use these for workload characterization. **A performance problem may simply be due to an excessive load applied.**\nawait: The average time for the I/O in milliseconds. This is the time that the application suffers, as it includes both time queued and time being serviced. **Larger than expected average times can be an indicator of device saturation, or device problems.**\navgqu-sz: The average number of requests issued to the device. Values greater than 1 can be evidence of saturation (although devices can typically operate on requests in parallel, especially virtual devices which front multiple back-end disks.)\n%util: Device utilization. This is really a busy percent, showing the time each second that the device was doing work. Values greater than 60% typically lead to poor performance (which should be seen in await), although it depends on the device. Values close to 100% usually indicate saturation.\nIf the storage device is a logical disk device fronting many back-end disks, then 100% utilization may just mean that some I/O is being processed 100% of the time, however, the back-end disks may be far from saturated, and may be able to handle much more work.\nBear in mind that poor performing disk I/O isn’t necessarily an application issue. Many techniques are typically used to perform I/O asynchronously, so that the application doesn’t block and suffer the latency directly (e.g., read-ahead for reads, and buffering for writes).\n\niostat报告CPU统计数据，并观察有关设备的平均传输速率的活跃时间，其用来监控系统输入／输出设备负载。iostat命令生成的报告可以用来更改系统配置，进行详细的I/O瓶颈和性能调整，以在物理磁盘之间更好地平衡输入/输出负载。参考4.4.1节的内容。iostat工具是sysstat软件包的一部分。\n\n通过iostat命令生成的第一部分报告是CPU使用率报告。对于多处理器系统，它是所有处理器总数的CPU全局平均值。报告包含以下格式：\n\n□　%user，显示当在用户级别（应用程序）执行时发生的CPU使用率百分比。\n\n□　%nice，显示在拥有nice优先级用户级别执行时发生的CPU使用率百分比。\n\n□　%system，显示当在系统级别（内核）执行时发生的CPU使用率百分比。\n\n□　%iowait，显示在系统未完成磁盘I/O请求期间，一个CPU或多个CPU空闲时间的百分比。\n\n□　%steal，显示当hypervisor为另一个虚拟处理器服务的时候，一个虚拟CPU或多个虚拟CPU非自愿等待所花费时间的百分比。\n\n□　%idle，显示一个CPU或多个CPU空闲时间的百分比，并且系统没有未完成的磁盘I/O请求。","n":0.051}}},{"i":238,"$":{"0":{"v":"Cpu","n":1},"1":{"v":"\n□　CPU使用率。 这可能是最直接的指标。它描述了每个处理器的整体使用率。如果在一段持续时间内CPU的使用率超过80％，则处理器可能有瓶颈。\n\n□　用户进程消耗CPU的时间。 描述了CPU花费在用户进程的百分比，包括nice time。较高值的user time通常是有利的，因为，在这种情况下，系统在执行实际的工作。\n\n□　内核操作消耗CPU的时间。 其描述了CPU花费在内核操作的百分比，包括IRQ和softirq时间。较高和持续的system time值可以指出在网络和驱动程序堆栈中你的瓶颈。一个系统通常应保持花在内核操作上的时间尽可能的少。\n\n□　等待。 CPU花费在等待（由于一个I/O操作发生等待）上的时间总量，像是阻塞值。一个系统不应该花费太多时间等待（因为I/O操作）；否则应该检查各自的I/O子系统性能。\n\n□　CPU空闲时间。 其描述了系统空闲等待任务的CPU百分比。\n\n□　Nice消耗CPU时间。 描述了CPU花费在re-nicing进程（更改进程的执行顺序和优先级）上的时间百分比。\n\n□　平均负载。 load average不是一个百分比，而是以下总和的滚动平均值：\n\n•　队列中等待处理的进程数。\n\n•　等待不可中断任务被完成的进程数。\n\n也就是说，TASK_RUNNING和TASK_UNINTERRUPTIBLE进程数的总和的平均值。如果进程请求CPU时间而被阻塞（这意味着CPU没有时间处理它们），load average会增加。另一方面，如果每个进程得到直接访问CPU的时间，它们没有在CPU周期丢失，则负载将减小。\n\n□　可运行的进程。 这个值描述了已经准备好执行的进程数。在一段持续的时间内，这个值不应该超过物理处理器数量的10倍。否则处理器可能是瓶颈。\n\n□　阻塞的进程。 不被执行的进程数，因为它们要等待I/O操作结束。阻塞的进程数能反映出是否有I/O瓶颈。\n\n□　上下文切换。 在系统上发生线程之间切换的数量。大量上下文切换如果与大量中断相关，则可能是驱动程序或应用程序出现问题的信号。上下文切换通常是不利的，因为每一次上下文切换都会导致CPU缓存被刷新，但是有些上下文切换是必要的。参考1.1.5节的内容。\n\n□　中断。 中断包含硬中断与软中断。硬中断对系统性能有更加不利的影响。较高的中断值表明可能有软件瓶颈，可能是在内核中，也可能是一个驱动程序出现瓶颈。记住，中断还包括CPU时钟引起的中断。参考1.1.6节的内容。\n\n## uptime\n\n```\n$ uptime \n23:51:26 up 21:31, 1 user, load average: 30.02, 26.43, 19.02\n```\n\nThis is a quick way to view the load averages, which indicate the number of tasks (processes) wanting to run. On Linux systems, these numbers include processes wanting to run on CPU, as well as processes blocked in uninterruptible I/O (usually disk I/O). This gives a high level idea of resource load (or demand), but can’t be properly understood without other tools. Worth a quick look only.\nThe **three numbers are exponentially damped moving sum averages with a 1 minute, 5 minute, and 15 minute constant**. The three numbers give us some idea of how load is changing over time. For example, if you’ve been asked to check a problem server, and the 1 minute value is much lower than the 15 minute value, then you might have logged in too late and missed the issue.\nIn the example above, the load averages show a recent increase, hitting 30 for the 1 minute value, compared to 19 for the 15 minute value. That the numbers are this large means a lot of something: probably CPU demand; vmstat or mpstat will confirm, which are commands 3 and 4 in this sequence.\n\n系统平均负载是可运行状态进程或不可中断状态进程的平均数。处在可运行状态的进程要么是正在使用CPU，要么是等待使用CPU。处在不可中断状态的进程正在等待一些I/O访问，例如等待磁盘。平均值有3个时间间隔。因为系统中CPU的数量、平均负载不是规范化的，所以，平均负载为1意味着一个单CPU系统始终是有负载的，在一个4核CPU系统上则意味着它有75％的空闲时间。\n\n平均负载最佳值为1，这意味着每个进程都能立刻访问CPU，并且没有丢失CPU周期。对于单（核）处理器工作站，1或2是可以接受的，而在多处理器服务器上你可能会看到8到10的数字（单核CPU负载是2，4核CPU负载可能是8）。\n\n\n\n## ps\n\nps显示有关选择的活跃进程的信息。ps命令提供当前已存在进程的列表。top命令动态显示进程信息，但是ps命令可以以静态方式提供更详细的信息。\n\nps aux\n\n　-A，选择所有进程，与-e相同。\n\n□　-N，选择除满足指定条件以外的所有进程。（否定选择）与--deselect相同。\n\n□　T，选择与该终端相关的所有进程。与不带任何参数的t选项相同。\n\n□　-a，选择除session leader（参见getsid(2)）以外的进程和与该终端不相关的所有进程。\n\n□　a，这个选项使得ps列出使用该终端（tty）的所有进程，或当与x选项一起使用时列出所有进程。\n\n□　-d，选择除session leader以外的所有进程。\n\n□　-e，选择所有进程，与-A相同。\n\n□　g，真正所有的进程，甚至是session leader。此选项已经废弃。\n\n□　r，限制只选择正在运行的进程。\n\n□　X，此选项使得ps列出你拥有的所有进程，或当与a选项一起使用时列出所有进程。\n\n□　--deselect，选择除满足指定条件以外的所有进程。（否定选择）与-N相同。\n\n## mpstat\n\nmpstat命令用来报告在多处理器服务器上每个可用CPU的相关统计数据（如图2-8所示）\n\n![](/assets/images/2022-04-19-20-34-14.png)\n\ninterval参数指定每次报告之间的时间间隔，以秒为单位。值为0（或没有参数）表明报告自系统启动以来的处理器统计数据。count参数如果不设置为0则可以和interval参数结合使用。count的值决定了间隔秒数生成报告的次数。如果只指定interval参数，没有count参数，那么mpstat命令将不断地生成报告。\n\n\n```\n$ mpstat -P ALL 1\nLinux 3.13.0-49-generic (titanclusters-xxxxx)  07/14/2015  _x86_64_ (32 CPU)\n\n07:38:49 PM  CPU   %usr  %nice   %sys %iowait   %irq  %soft  %steal  %guest  %gnice  %idle\n07:38:50 PM  all  98.47   0.00   0.75    0.00   0.00   0.00    0.00    0.00    0.00   0.78\n07:38:50 PM    0  96.04   0.00   2.97    0.00   0.00   0.00    0.00    0.00    0.00   0.99\n07:38:50 PM    1  97.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   2.00\n07:38:50 PM    2  98.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   1.00\n07:38:50 PM    3  96.97   0.00   0.00    0.00   0.00   0.00    0.00    0.00    0.00   3.03\n[...]\n```\n\nThis command prints CPU time breakdowns per CPU, which can be used to **check for an imbalance**. A single hot CPU can be evidence of a single-threaded application.\n\n## strace\n\nstrace用来跟踪系统调用和信号。strace是一个很有用的诊断、指导和调试的工具。系统管理员可以很方便地使用它来诊断和解决程序出现的问题，因为可以在不需要重新编译的情况下来跟踪它们。最简单的情况就是使用strace运行指定的命令，直到命令结束。它拦截并记录进程执行的系统调用和进程接收的信号。每个系统调用的名称、参数和返回值都将被显示在标准错误输出中或可以通过-o选项指定到文件。\n\ntrace system calls and signals\n\n跟踪的每一行包含系统调用的名称，其次是括号中的参数，还有返回值。下面是cat命令的跟踪例子：\n\n```\n[root@zyg ～]# strace cat/tmp/file1\nexecve(\"/bin/cat\", [\"cat\", \"/tmp/file1\"], [/* 29 vars */]) = 0\nbrk(0)　　　　　　　　　　　=0x19f0000\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f229ad6b000\naccess(\"/etc/ld.so.preload\", R_OK)　　　= -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY)　　= 3\nfstat(3, {st_mode=S_IFREG|0644, st_size=81712, ...}) = 0\nmmap(NULL, 81712, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f229ad57000\nclose(3)　　　　　　　　　　　　　=0\nopen(\"/lib64/libc.so.6\", O_RDONLY)　　　= 3\nread(3, \"\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0000\\356\\341\\2426\\0\\0\\0\"..., 832)= 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=1926800, ...}) = 0\nmmap(0x36a2e00000, 3750152, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0)= 0x36a2e00000\nmprotect(0x36a2f8b000, 2093056, PROT_NONE) = 0\nmmap(0x36a318a000, 20480, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x18a000) = 0x36a318a000\nmmap(0x36a318f000, 18696, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x36a318f000\nclose(3)　　　　　　　　　　　　　=0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f229ad56000\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f229ad55000\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f229ad54000\narch_prctl(ARCH_SET_FS, 0x7f229ad55700) = 0\nmprotect(0x36a318a000, 16384, PROT_READ) = 0\nmprotect(0x36a281f000, 4096, PROT_READ) = 0\nmunmap(0x7f229ad57000, 81712)　　　=0\nbrk(0)　　　　　　　　　　　　　=0x19f0000\nbrk(0x1a11000)　　　　　　　　　　=0x1a11000\nopen(\"/usr/lib/locale/locale-archive\", O_RDONLY) = 3\nfstat(3, {st_mode=S_IFREG|0644, st_size=99158576, ...}) = 0\nmmap(NULL, 99158576, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f2294ec3000\nclose(3)　　　　　　　　　　　　　=0\nfstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0\nopen(\"/tmp/file1\", O_RDONLY)　　　　=3\nfstat(3, {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\nread(3, \"111\\n\", 32768)　　　　　=4\nwrite(1, \"111\\n\", 4111\n)　　　　　　=4\nread(3, \"\", 32768)　　　　　　　=0\nclose(3)　　　　　　　　　　　　=0\nclose(1)　　　　　　　　　　　　=0\nclose(2)　　　　　　　　　　　　=0\nexit_group(0)　　　　　　　　　 =?\n```\n还有另一个有趣的用途。此命令还可以报告执行一个命令每个系统调用在内核中消耗时间的统计，使用-c选项：\n\n```\n[root@zyg ～]# strace -c cat /tmp/file1\n111\n% time\tseconds\tusecs/call\tcalls\terrors\tsyscall\n------\t-----------\t-----------\t---------\t---------\t----------------\n60.82\t0.000863\t863\t1\t\texecve\n14.87\t0.000211\t35\t6\t\tclose\n12.40\t0.000176\t20\t9\t\tmmap\n11.91\t0.000169\t42\t4\t\topen\n0.00\t0.000000\t0\t3\t\tread\n0.00\t0.000000\t0\t1\t\twrite\n0.00\t0.000000\t0\t5\t\tfstat\n0.00\t0.000000\t0\t3\t\tmprotect\n0.00\t0.000000\t0\t1\t\tmunmap\n0.00\t0.000000\t0\t3\t\tbrk\n0.00\t0.000000\t0\t1\t1\taccess\n0.00\t0.000000\t0\t1\t\tarch_prctl\n------\t-----------\t-----------\t---------\t---------\t----------------\n```\n\n## ltrace\n\nltrace是一个库调用跟踪程序，其可以通过ltrace简单运行指定命令直到它退出。它截取和记录执行进程所进行的动态库调用，和进程接收的信号。它也可以截取和显示程序执行的系统调用。它的使用与strace非常类似。ltrace显示调用函数的参数和系统调用。要确定每个函数有什么样的参数，它需要函数原型的外部声明。这些都被存储在被称为原型库的文件中，这些文件的语法细节参考ltrace.conf(5)。参见PROTOTYPE LIBRARY DISCOVERY章节学习ltrace如何找到原型库。\n\n# how\n\n第一步是确认系统性能问题是CPU引起的，而不是其他子系统。如果处理器是服务器的瓶颈，那么采取一些行动来提高性能，其中包括：\n\n□　使用ps -ef命令来确认后台没有运行不必要的程序。如果发现这样的程序，停止它们并使用cron来安排它们在非高峰时段运行。\n\n□　使用top识别非关键性CPU密集型程序，并使用renice修改它们的优先级。\n□　根据正在运行的应用程序，可能更大的扩展（更大的CPU）要比更多的扩展（更多CPU）好。这要取决于你的应用程序是否都被设计为有效地利用更多CPU。比如，一个单线程的应用程序通过一个更快的CPU可以更好地扩展，而不是更多的CPU。\n\n□　通常的选项包括，确保使用最新的驱动程序和固件，因为这可能影响它们在CPU上的负载。\n\n","n":0.045}}},{"i":239,"$":{"0":{"v":"Monitor","n":1},"1":{"v":"\n# Monitor\n\n## work metrics\n\n- throughput:rps\n- success\n- error\n- performance: response time\n\n## resource metrics\n\n- utilization: percentage time that the resource is busy\n- saturation: measure of the amount of requested work that resource cannot yet service, often queued\n- errors: internal error that cannot observed in the resource produces\n- availability: represents the percentage of time that the resource responded to requests. This metric is only well-defined for resources that can be actively and regularly checked for availability.\n\n## event metrics\n\n- Changes: Internal code releases, builds, and build failures\n- Alerts: Internally generated alerts or third-party notifications\n- Scaling events: Adding or subtracting hosts","n":0.102}}},{"i":240,"$":{"0":{"v":"Meta","n":1},"1":{"v":"this page show how Meta system works.\n\n","n":0.378}}},{"i":241,"$":{"0":{"v":"Slick","n":1},"1":{"v":"\nSLICK is a dedicated SLO(service level objectives). With SLICK, we are able to centralize SLI and SLO definitions to easily find and understand another service’s reliability; provide service owners with insights using high-retention, full granularity data for key service metrics not found in other tools; and integrate SLOs with various other workflows at the company to ensure that SLOs become a part of day-to-day work.\n\n- Define SLOs in a unified way for our services\n- Have up to per-minute granularity metric data with up to two years of retention\n- Have standard visualizations and insights for SLI/SLO metrics\n- Send periodic reliability reports to internal groups, allowing teams to use them for reliability reviews\n\n# how to onboard\n\n![](/assets/images/2022-12-27-15-08-22.png)\n\n# using\n\n- dashboard\n\n![](/assets/images/2022-12-27-15-08-39.png)\n\n- report\n- cli\n\n# Arch\n\n![](/assets/images/2022-12-27-15-09-04.png)\n\n- SLICK Configs: A config file written using SLICK’s DSL, committed by the user to the SLICK config store.\n- SLICK Syncer: A service that synchronizes changes made to SLICK configs into SLICK’s config metadata storage.\n- SLICK UI: These are the generated SLICK dashboards for every service. The SLICK UI also provides the index mentioned previously.\n- SLICK Service: A server that provides an API that is able to answer queries such as “How to compute the SLO for a specific visualization?”. The server allows us to abstract away all the details around data placement and sharding, and it enables the caller to easily find the data needed.\n- SLICK Data Pipelines: Pipelines that periodically run in order to capture SLI data over the long term.\n\n## Data ingestion\n\n![](/assets/images/2022-12-27-15-09-50.png)\n","n":0.064}}},{"i":242,"$":{"0":{"v":"Maintainability","n":1},"1":{"v":"\n# Maintainability\n\n- Operability Make it easy for operations teams to keep the system running smoothly.\n- Simplicity Make it easy for new engineers to understand the system, by removing as much complexity as possible from the system. (Note this is not the same as simplicity of the user interface.) \n- Evolvability Make it easy for engineers to make changes to the system in the future, adapting it for unanticipated use cases as requirements change. Also known as extensibil‐ity, modifiability, or plasticity.\n\n\n## Operability\n\n- Monitoring the health of the system and quickly restoring service if it goes into a bad state \n- Tracking down the cause of problems, such as system failures or degraded per‐formance \n- Keeping software and platforms up to date, including security patches \n- Keeping tabs on how different systems affect each other, so that a problematic change can be avoided before it causes damage\n- Anticipating future problems and solving them before they occur (e.g., capacity planning) \n- Establishing good practices and tools for deployment, configuration manage‐ment, and more \n- Performing complex maintenance tasks, such as moving an application from one platform to another \n- Maintaining the security of the system as configuration changes are made \n- Defining processes that make operations predictable and help keep the produc‐tion environment stable \n- Preserving the organization’s knowledge about the system, even as individual people come and go\n\n\n- Providing visibility into the runtime behavior and internals of the system, with good monitoring \n- Providing good support for automation and integration with standard tools \n- Avoiding dependency on individual machines (allowing machines to be taken down for maintenance while the system as a whole continues running uninter‐rupted) \n- Providing good documentation and an easy-to-understand operational model (“If I do X, Y will happen”) \n- Providing good default behavior, but also giving administrators the freedom to override defaults when needed \n- Self-healing where appropriate, but also giving administrators manual control over the system state when needed \n- Exhibiting predictable behavior, minimizing surprises","n":0.055}}},{"i":243,"$":{"0":{"v":"File_system","n":1},"1":{"v":"\n[[Io|dendron://my_note/development.computer.io]]\n\nthe in-memory data structure vnode is just an inode cache that stores information about the file(typically inode stores in the disk) so that it can be accessed more quickly.\n\n![](/assets/images/2021-05-11-19-41-30.png)\n\n# file system\n\n![](/assets/images/2021-05-11-19-43-14.png)\n\n- The boot block occupies the beginning of a file system, typically the first sector, and may contain the bootstrap code that is read into the machine to boot, or initialize, the operating system. Although only one boot block is needed to boot the system, every file system has a (possibly empty) boot block.\n\n- The super block describes the state of a file system — how large it is, how many files it can store, where to find free space on the file system, and other information.\n\n- The mode list is a list of Modes that follows the super block in the file system. Administrators specify the size of the Mode list when configuring a file system. The kernel references Modes by index into the Mode list. One Mode is the root mode of the file system: it is the Mode by which the directory structure of the file system is accessible after execution of the mount system call (Section 5.14).\n\n- The data blocks start at the end of the Mode list and contain file data and administrative data. An allocated data block can belong to one and only one file in the file system.\n\n## inode\n\nModes exist in a static form on disk, and the kernel reads them into an in-core mode to manipulate them. Disk modes consist of the following fields\n\n- file owner identifier\n- file type\n- file access permission\n- access time, last modified, last accessed\n- number of links to the file\n- table of contents for the disk addresses of data in a file\n- file size\n- no path\n\n## STRUCTURE OF A REGULAR FILE\n\nthe Mode contains the table of contents to locate a file's data on disk. Since each block on a disk is addressable by number, the table of contents consists of a set of disk block numbers.\n\nFor greater flexibility, the kernel allocates file space one block at a time and allows the data in a file to be spread throughout the file system.\n\nTo access the data via the indirect block, the kernel must read the indirect block, find the appropriate direct block entry, and then read the direct block to find the data.\n\n![](/assets/images/2021-05-11-19-58-08.png)\n\n## directories\n\nA directory is a file whose data is a sequence of entries, each consisting of an mode number and the name of a file contained in the directory.\n\n![](/assets/images/2021-05-11-20-05-57.png)\n\n## ls\n\n```\n-rwxrw-r--    10    root   root 2048    Jan 13 07:11 afile.exe\n?UUUGGGOOOS   00  UUUUUU GGGGGG ####    ^-- date stamp and file name are obvious ;-)\n^ ^  ^  ^ ^    ^      ^      ^    ^\n| |  |  | |    |      |      |    \\--- File Size\n| |  |  | |    |      |      \\-------- Group Name (for example, Users, Administrators, etc)\n| |  |  | |    |      \\--------------- Owner Acct\n| |  |  | |    \\---------------------- Link count (what constitutes a \"link\" here varies)\n| |  |  | \\--------------------------- Alternative Access (blank means none defined, anything else varies)\n| \\--\\--\\----------------------------- Read, Write and Special access modes for [U]ser, [G]roup, and [O]thers (everyone else)\n\\------------------------------------- File type flag\n```\n\n## conversion of a path name to an innode\n\n![](/assets/images/2021-05-11-20-12-36.png)\n\nThe kernel does a linear search of the directory file associated with the working mode, trying to match the path name component to a directory entry name.\n\n","n":0.043}}},{"i":244,"$":{"0":{"v":"Linux","n":1},"1":{"v":"\n虚拟文件系统（Virtual Files System, VFS）是驻留在用户进程与各种类型的Linux文件系统之间的一个抽象接口层。VFS提供了访问文件系统对象的通用对象模型（比如索引节点、文件对象、分页缓存、目录条目，等等）和方法。它对用户进程隐藏了实现每个文件系统的差异。有了VFS，用户进程不需要知道系统使用的是哪一个文件系统，为每个文件系统运行哪一个系统调用\n\n![](/assets/images/2022-04-19-19-58-32.png)\n\n# ext2\n\n![](/assets/images/2022-04-19-20-01-02.png)\n\n□　超级块（Super Block）。 文件系统的信息存储在这里。超级块的精确副本被放置在每个块组的顶部。\n\n□　块组描述符（Block group descriptor）。 块组上的信息被存储在这里。\n\n□　数据块位图（Data block bitmaps）。 用于空闲数据块管理。\n\n□　索引节点位图（I-node bitmaps）。 用于空闲索引节点的管理。\n\n□　索引节点表（I-node tables）。 索引节点表存储在这里。每个文件有一个相应的索引节点表，其中保存了文件的元数据，比如文件模式、uid、gid、atime、ctime、mtime和到数据块的指针。\n\n□　数据块（Data blocks）。 实际的用户数据存储的位置。\n\n要查找组成一个文件的数据块，首先要查找文件的索引节点。如果一个进程请求打开/var/log/messages，那么kernel会解析文件路径，搜索／（根目录）的目录条目，该目录条目中有它（根目录）下面文件和目录的信息。接下来内核可以找到／var的索引节点，并且查看／var的目录条目，该目录条目中也有／var下面文件和目录的信息。内核以此方式一直向下搜索直到找到文件的索引节点。Linux内核使用一个文件对象缓存，比如目录条目缓存或者索引节点缓存来加速查找符合条件的索引节点。\n\n一旦Linux内核找到了文件的索引节点，它会试图找到实际的用户数据块。正如前面描述的，索引节点有到数据块的指针。通过它，内核可以得到数据块。对于大文件，Ext2实现数据块直接／间接的引用。图1-17说明了以上描述的工作过程。\n![](/assets/images/2022-04-19-20-02-55.png)","n":0.229}}},{"i":245,"$":{"0":{"v":"Concurrency","n":1},"1":{"v":"\n# 并发编程\n\n- 进程: 独立虚拟地址空间\n- i/o多路复用: 一个进程的上下文显示调度他们自己的逻辑流\n- 线程：运行在单一进程上下文的逻辑流，由内核控制\n\n## 进程\n\n- fork, exec, waitpid\n- 共享文件表，不共享用户地址空间，共享状态信息变得困难\n\n## I/O多路复用\n\n使用select函数，要求内核挂起进程，只有在一个或多个I/O事件发生后才将控制返回给应用程序。\n\n用作event-driven程序的基础。\n\n客户端池:\n\n- 优点：不需要切换上下文\n- 缺点：编码复杂\n\n## thread\n\n有自己的thread id, stack, PC, registers\n\n共享进程的整个虚拟地址空间。\n\n线程之间对等，无父子关系，切换上下文快。\n\npthread api\n\n- pthread_create\n- pthread_exit\n- pthread_join ：回收，阻塞，直到tid终止\n- pthread_detach: 不被其他回收，在终止时被系统回收\n\n- 共享变量\n  - 全局变量：任何线程都可以访问\n  - 本地自动变量：无static,只在自己的thread里\n  - 本地静态：线程共享，在vm里只有一个\n\n\n","n":0.171}}},{"i":246,"$":{"0":{"v":"Compute","n":1}}},{"i":247,"$":{"0":{"v":"Yarn","n":1},"1":{"v":"\n\n- YARN, which separates the resource management and processing components. The YARN-based architecture is not constrained to MapReduce.\n![](pic/yarn.jpg)\n- The **ResourceManager** tracks how many live nodes and resources are available on the cluster and coordinates what applications submitted by users should get these resources and when\n- **ApplicationMaster** is started to coordinate the execution of all tasks within the application.The ApplicationMaster and tasks that belong to its application run in resource containers controlled by the NodeManagers.\n- The **NodeManager** is a more generic and efficient version of the TaskTracker. The NodeManager has a number of dynamically created resource containers.\n\n## features\n\n- **Uberization** is the possibility to run all tasks of a MapReduce job in the ApplicationMaster's JVM if the job is small enough\n- Binary or source compatibility for MapReduce jobs written for MRv1\n- An application recovery after the restart of ResourceManager","n":0.085}}},{"i":248,"$":{"0":{"v":"Spark","n":1},"1":{"v":"\n\n- key point: efficient\n    - general execution graphs\n    - in-memory storage\n- Resilient Distributed Datasets\n    - Collections of objects spread across a cluster, stored in RAM or on disk\n    - build through parallel transformation\n    - automatically rebuild on failure \n    - It track lineage information that can be used to efficiently recompute lost data\n- DAG scheduler(Directed Acyclic Graph)\n    - job: one action for RDD\n    - stage: split in shuffle for job\n    - task: real task in executor\n    - DAG in Apache Spark is a set of Vertices and Edges, where vertices represent the RDDs and the edges represent the Operation to be applied on RDD.\n    - know the dependency for different RDD\n    - In this way, the execution plan is optimized, e.g. to minimize shuffling data around. \n    - ![](https://img-blog.csdn.net/20170427180924863?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTU2NDE3Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)","n":0.088}}},{"i":249,"$":{"0":{"v":"Mapreduce","n":1},"1":{"v":"\nMapReduce is a programming model for processing large amounts of data in bulk across many machines\n\nThe map and reduce functions are somewhat restricted in what they are allowed to do. They must be pure functions, which means they only use the data that is passed to them as input, they cannot perform additional database queries, and they must not have any side effects.\n\n- **what**: do parellel in map phase, do merge sort in sort, do linear in reducer\n- **why**: quick in map, slow in reduce\n- **how**: could do select, filter, min,max,sum, no avg, join is not a good operation in mapreduce, only in reduce phase.\n- sort:\n    - search in the final result\n    - mapper yield duplicated key and we need use sort to group them in one reducer \n- **problem**\n    - A single **master** process called **JobTracker**, which **coordinates** all jobs running on the cluster and **assigns** map and reduce tasks to run on the TaskTrackers\n    - A number of subordinate processes called **TaskTrackers**, which run assigned tasks and periodically report the progress to the JobTracker\n    - Hadoop was designed to run MapReduce jobs only\n    - more maps means more overhead for master to keep track of the state of computation\n    - fewer map-reduce phase","n":0.07}}},{"i":250,"$":{"0":{"v":"Container","n":1},"1":{"v":"\n\n# VM and containers\n\n- **what**: a virtualized system is a **mapping** of its interface, and all resources visible through that interface, to the interface and resources of a real system.\n- **why**: \n    - provide a way of relaxing constrains and increasing flexibility\n    - advantages\n        - multiple secure environment: system VM provides a sandbox isolates one system environment from others\n        - failure isolation\n        - mixed-os environment: one hardware support multiple OS concurrently\n        - better System Utilization: can be dynamically or statically re-configured for changing needs\n    - properties:\n        - isolation: fault, software, performance(done by scheduling)\n        - encapsulation: all VM state could be captured in a file\n        - interposition: all guest actions could be inspect, modify and deny\n- **how**: abstraction. provide a simplified interface to underlying resources. virtualization provides a different interface at the same level of abstraction.\n    - hypervisor: a co-designed firmware-software layer,use this layer to manage the virtual machines\n    - full virtualization: provide same function as the underlying physical hardware. Allow unmodified OS to execute on VM\n    - para-virtualization: provide similar function, and modify OS to cooperate with VMM. Get lower overhead and better performance.\n    - Emulation: implement same function with different intereface and functionality\n    - system VM: vmare, process VM: jvm\n    - multiprocessor system: partition(subset of the resources)-> in space(physical), in time(logical)\n    - in DS:\n        - abstract environment from resources\n        - abstract application from environment\n        - different environment no affect users\n        - migration\n        - scaling\n        - protection\n        - sharing\n\n## Containers\n\n- share part of OS\n- provide independent\n- resource share.  secure problem\n- less isolation\n\nDocker allows you to set the limit of memory, CPU, and also recently GPU on your container. It is not as simple as it sounds.\n\n# Tupperware \n\n![](/assets/images/2021-05-10-22-59-20.png)\n\n![](/assets/images/2021-05-10-23-00-53.png)\n\nresource broker for source of truth for machine info. One instance of Resource Broker (RB) is deployed to each DC. RB records whether a machine in the DC is free or assigned to an entitlement\n\n![](/assets/images/2021-05-10-23-06-16.png)\n\n![](/assets/images/2021-05-11-20-32-16.png)\n\nFigure 4 shows an overview of Twine. The Capacity Portal allows users to request or modify entitlements, which associate capacity quotas with business units deﬁned in the service accounting hierarchy. With a granted entitlement, a user deploys jobs through the front end. The scheduler manages job and task lifecycle, e.g., orchestrating a job’s software release. If a job has a TaskController, the scheduler coordinates with the TaskController to make decisions, e.g., delaying a task restart to rebuild a lost data replica ﬁrst. The allocator assigns machines to entitlements and assigns tasks to machines. ReBalancer runs asynchronously and continuously to improve the allocator’s decisions, e.g., better balancing the utilization of CPU, power, and network. Resource Broker (RB) stores machine information and unavailability events that track hardware failures and planned maintenance. DC operators schedule planned maintenance through Ops Planner. The Health Check Service (HCS) monitors machines and updates their status in RB. The agent runs on every machine to manage tasks. Sidekick switches host proﬁles as needed. Service Resource Manager (SRM) autoscales jobs in response to load changes. Conveyor is our continuous delivery system.\n\n[reference](https://www.usenix.org/system/files/osdi20-tang.pdf)","n":0.045}}},{"i":251,"$":{"0":{"v":"Code_deployment","n":1},"1":{"v":"\n# continous www push\n\n- Check out trunk\t--\t<0:01\tcheck out the most current trunk revision in WWW. \n- Build\t<0:01\t0:35\tOnce we have a version locked in, we kick off an asynchronous test run, and start doing a build. A build in this context is taking the PHP files in the repo and turning it into packages that we will actually ship to web servers. This can fail in many ways, from Hack failures, to static resources errors, to other random stuff.\n- Test\t0:10\t0:15\tThe actual work here usually finishes while the build step is running. If any test failed, we consider the step failed.\n- Try Acquiring Deploy Lock\t0:35\t<0:01\tWe don't want to push if someone hit the stop button, nor do we want multiple pushes back to back to back, so if any build is currently beyond this step (pushing or waiting), we'll mark the push phases as SKIPPED and end the push instance.\n- Push Trunkstable/c1\t0:35\t0:20\tThis basically does a twdeploy push_job which will push trunkstable. See the Tupperware UI for a list of these jobs. We do this rollout in a staged fashion. Each individual server is down for under 5 minutes.\n- Push C2\t1:10\t0:30\tNow we'll do tupperware push_job to push these jobs. This will be hit by 1% (soon 2%) of users, so we have a system called Presholds which may pause the push if some metrics look bad enough (logspew, fatals, latency, servers not coming back up). If enough jobs get paused in this way, we'll revert c2 and fail the push.\n- Verify C2\t1:40\t0:25\tNow we wait again. This time we want employees and alerts to have a chance to notice c2 is broken. At the end of this 15 minute window we check for any alerts with the `blocks_c3_push` tag. If any are found we'll fail the job.\n- Push C3\t1:50\t0:30\tThis behaves exactly like pushing c2, it also has presholds. Naturally there are different Tupperware jobs.\n- Done\t2:20\t--\tOnce this finishes, we're done and another build can try and grab the deploy lock!","n":0.055}}},{"i":252,"$":{"0":{"v":"Alert","n":1},"1":{"v":"\n# Alert\n\n- 警报应当是紧急的、重要的、可操作的，并且是真实的。\n- 它们应该代表服务中持续存在或即将出现的问题。\n- 应该避免过度监控导致的噪音警报，因为过度监控比欠缺监控更难解决。\n- 你几乎总应该能够将问题归类为以下一种：\n  - 可用性和基础功能性\n  - latency\n  - 正确性（数据的完整性、新鲜度和持久性）\n  - 特定功能的问题。\n- **症状是以更全面和更少的努力**捕获更多问题的更好方法。\n- 应该在基于症状的页面或仪表板上包括基于原因的信息，但避免只关注原因。\n\n## 处理警报\n\n症状为本的监控\n\n1. 警报系统需要处理需要及时响应的问题，但不一定是紧迫的问题。\n2. 每次接到警报时，应该有紧迫感地做出反应。\n3. 每个页面的警报都应该是可操作的，不能只是简单地记录“这个页面又警报了”。\n4. 每个页面的警报都应该需要智能来处理，不能有机械式或可脚本化的回应。\n\n## 警报规则\n\n在处理警报规则时，应该问自己以下几个问题：\n\n1. 这条规则是否能检测到以前未发现的紧急、可操作和活动的问题？\n2. 我是否能忽略这条规则，知道它是良性的？\n3. 它是否确定会伤害用户？\n4. 我能对这个警报采取行动吗？行动是否紧急？\n5. 是否有其他人同时收到警报？他们会解决问题吗？\n\n# 追踪和责任制度\n\n跟踪页面和警报是保证警报有效性的关键。如果一个页面触发警报，人们只是说“我看了一下，没有问题”，这是一个警报系统的红旗。\n警报准确度低于50%的应该被认为是损坏的，需要修正或以其他方式彻底收集数据。\n实施定期检查（例如，所有页面的周检查和季度统计）有助于把握整体情况，识别通常在页面移交时丢失的模式。","n":0.189}}},{"i":253,"$":{"0":{"v":"Swift","n":1},"1":{"v":"# basic\n\n","n":0.707}}},{"i":254,"$":{"0":{"v":"Task","n":1},"1":{"v":"\n# Swift中的`Task`\n\n## 概念\n\n在Swift中，`Task`用于并发编程，是执行异步工作的一种方式。它允许你创建一个异步任务，这个任务可以在后台并行执行，而不会阻塞主线程。\n\n## 使用`Task`\n\n### 1. 创建任务\n\n使用`Task`初始化器可以创建一个新的异步任务。\n\n```swift\nTask {\n    // 这里执行异步代码\n}\n```\n\n### 2. 使用`Task`执行异步操作\n\n你可以在`Task`块内部调用异步函数。\n\n```swift\nTask {\n    let data = await fetchData()\n    // 处理数据\n}\n```\n\n在这个例子中，`fetchData`是一个异步函数，它被`await`调用以等待其完成。\n\n### 3. 取消任务\n\n创建的`Task`可以被取消。这对于停止长时间运行或不再需要的任务非常有用。\n\n```swift\nlet task = Task {\n    await longRunningTask()\n}\n\n// 在某个时刻取消任务\ntask.cancel()\n```\n\n### 4. 处理任务返回值\n\n`Task`还可以处理异步函数的返回值。\n\n```swift\nTask { () -> ReturnType in\n    let result = await someAsyncFunction()\n    return result\n}\n```\n\n### 5. Task优先级\n\n`Task`还可以指定优先级。\n\n```swift\nTask(priority: .high) {\n    // 高优先级的任务\n}\n```\n\n## 注意事项\n\n- 在`Task`内部使用`await`来调用异步函数。\n- `Task`可以用于结构化并发，它有助于管理异步代码的复杂性。\n- 取消`Task`是一种重要的资源管理手段，可以避免不必要的计算和潜在的内存泄漏。\n\n## 总结\n\n`Task`是Swift并发编程的核心概念之一，它提供了一种简单而强大的方式来处理异步代码和并行任务。正确使用`Task`可以显著提高应用程序的性能和响应速度。\n","n":0.137}}},{"i":255,"$":{"0":{"v":"String","n":1},"1":{"v":"\n# Swift字符串插值和操作\n\n## 字符串插值\n\n在Swift中，字符串插值是一种构建新字符串的方式，可以将常量、变量、字面量和表达式的值包含在长字符串中。格式是将值放在`\\()`中。\n\n```swift\nlet name = \"小明\"\nlet greeting = \"你好, \\(name)!\"\nprint(greeting) // 输出: 你好, 小明!\n```\n\n## 常用的字符串操作\n\n### 1. 字符串连接\n\n可以使用`+`运算符来连接两个字符串。\n\n```swift\nlet firstPart = \"Swift\"\nlet secondPart = \"UI\"\nlet completeString = firstPart + secondPart\nprint(completeString) // 输出: SwiftUI\n```\n\n### 2. 多行字符串\n\n使用三个双引号(`\"\"\"`)来创建多行字符串。\n\n```swift\nlet multiLineString = \"\"\"\n这是一个\n多行\n字符串\n\"\"\"\nprint(multiLineString)\n```\n\n### 3. 字符串长度\n\n使用`.count`属性来获取字符串的长度。\n\n```swift\nlet message = \"Hello, Swift!\"\nprint(\"字符串长度为 \\(message.count)\")\n```\n\n### 4. 访问字符串中的字符\n\n可以使用下标语法来访问字符串中的特定字符。\n\n```swift\nlet word = \"Hello\"\nlet firstLetter = word[word.startIndex]\nprint(firstLetter) // 输出: H\n```\n\n### 5. 字符串的遍历\n\n使用`for-in`循环遍历字符串中的每个字符。\n\n```swift\nfor char in \"Swift\" {\n    print(char)\n}\n```\n\n### 6. 字符串的修改\n\n字符串可以通过各种方法进行修改，例如添加字符、替换子字符串等。\n\n```swift\nvar str = \"I like Swift\"\nstr += \" programming\"\nprint(str) // 输出: I like Swift programming\n```\n","n":0.114}}},{"i":256,"$":{"0":{"v":"Published","n":1},"1":{"v":"\n\n# Swift中的`@Published`属性包装器\n\n## 概念\n\n在Swift的Combine框架中，`@Published`是一个属性包装器，用于创建可被观察的对象属性。当这个属性的值改变时，它会自动通知所有订阅者。\n\n## 作用\n\n- **数据绑定**: `@Published`属性用于数据绑定，特别是在SwiftUI中，它允许视图自动更新以响应数据模型的变化。\n- **简化状态管理**: 在复杂的应用中，`@Published`属性帮助管理和传播状态变化，简化了状态管理的复杂性。\n\n## 使用`@Published`\n\n### 1. 定义`@Published`属性\n\n在类中定义一个`@Published`属性。\n\n```swift\nclass MyModel: ObservableObject {\n    @Published var count = 0\n}\n```\n\n在这个例子中，`count`是一个`@Published`属性。当它的值改变时，所有订阅这个`MyModel`对象的视图将自动更新。\n\n### 2. 观察`@Published`属性的变化\n\n可以使用Combine的`Publisher`来订阅`@Published`属性的变化。\n\n```swift\nlet model = MyModel()\nmodel.$count\n    .sink { newValue in\n        print(\"Count updated to \\(newValue)\")\n    }\n    .store(in: &subscriptions)\n```\n\n在这个例子中，每当`count`值改变时，新的值会被打印出来。\n\n## 注意事项\n\n- `@Published`需要与Combine框架一起使用。\n- 适用于需要反应式编程的场景，如在SwiftUI中自动更新UI。\n- 它仅适用于类（`class`），不适用于结构体（`struct`）或枚举（`enum`）。\n\n## 总结\n\n`@Published`属性包装器是Swift中实现反应式编程的关键工具之一，特别是在使用SwiftUI构建用户界面时。它允许开发者以声明式的方式连接UI与数据模型，简化了视图更新和状态管理的过程。\n","n":0.158}}},{"i":257,"$":{"0":{"v":"Operator","n":1},"1":{"v":"\n# Swift中的数值比较运算符 `~=` \n\n## 概念\n\n在Swift中，`~=`运算符不是不等于，而是一个\"模式匹配\"运算符。它通常用在`switch`语句中，用于检查值是否符合某个模式。\n\n## `~=`运算符的用法\n\n### 1. 在`switch`语句中的应用\n\n`~=`用于`switch`语句中，以确定值是否与某个模式匹配。\n\n```swift\nlet value = 5\n\nswitch value {\ncase 1...10:\n    print(\"在1到10之间\")\ndefault:\n    print(\"超出范围\")\n}\n```\n\n在这个例子中，`~=`被隐式使用来检查`value`是否在`1...10`的范围内。\n\n### 2. 自定义模式匹配\n\n你还可以为`~=`定义自己的行为，让它能够匹配自定义类型。\n\n```swift\nstruct MyType {\n    let value: Int\n}\n\nfunc ~=(pattern: MyType, value: Int) -> Bool {\n    return pattern.value == value\n}\n\nlet myValue = MyType(value: 5)\n\nswitch myValue.value {\ncase MyType(value: 5):\n    print(\"匹配成功\")\ndefault:\n    print(\"匹配失败\")\n}\n```\n\n在这个例子中，我们自定义了`~=`运算符来匹配`MyType`和`Int`类型。\n\n\n# Swift中的其他运算符\n\nSwift提供了多种运算符，用于执行各种操作，包括数学运算、比较、逻辑运算等。以下是Swift中常见的运算符类别及其例子。\n\n## 1. 算术运算符\n\n- 加法 (`+`)\n- 减法 (`-`)\n- 乘法 (`*`)\n- 除法 (`/`)\n- 求余 (`%`)\n\n## 2. 比较运算符\n\n- 等于 (`==`)\n- 不等于 (`!=`)\n- 大于 (`>`)\n- 小于 (`<`)\n- 大于等于 (`>=`)\n- 小于等于 (`<=`)\n\n## 3. 逻辑运算符\n\n- 逻辑非 (`!`)\n- 逻辑与 (`&&`)\n- 逻辑或 (`||`)\n\n## 4. 赋值运算符\n\n- 直接赋值 (`=`)\n- 加法赋值 (`+=`)\n- 减法赋值 (`-=`)\n- 乘法赋值 (`*=`)\n- 除法赋值 (`/=`)\n- 求余赋值 (`%=`)\n\n## 5. 位运算符\n\n- 按位取反 (`~`)\n- 按位与 (`&`)\n- 按位或 (`|`)\n- 按位异或 (`^`)\n- 按位左移 (`<<`)\n- 按位右移 (`>>`)\n\n## 6. 范围运算符\n\n- 封闭范围 (`a...b`)\n- 半开范围 (`a..<b`)\n\n## 7. 条件运算符\n\n- 三元运算符 (`a ? b : c`)\n\n## 8. 可选链运算符\n\n- 可选链 (`?`)\n\n## 9. 空合并运算符\n\n- 空合并 (`??`)\n\n## 10. 恒等与不恒等运算符\n\n- 恒等 (`===`)\n- 不恒等 (`!==`)\n\n## 11. 其他运算符\n\n- Nil合并运算符 (`??`)\n- 区间运算符 (`..<` 和 `...`)\n\n## 总结\n\nSwift中的运算符覆盖了从基本的数学运算到更复杂的逻辑和比较操作。理解这些运算符的用法是掌握Swift编程的关键部分。\n","n":0.083}}},{"i":258,"$":{"0":{"v":"Mainactor","n":1},"1":{"v":"\n\n# Swift中的`MainActor`\n\n## 概念\n\n`MainActor`是Swift中的一个特性，用于并发编程。它是一个特殊的actor，确保访问和修改UI相关的代码在主线程（也就是UI线程）上执行。这对于编写线程安全的UI代码非常重要。\n\n## 作用\n\n- **线程安全**: 确保UI更新在主线程上安全执行，防止线程冲突。\n- **简化代码**: 通过自动调度到主线程，减少了手动管理线程的复杂性。\n\n## 使用`MainActor`\n\n### 1. 标记方法或属性\n\n使用`@MainActor`来标记类、结构体、枚举中的方法或属性。\n\n```swift\nclass MyViewController: UIViewController {\n    @MainActor var myProperty: String\n\n    @MainActor func updateUI() {\n        // 更新UI的代码\n    }\n}\n```\n\n在这个例子中，`myProperty`属性和`updateUI`方法被标记为`@MainActor`，确保它们在主线程上执行。\n\n### 2. 使用`MainActor`执行代码块\n\n可以使用`MainActor.run`来执行一个代码块。\n\n```swift\nTask {\n    await MainActor.run {\n        // 在主线程上执行的代码\n    }\n}\n```\n\n这种方式在异步代码中切换回主线程更新UI时非常有用。\n\n### 3. 与全局actor的区别\n\n`MainActor`是一个全局actor，这意味着它是单例的，整个应用中只有一个`MainActor`实例。\n\n## 注意事项\n\n- 使用`MainActor`时，要确保只有与UI相关或必须在主线程上执行的代码被标记。\n- 对于需要高性能的计算或后台处理的代码，应避免在`MainActor`上执行。\n\n## 总结\n\n`MainActor`是Swift中处理并发UI更新的重要特性。它通过确保UI相关代码在主线程上执行，帮助开发者编写更安全、更简洁的UI代码。\n","n":0.158}}},{"i":259,"$":{"0":{"v":"Json","n":1},"1":{"v":"\n\n# Swift中的`Decodable`协议\n\n## 概述\n\n`Decodable`是Swift标准库中的一个协议，用于将数据（如JSON）解码为Swift的数据类型。\n\n## 作用\n\n- **数据解码**: 允许你将符合外部格式（如JSON、XML）的数据转换成Swift内部的数据类型。\n- **简化解析流程**: 使用`Decodable`可以大幅简化从外部数据源到Swift对象的转换过程。\n\n## 使用`Decodable`\n\n### 1. 定义符合`Decodable`的类型\n\n首先，你需要定义一个符合`Decodable`协议的结构体或类。\n\n```swift\nstruct User: Decodable {\n    var name: String\n    var age: Int\n}\n```\n\n在这个例子中，`User`结构体可以解码包含`name`和`age`字段的JSON对象。\n\n### 2. 解码JSON\n\n然后，你可以使用如`JSONDecoder`的解码器来将JSON数据转换为`User`类型的实例。\n\n```swift\nlet json = \"\"\"\n{\n    \"name\": \"张三\",\n    \"age\": 28\n}\n\"\"\".data(using: .utf8)!\n\nlet decoder = JSONDecoder()\ndo {\n    let user = try decoder.decode(User.self, from: json)\n    print(user.name) // 输出: 张三\n} catch {\n    print(error)\n}\n```\n\n## 注意事项\n\n- 字段匹配：`Decodable`类型的属性名需要与JSON中的键匹配，或者你需要自定义`CodingKeys`来映射不匹配的键。\n- 数据类型匹配：JSON中的数据类型需要与Swift中的对应类型匹配。\n- 错误处理：解码过程可能会抛出错误，通常需要使用`try-catch`语句来处理。\n\n## 总结\n\n`Decodable`协议是Swift中处理数据解码的关键工具。它在将外部数据（如JSON）解码为Swift内部数据类型时非常有用，使得数据处理变得简单和直接。\n","n":0.137}}},{"i":260,"$":{"0":{"v":"Guard","n":1},"1":{"v":"\n\n# Swift中的`guard`语句\n\n## 基本概念\n\n`guard`语句在Swift中用于提前退出一个代码块，如果其条件不满足。它主要用于提高代码的可读性，通过减少嵌套并快速处理错误情况。\n\n## 基本语法\n\n```swift\nguard 条件 else {\n    // 条件不满足时执行的代码\n    return或throw或break等\n}\n// 条件满足时继续执行的代码\n```\n\n## 使用示例\n\n### 1. 检查条件并提前退出\n\n```swift\nfunc greet(name: String?) {\n    guard let name = name else {\n        print(\"没有提供名字\")\n        return\n    }\n    print(\"Hello, \\(name)!\")\n}\n```\n\n在这个例子中，如果`name`是`nil`，`guard`语句将确保函数提前退出，并打印一条消息。如果`name`不是`nil`，它的值将被解包并用于后面的`print`语句。\n\n### 2. 与`if`语句的比较\n\n`guard`语句与`if`语句的主要区别在于，`guard`总是有一个`else`分支，用于处理条件不满足的情况。而`if`语句则是可选的。\n\n```swift\nif let name = name {\n    print(\"Hello, \\(name)!\")\n} else {\n    print(\"没有提供名字\")\n}\n```\n\n相比之下，使用`guard`可以减少嵌套，使代码更清晰。\n\n## 总结\n\n`guard`语句是Swift中处理错误和提前退出的强大工具。它帮助你写出更清晰、更易于维护的代码，特别是在需要多个条件检查时。\n\n","n":0.154}}},{"i":261,"$":{"0":{"v":"Async","n":1},"1":{"v":"\n# Swift中的`async`关键字\n\n## 异步函数 (`async`)\n\n在Swift中，`async`关键字用于标记一个函数或方法是异步的。这意味着该函数可以在等待某些长时间运行的操作完成时暂停其执行，而不会阻塞当前线程。\n\n## 基本语法\n\n```swift\nfunc functionName() async -> ReturnType {\n    // 异步操作\n}\n```\n\n## 使用`async`的优势\n\n- **非阻塞**: 异步函数允许CPU继续处理其他任务，而不是等待当前任务完成。\n- **更好的性能**: 在处理I/O、网络请求或其他耗时操作时，提高了应用的响应性和性能。\n- **改善代码可读性**: 异步函数有助于写出更简洁、更易于理解的代码。\n\n## 示例：异步函数\n\n### 1. 定义一个异步函数\n\n```swift\nfunc fetchData() async -> Data {\n    // 假设这是一个从网络获取数据的操作\n    let url = URL(string: \"https://example.com/data\")!\n    let (data, _) = try! await URLSession.shared.data(from: url)\n    return data\n}\n```\n\n在这个例子中，`fetchData`函数使用`async`关键字标记。它执行一个网络请求，这是一个典型的异步操作。\n\n### 2. 调用异步函数\n\n```swift\nfunc displayData() async {\n    let data = await fetchData()\n    // 使用数据进行一些操作\n}\n```\n\n要调用异步函数，你需要使用`await`关键字。这告诉Swift暂停函数的执行，直到异步操作完成。\n\n## 注意事项\n\n- 异步函数只能在另一个异步上下文中被`await`调用。\n- 不能在同步函数中直接调用异步函数，除非使用特定的异步API，如`Task`。\n- `async`与`await`是Swift并发模型的一部分，要充分利用它们，需要对Swift的并发模型有一定的了解。\n\n## 总结\n\n`async`关键字是Swift中处理异步操作的强大工具，它有助于编写同时高效和可读的代码，特别是在处理网络请求、文件I/O或其他需要等待的操作时。\n","n":0.128}}},{"i":262,"$":{"0":{"v":"Array","n":1},"1":{"v":"\n\n# Swift中的数组操作\n\n## 初始化数组\n\n### 1. 空数组\n\n```swift\nvar emptyArray = [Int]()\n```\n\n### 2. 具有默认值的数组\n\n```swift\nvar defaultValuesArray = Array(repeating: 0, count: 5) // [0, 0, 0, 0, 0]\n```\n\n### 3. 字面量初始化\n\n```swift\nvar literalArray: [String] = [\"Apple\", \"Banana\", \"Cherry\"]\n```\n\n## 增加元素\n\n### 1. 使用`append`\n\n```swift\nvar fruits = [\"Apple\"]\nfruits.append(\"Banana\") // [\"Apple\", \"Banana\"]\n```\n\n### 2. 使用`+=`运算符\n\n```swift\nfruits += [\"Cherry\"] // [\"Apple\", \"Banana\", \"Cherry\"]\n```\n\n## 删除元素\n\n### 1. 使用`remove`\n\n```swift\nfruits.remove(at: 0) // 移除第一个元素，剩下[\"Banana\", \"Cherry\"]\n```\n\n### 2. 移除最后一个元素\n\n```swift\nfruits.removeLast() // 移除最后一个元素，剩下[\"Banana\"]\n```\n\n## 修改元素\n\n直接通过索引修改数组中的元素。\n\n```swift\nfruits[0] = \"Strawberry\" // [\"Strawberry\"]\n```\n\n## 遍历数组\n\n使用`for-in`循环遍历数组。\n\n```swift\nfor fruit in fruits {\n    print(fruit)\n}\n```\n\n## 总结\n\n数组是Swift中常用的数据结构，用于存储同类型的多个值。理解如何有效地初始化、添加、删除和修改数组中的元素对于任何Swift开发者来说都是基本且重要的技能。\n","n":0.12}}},{"i":263,"$":{"0":{"v":"Processing","n":1}}},{"i":264,"$":{"0":{"v":"Pe_domain","n":1},"1":{"v":"\n# Monitoring\n\n# Logging \n\n# Alerting\n\n# Automation","n":0.408}}},{"i":265,"$":{"0":{"v":"Libra","n":1},"1":{"v":"\n# libra production\n\nstep 1: \n\n- single docker image + deploy on AWS ECS\n- pre-generated key\n- run majority\n\nstep 2:\n\n- better isolation between components\n- tooling support\n- moved to Kubernetes\n- run multiple cloud\n- minimum validator architecture\n\n![](/assets/images/2021-04-21-09-59-53.png)\n\nstep 3:\n\n- security enhancement\n  - store keys in vault\n- production deployment\n  - isolating the validator network\n  - provide public access\n\n![](/assets/images/2021-04-21-10-08-06.png)\n\nstep 4:\n\n- tooling support\n- support backup and restore\n- operational readiness\n\n\nstep 5:\n\n- storm, DR\n- runbook\n- training\n- falut tolerance policy\n- support diversity deployment","n":0.118}}},{"i":266,"$":{"0":{"v":"Network","n":1},"1":{"v":"\n# OSI\n\n- [[Application|development.network.applicationlayer]]\n- Presentation\n- Session\n- [[Transport|development.network.transportlayer]]\n- [[Netwrok|development.network.networklayer]]\n- [[Link|development.network.linklayer]]\n- [[Pysical|development.network.physicallayer]]\n\n![](/assets/images/2021-05-14-09-29-00.png)\n\n# network type\n\n- circuit switching\n  - dedicated circuit per call, no sharing, setup required\n  - network bandwidth divided into pieces: FDM, TDM\n- packet switching\n  - each packet use full bandwidth\n  - move hop-at-a-time, get complete packet before forwarding\n  - statistical multiplexing\n  - store-and-forward.\n  - L bits, R bps throughput, take L/R seconds to transmit","n":0.127}}},{"i":267,"$":{"0":{"v":"Transportlayer","n":1},"1":{"v":"\n# transport layer\n\ntcp/udp\n\n- end-to-end, broke whole messages to segments\n- connection-oriented service: reliable delivery, error detection, congestion control, flow control\n- connectionless service: best effort delivery\n\n\n![](/assets/images/2021-03-25-16-41-46.png)\n\n- mission: **Logical** connection, between applications running on different hosts\n- Logical communication = as if the applications were directly connected\n    - scope: between applications\n    - addressing mechanism: multiplex, port numbers bound to an application, 16-bit unsigned number\n    - data types: segment\n- responsibilities: \n    - **multiplex** messages/de..  end host run **mulitple** applications -> addressing\n    - break data to segments and re-assembly\n        - segmentation, broken into segments\n    - connection setup and state management and tear down\n    - TCP: reliability guarantee\n    - Transport layer adds header with additional information (port numbers, ...)\n  \n","n":0.094}}},{"i":268,"$":{"0":{"v":"Udp","n":1},"1":{"v":"\n# udp\n\n- advantages/disadvantages\n    - adv:\n        - connectionless: no connection establishment, thus no additional delay\n        - fast: no handshake\n        - each segment handled independently\n        - Very simple: no state to maintain\n        - Segment header is small\n    - dis\n        - segments may be lost\n        - may out-of-order\n        - no congestion control\n        - There are no guarantees with UDP.\n- segment format\n    - source port, dest port, length(**whole segment** at least 8 byte(header size)), checksum, application data\n- reliability assumptions\n    - Often used for **streaming** multimedia apps \n    - Loss tolerant\n    - **Rate sensitive** (timeliness)\n    - Reliability can be added at app layer\n\n\n","n":0.101}}},{"i":269,"$":{"0":{"v":"Tcp","n":1},"1":{"v":"\n# TCP\n\n- point-to-point / reliable / in-order byte stream / pipelined: sliding windows\n- full duplex data: bi-directional data flow\n- connection-oriented: handshaking (exchange of control messages) initializes sender & receiver state before data exchange\n- Both sides have buffers\n- Flow Control\n- Congestion Control\n\n## connection and tear down\n\n- establish: setup state before exchanging data segements\n  - step1: send SYN segment and specifies initial seq#, no data\n  - why random sn? an earlier incarnation of the same connection can interfere with a later one\n  - step2: server respond with SYNACK segment, allocates buffers and specifies initial seq#\n  - step3: replies with ACK, may contain data\n  - if host receive with SYN to a closed port, responds with a RST segments \n- teardown: free up state \n  - step1: send TCP FIN to server\n  - step2: server responds with ACK and closed, send FIN\n  - step3: client receives FIN, replies with ACK , wait \n  - why? possible ACK lost\n  - Client may open the same connection again (same pair of port #s) \n  - then Receives FIN from earlier incarnation of connection\n  - so Immediately initiate closing of the later incarnation\n  - Step 4: server receives ACK, closes connection\n\n\n## RDT\n\n  - TCP creates RDT service on top of IP’s unreliable service\n    - Pipelined segments \n    - Cumulative acks\n    - Retransmission timer\n  - Retransmissions are triggered by:\n    - timeout events \n    - duplicate acks\n  - Initially, we consider simplified TCP sender:\n    - ignore duplicate acks\n    - ignore flow control, congestion control\n    - assume RTT is estimated somehow\n  - SN : byte stream “number” of first byte in segment’s data\n  - ACKs: seq # of next byte expected from other side\n    - **cumulative** ACK: acknowledges bytes up to the first missing byte in the stream\n  - Data received from app:\n    - Create segment\n    - seq# is byte-stream number of first data byte in segment\n    - Send, if allowed by congestion & flow-control\n    - start timer if not already running (think of timer as for oldest unacked segment)\n    - expiration interval: TimeOutInterva\n  -  Timeout:\n    -  retransmit segment that caused timeout\n    -  restart timer\n  - ACK received:\n    -  If acknowledges previously unACKed segments\n    -  update what is known to be ACKed\n    -  start timer if there are outstanding segments\n  - fast retransmit\n    - If segment is lost, there will likely be many duplicate ACKs\n    - If sender receives 3 duplicate ACKs, it supposes that segment after ACKed data was lost: resend segment before timer expires： voodoo constant\n\n![[development.network.reliable_data_transfer]]\n## Flow control\n\n- mission: Sender won’t overflow the **receiver’s buffer** by transmitting too much, too fast\n  - matching the send rate to the receiving app’s drain rate\n  - operation:\n- mechanism\n    - RcvWindow = RcvBuffer - [ LastByteRcvd - LastByteRead ] (assume discard out of order)\n    - Receiver advertises spare room by including value of RcvWindow in ACK segment\n    - Gives sender permission to send this much\n\n- congwin: how much data allowed in-flight at any time, >= LastByteSent-LastByteAcked\n    - **rate = congwin/RTT**\n- sender perceive congestion: timeout / 3 duplicate ACKs\n- self-clocking nature: use ACK to trigger its increase in congestion window size\n- interaction of various phases \n  - When CongWin is below Threshold, window grows exponentially (slow-start phase)\n  - When CongWin is above Threshold, window grows linearly (congestion-avoidance phase)\n  - When a triple duplicate ACK occurs, Threshold set to CongWin/2 and CongWin set to Threshold. Window grows linearly\n  - When timeout occurs, Threshold set to CongWin/2 and CongWin is set to 1 MSS. Enters slow-start phase\n- slow start\n  - start with MSS = 1, increase exponentially, done by increasing CongWin by 1MSS for every ACK received\n  - With Slow Start, no bandwidth wasted on retransmission\n  - end: first lost event\n- congestion avoidance\n    - start: first lost event\n        - cut CongWin in half after a loss event\n        - Continue probing for usable bandwidth\n    - Reno: after 3 dup, cancel slow start, cut half CongWin, grows linearly\n        - after timeout, set ssthrehold to half, skip ss, fast recovery.\n        - fast retransmit:  after 3 dup\n    - Tahoe: after loss event, congwin set to 1, enter slow start\n- how TCP sets timeout values.\n    - longer than RTT. \n    - too short, premature timeout, unnecessary retransmissions\n    - too long, slow reaction to segment loss\n    - need to measure RTT for baseline\n\n","n":0.038}}},{"i":270,"$":{"0":{"v":"Transit","n":1},"1":{"v":"\n## Peering\n\n![](/assets/images/2021-03-25-16-50-29.png)\n\n![](/assets/images/2021-03-25-16-52-09.png)\n\n## FNA\n\n![](/assets/images/2021-03-25-16-50-00.png)\n\n## network types\n\n![](/assets/images/2021-03-25-16-52-47.png)","n":0.447}}},{"i":271,"$":{"0":{"v":"Synctime","n":1},"1":{"v":"\n\n1. SYNCHRONIZING PHYSICAL TIME: central server\n1. time server and distributed to nodes. Latency between transfer could be a problem.\n    - 估计来回的时间\n    - 注意不要回到过去\n    - 可以miss tick放慢时间\n2. 没有一个标准时间的话，就设立一个master询问每个client时间，average.调整时间是原来的两倍。\n3. BERKELEY ALGORITHM: server向所有人请求时间，算入RTT，average，返回client，注意drift可能是原来的两倍。\n3. logical time: 保证顺序。高时间不可能导致低时间的任务发生。\n4. LAMPORT LOGICAL TIME: happened before\n    - The counter is incremented before each event.\n    - The message should carry the new (incremented) timestamp.\n    - 维护全局index，不能处理接受和发送的问题\n    - If two events have no message exchange, Lamport logical time cannot tell which one happened first\n    - 可能出现无法处理因果的情况\n5. google truetime: compares itself with others, twice drift\n6. Cristian's Algorithm is one approach to synchronizing physical clocks using a time server.","n":0.102}}},{"i":272,"$":{"0":{"v":"Sessionlayer","n":1},"1":{"v":"\n\n![](/assets/images/2021-03-25-16-43-26.png)\n\n- rpc","n":0.707}}},{"i":273,"$":{"0":{"v":"Rpc","n":1},"1":{"v":"\n1. REMOTE PROCEDURE CALL: REPLACE COMMUNICATION VIA THE STACK WITH THE NETWORK\n    - A type of client/server communication\n    - Attempts to make remote procedure calls look like local ones\n2. problem:\n    - Calling and called procedures run on different machines, with different address spaces\n    - Must convert to local representation of data\n    - Machines and network can fail\n3. STUBS: OBTAINING TRANSPARENCY\n    - Client stub\n        - Marshalsargumentsintomachine-independentformat\n        - Sendsrequesttoserver\n        - Waits for response\n        - Unmarshals result and returns to caller\n    - Server stub\n        - Unmarshals arguments and builds stack frame \n        - Calls procedure\n        - Server stub marshals results and sends reply\n4. RFC makes a user defined header to a entire empty server library and user can filled them in.\n5. 写个接口让程序员调用服务器上的方法就像本地一样\n6. 通过编码和解码传输参数，遇到大小端的问题的话，可以采用语言将数据包装，这样就和地址顺序无关了。\n7. 存在的问题是：如果调用失败，可能是server或者网络的问题，无法排查。解决方式可以是在server保证最多一次request，出现第二次也返回第一次的reply \n8. 同步方法：1. 只进行一次rpc，允行完再ack 2. 两次rpc，收到请求ack，运行完ack","n":0.089}}},{"i":274,"$":{"0":{"v":"Reliable_data_transfer","n":1},"1":{"v":"\n# RDT\n\n## possible failure\n\nbit-errors, lossy, duplicate delivery , out-of-order delivery\n\n## methods\n\n- checksums: bit error \n- receiver feedback: bit error, ACK/NACK， Cumulative acknowledgments(I have received all packets with sequence numbers up to but not including sn.) allow acknowledgment of numerous packets at a time. They can be useful in pipelined protocols. 可能lost\n- retransmission : Sender sends another copy of segment, detect loss and allows for duplicate seg\n- sequence numbers : Distinguish between old and new, Gaps let receiver detect lost segment, find duplicate packets，restoring the transmitted order. have to be a bounded # bits\n- timer expiration: Segment or receiver feedback is lost (sender: Resends a packet after a timer fires. Sends a new packet after an acknowledgment (positive) arrives.)\n- window:Control sending of multiple segments, allow for reuse of sequence numbers, also allow for pipeling segments\n\n## protocols\n\n### Stop-n-Wait\n\n - Simplest Protocol that will handle bit errors and segment loss\n    - use: checksum, ack, sn, timers\n    - 1 bit for sequence number\n    - ![](/assets/images/2021-04-03-23-06-30.png)\n    - ![](/assets/images/2021-04-03-23-07-36.png)\n    - 为了解决checksum返回的时候有问题。可能ack会lost。带来的问题就是可能重复发几次。所以需要seq num\n    - ![](/assets/images/2021-04-03-23-08-48.png)\n    - 计时发送，看指定时间能否达到response, 没seq num. 接收者不能知道是否是重发。LOST ACK和lost segment对于发送方式一样的\n\n\n## Go Back N\n       \n- sliding window: A mechanism to control multiple, in-flight segments without overwhelming receiver, Sender is allowed to transmit N segments without waiting for an ACK\n- “window” of up to N, consecutive unACKed segments allowed\n- Sets a **timer** for each in-flight segment\n- timeout(n): retransmit segment n and all **higher** seq# segments in window\n- sender:\n  - Sender places a k-bit seq# in header\n  - “window” of up to N, consecutive unACKed segments allowed\n  - Sets a timer for each in-flight segment\n  - timeout(n): retransmit segment n and **all higher** seq# segments in window\n  - ACK(n): ACKs all segments up to, including seq# n (Cumulative ACK)\n- receiver: ACK-only: always send ACK for correctly-received segment with **highest in-order seq**, Receipt of out-of-order segment just discard and send with highest in-order seq \n    - May generate duplicate ACKs\n    - Why discard segs received out-of-order： Don’t want to buffer them, going to be re-sent anyway\n- A single segment error can cause many segments to be retransmitted\n\n## Selective Repeat\n\n  - Receiver individually ACKs all correctly received segments\n  - Buffers segs for eventual in-order delivery\n  - Sender only resends segments for which ACK not received\n  - Sets timer for each segment\n  - Sender window of N consecutive seq#s\n  - Limits seq # s of sent, but unACKed segs\n  - ![](/assets/images/2021-04-03-23-12-02.png)\n  - issues: both side have varying view, receiver window移动了，但是发送端没收到ack， 会重传。\n  - sequence number的space至少是2^k 个，k是window的大小","n":0.05}}},{"i":275,"$":{"0":{"v":"Queue","n":1},"1":{"v":"\n# queue theory\n\n- performance evaluation\n  - $\\lambda$ average arrival rate, packets per second\n  - $\\mu$ average service rate, packets servered per second\n  - $c$ number of servers\n  - $\\rho = \\lambda/c\\mu$ traffic congestion in servers\n    - if >1 averge exceeds service capability\n    - if = 1 randomness prevents queue from emptying\n  - $p_n$ is probability of a particular number n customers in the system\n  - expected number in system: $L = \\sum(n p_n)$\n  - expected number in queue: $L = \\sum_{n=c+1}((n-c) p_n)$\n  - time : $T = T_q + S$ time in queue + service time\n  - **little law**\n    - $W = E[T] W_q = E[T_q]$ mean waiting time in system\n    - $L = \\lambda W$ \n    - $E[T] = E[T_q] + E[S]$ to get $W = W_q + 1/\\mu$\n    - expected servered people: $E[N_s] = L-L_q = \\lambda(W-W_q) = \\lambda(1/\\mu) = \\lambda/\\mu$\n    - $c = 1, r = \\rho , L-L_q = \\sum_{n=1} np- \\sum_{n=1} (n-1)p = \\sum_{n=1} p_n =  1-p_0=\\rho$\n  - busy probability\n    - for G/G/c system, $E[N_s] = r$\n    - $P_b = \\rho$ one server being busy brobability\n    - ...\n\n- rate transition diagrams\n  - a type of continuous-time Markov chain\n  - $(\\lambda_n+\\mu_n)p_n =(\\lambda_{n-1}+\\mu_{n-1})p_{n-1}+(\\lambda_{n+1}+\\mu_{n+1})p_{n+1}$\n  - $p_3 = \\frac{\\lambda_2 \\lambda_1 \\lambda_0}{\\mu_3 \\mu_2 \\mu_1} p_0 $\n  - $p_n = \\prod_{i=1}^n\\frac{\\lambda_{i-1}}{\\mu_i}$\n\n- M/M/1 system\n  - Exponentially distributed \n    - interarrival time $TI(t)=\\lambda e^{-\\lambda t}$\n    - service time $TI(t)=\\mu e^{-\\mu t}$\n  - if all $\\mu$ and $\\lambda$ equal get $p_n = p_0 (\\frac{\\lambda}{\\mu})^n$\n  - $p_0 = 1-\\rho$ - > $p_n = (1-\\rho)\\rho^n$","n":0.063}}},{"i":276,"$":{"0":{"v":"Programming","n":1},"1":{"v":"\n\n# basic\n\n- socket: `ip:port`\n  - 客户端： port是由内核自动分配的\n  - server端：port是和服务对应的\n- 一个连接是一个socket pair\n\n\n![](/assets/images/2021-05-03-20-17-16.png)","n":0.302}}},{"i":277,"$":{"0":{"v":"Problem","n":1},"1":{"v":"\n# problem happened in the network\n\n## data loss\n\n## delay\n\n- processing, time spent in router, check bit error, determine output link\n- queueing, depends on congestion level\n- transmission delay: L/R bits/ bps\n- propagation delay: d/s (length/2*10^8)\n- $\\lambda$ = avg packet arrival rate(pts/s), traffic intensity: $L \\lambda /R$ value -> 1, delay becomlarge.\n- nodal delay = $d_{proc}+d_{queue}+d_{trans}+d_{prop}$\n\n### measurement\n\n- tracerouter algo:\n   - for all router i:\n        - send three packets to router i \n        - router i will return packets to sender\n        - measure transmission and reply interval","n":0.109}}},{"i":278,"$":{"0":{"v":"Physicallayer","n":1},"1":{"v":"\n![](/assets/images/2021-03-25-15-54-22.png)","n":1}}},{"i":279,"$":{"0":{"v":"Networklayer","n":1},"1":{"v":"\n# network layer\n\nip\n\n**transfer packets across links**, addressing scale to large networks, routing protocol determines best paths across the network\n\n\n## IP\n\naddressing mechanism: IP ADDRESS \n\n- No call setup at network layer\n- Packets are forwarded using address of the destination host\n- Packets are forwarded independently\n- Packets between same source-dest pair may take different paths\n- addressing\n  - Each end-host has unique address\n  - Forwarding table maps addresses to outgoing link\n\n### packet\n\n- data types: packet\n  - On sending side, encapsulate segment into packets\n  - Transmit the packet through the network\n  - Network layer protocols exist on all routers (and hosts) for this purpose\n  - On receiving side, deliver packets to transport layer\n\n### routing\n\n- Routing (Control Plane)\n    - **Involves all routers in a network**\n    -  Creates a **forwarding** table to determine end-to-end paths taken by packets\n    -  Uses routing algorithms\n- Forwarding (Data Plane)\n    - Move packets from router’s incoming interface to appropriate outgoing interface\n    - An action in a single router\n    - use forwarding table\n- Connection Setup: setup route states before sending packets\n\n### format\n\n- packet-handling operations at each router\n    - forward with destination of address\n    - forward independently\n- format\n    - Version specifies IPv4\n    - Header length (in 32-bit words)\n    - Type of Service\n    - Datagram length (Header + data) 20bytes+data\n    - ID, Flags, Offset: Used for fragmentation at router\n        - 1 DF Don't fragament\n        - 2 MF more fragament\n        - ID unique\n    - Time-to-Live: Decremented at each router, Datagram dropped if zero\n    - Protocol\n        - Used by receiver to determine which transport protocol should get packet\n    - Header checksum: Calculated only on header\n        - Must be recomputed at each router: because ttl changes\n    - use checksum because other protocol maybe involved\n    - Data: Encapsulated TCP/UDP segment . ICMP data\n\n### ipv4\n\n- prefix notation: range of subnet 128.2.101.64/26\n    - 6 bit free\n    - example: 223.1.17.0/25 for /24 half, 223.1.17.128/26 for 64, 223.1.17.192/26 for 64\n- forwarding tables:\n    - put prefix matching in destination prefix\n    - match the leading bits of destination address to the longest listed prefix: **longest matching prefix rule**\n- CIDR classless interdomain routing\n\n\n![](/assets/images/2021-03-25-16-00-27.png)\n\n![](/assets/images/2021-03-25-16-14-19.png)\n\n\n### ICMP\n\n- single ip packet\n    - no reliability\n    - type/ code for echo/unreachable....\n- traceroute:\n    - send nth udp segments has TTL of n\n    - replies with ICMP time exceeded\n- is a network-layer protocol\n    - Messages used for communication between routers and end-hosts\n    - Messages sent in an IP packet - Just like a UDP segment\n    - Messages require special processing by the IP layer software on each router\n\n### forwarding table\n\ndijkstra\n\n![](/assets/images/2021-04-11-21-58-17.png)\n\n- 每次更新新加入的点到未加入点的距离。每次从未加入点中选一个距离到已加入的set里\b最小的\n  - short path tree\n  - use dijkstra's to get routing table\n  - O(n^2)\n\nbellman-ford\n\n- Each node periodically sends its own distance vector estimates to neighbors\n- When a node x receives a new DV estimate from a neighbor v, uses B-F\n- Dx(y) ←minv{c(x,v)+Dv(y)} for each y ∈ N\n- The estimate Dx(y) converges to the actual dx(y) for minor, natural conditions\n\n## AS\n\n- A collection of physical networks with a unif\n    - ISP, A Corporate network, A Campus networ\n- An AS may get an AS number (ASN)\n    - ASNs represent units of routing policy\n- AS can have one/many/none ASN\n\n\n## BGP\n\n- function\n    - Obtain network reachability information from neighboring AS\n    - Propagate the reachability information to all routers internal to the AS\n    - Determine “good” routes to subnets based on the reachability information and on AS policy\n    - Advertise its existence to the rest of the Internet!\n- Uses path vector routing algorithm\n- Is heavily policy-based\n- Principles of Operation\n    - A BGP session is established between routers (TCP)\n    - exchange route UPDATE messages while connection is ALIVE\n    - message\n        - open： set up session\n        - keepalive: confirms liveness to neighbor\n        - notificatoin: signals an error before\n        - UPDATE: Primary message to communicate information about routes\n            - Announce or withdraw routes\n            - Route = prefix + path attributes\n    - eBGP runs between ASes\n    - iBGP within AS\n\n\n![](/assets/images/2021-03-25-16-16-40.png)\n\n![](/assets/images/2021-03-25-16-18-44.png)\n\n![](/assets/images/2021-03-25-16-20-16.png)\n\n![](/assets/images/2021-03-25-16-22-51.png)\n\n![](/assets/images/2021-03-25-16-28-17.png)\n\n## DHCP\n\n- Dynamic Host Configuration Protocol (IP)\n- information carried: a pool of IP addresses, a repository of network details\n    -  Provides these details upon request or by default\n- methods of communication : broadcast, Send to 255.255.255.255, UDP, port 67\n- leases : Used for dynamic allocation, Solution for control of when an address can be given to another client\n    - Server allows use of addr for a set period, Client will need to reacquire permission before lease period expires(automatically)\n- message format:\n    - type: discover, offer, request, ack, release\n    - xid: Random transaction value (client 发，用于定位client)\n    - chaddr: client hardware identifier\n    - siaddr: server’s IP address\n    - yiaddr: “your” address\n    - options: lots of optional parameters\n- the discovery process\n    - broadcast first, Multiple servers may respond\n    - Client chooses whichever offer it wishes\n    - DHCP Request / Ack is repeated to renew a lease\n\n\n## NAT\n\n- Network Address Translation\n    - router manage a subnet\n    - map one address space to another\n- benefits\n    - Work-around to the impending exhaustion of IP addresses  \n    -  Also allows for simple address allocation for the subnet\n    - “Security”: internal network structure obscured\n- objections\n    - IPv6 should be used to solve addressing problem\n    - Objection 2: Violates end-to-end principle\n    - Objection 3: Routers shouldn’t process packets higher than network layer\n    - Objection 4: Using port numbers to address hosts\n- operations\n    - hosts on private network use \"non-routable\" ip addresses (10.0.0.0/8 172.16.0.0/16 192.168.0.0/16)\n    - these addresses are not unique, restricted to the private subnet\n    - Router shows a single external IP address\n    - Translation table maps external IP / port combinations to internal IP / port\n    - rewrite all packets in each direction, changing based on translation table\n        - Other fixes also needed to the packet\n    -  Packet Fix-up\n        - Fix checksums\n        - Router must do more than simply change address/port values\n- port forwarding.\n    - NAT Address Translation Table\n    - Translation table is normally initialized by internal traffic\n    - Port forwarding specifies values ahead of time\n\n\n# tool\n\n- ping: send one packets and cal RTT\n- traceroute: will send 3 packets to each router it.","n":0.032}}},{"i":280,"$":{"0":{"v":"Loadbalance","n":1},"1":{"v":"\n# load balance \n\n\n把一系列task分给不同的机器。\n\n- 静态\n  - it does not take into account the state of the system for the distribution of tasks\n  - are easy to set up and extremely efficient in the case of fairly regular tasks\n- 动态\n  - take into account the current load of each of the computing units\n  - tasks can be moved dynamically from an overloaded node to an underloaded node in order to receive faster processing\n\n## proxy\n\n- Client-side random load balancing: deliver a list of server IPs to the client, and then to have client randomly select the IP from the list on each connection\n  - the method of delivery of list of IPs to the client can vary\n- Server-side load balancers\n  - The load balancer forwards requests to one of the \"backend\" servers\n  - load balancers are implemented in high-availability pairs which may also replicate session persistence data if required by the specific application\n\n- presistence\n  -  important issue when operating a load-balanced service is how to handle information that must be kept across the multiple requests in a user's session. \n  -  One basic solution to the session data issue is to send all requests in a user session consistently to the same backend server.\n  -  Assignment to a particular server might be based on a username, client IP address, or be random.\n  -  use memcache to save session info\n  -  a simple but efficient approach is to store the per-session data in the browser itself: cookie\n     -  or URL rewriting\n\n\n### forward\n\n前向代理作为客户端的代理，将从互联网上获取的资源返回给一个或多个的客户端，服务端（如Web服务器）只知道代理的IP地址而不知道客户端的IP地址\nForward proxies ensure that websites never communicate directly with a user\n\n![](/assets/images/2021-05-03-22-38-13.png)\n### reverse\n\n反向代理是作为服务器端（如Web服务器）的代理使用，而不是客户端。反向代理是供很多客户端都通过它间接访问不同后端服务器上的资源，而不需要知道这些后端服务器的存在，而以为所有资源都来自于这个反向代理服务器。\nreverse proxies ensure that users would not communicate directly with a back-end server.\n![](/assets/images/2021-05-03-22-39-21.png)\n\nA reverse proxy server is a type of proxy server that typically sits behind the firewall in a private network and directs client requests to the appropriate backend server. A reverse proxy provides an additional level of abstraction and control to ensure the smooth flow of network traffic between clients and servers.\n\n## DNS  \n\n- round-robin DNS: multiple IP addresses are associated with a single domain name\n- [DNS delegation](https://en.wikipedia.org/wiki/Load_balancing_(computing)#DNS_delegation): delegate www.example.org as a sub-domain whose zone is served by each of the same servers that are serving the web site. This technique works particularly well where individual servers are spread geographically on the Internet. ","n":0.052}}},{"i":281,"$":{"0":{"v":"Linklayer","n":1},"1":{"v":"\n# data link layer\n\nethernet, wifi, fiber, telephony\n\ntransfer frames: ethernet, PPP, MAC address (add size, error correction codes)\n\n- Inserts framing info to denote frame boundaries\n- Inserts control, addressing and error correction info in header\n- Detects transmission errors on link. May retransmit frames\n- Activation, maintenance, & deactivation of link connection\n\n\n![](/assets/images/2021-03-25-15-55-22.png)\n![](/assets/images/2021-03-25-15-56-16.png)\n\n![](/assets/images/2021-03-25-15-58-20.png)\n\n- mission: transfer frames from one node, over a link\n- scope: Service received from physical layer is the ability to move a bit across the link\n    - A packet is transferred by different link protocols over different links\n    - Each data link protocol provides different services\n- addressing mechanism:MAC\n- data types : frame\n- responsibilities/services\n    - Framing:  encapsulate datagram into frame, adding header, trailer; identify source, destination with addresses • Different from IP \naddresses!!\n    - Link access: use medium access control (MAC) protocol\n    - Error Detection\n    - Error Correction\n    - Reliable Delivery: critical for wireless links ➙ high error rates\n\n## CSMA/CD\n\n- Carrier Sense: Listen before talking Multiple Access: Broadcast Medium\n- Collision Detection: Listen as you talk. If you hear someone else, be quiet\n- Capturing a Channel: If no other station initiates transmission during this period, sender has captured the channel. t = tprop\n- **Ethernet** is the most famous example\n- Before transmitting, listen\n- If channel is sensed idle, send the frame \n-  Else, defer transmission a random time\n- If collision is detected, abort transmission \n- reduces channel wastage\n- **Min transmission time must be long enough for collisions to propagate**\n- Length of the packet >= 2 * Tp * Bandwidth of the link worst case\n\n\n## ARP\n\n- mission: Translate a network-layer address (IP) to a link-layer address (MAC), Similar to DNS\n- frame fields:\n  - Sender Ethernet and IP address\n  - Target Ethernet and IP address\n- transmission mechanism\n    - Sent in an Ethernet frame to a broadcast address\n    - ARP Reply takes the same form\n    - broadcast request, if some one know, reply\n    - if in another subnet, sent datagram to router \n- caching\n    - Each Ethernet adapter uses a table to keep track of known mappings between IP addresses and Ethernet MAC Addrs\n    - When given IP address, ARP looks in ARP table and returns corresponding MAC address\n        - If IP not in table, queue frame and broadcast ARP request\n- security\n    - ARP frames are not authenticateds\n    - May be spoofed by a malicious entity\n    - May be proxied by design\n- gratuitous use\n    - ARP can be an “announcement” protocol\n    - Can send an ARP frame just to update other node’s ARP tables\n    - Set target address and sender address to the same value\n\n\n## csma/ca\n\n- CSMA / Collision Avoidance\n- 1. Listen for a specified time (DIFS) If medium is not free:\n    - 1. Exponential Backoff (下次请求的时间)\n- If medium is free:\n    - Transmit entire frame\n    - Await ACK frame （AP send ACK to sender）\n    - If no ACK, then Exponential Backoff\n- ACK\n    - protects against bit errors\n    - Receiver only sends ACK if frame passes CRC\n- Exponential Backoff\n    -  Each node chooses a random number \n    -  Max size increases from round to round\n    -  Can be modeled as a counter (wait time)\n        -  Decremented during any idle time\n        -  Put on hold if another node transmits and for a short time afterwards (SIFS)\n        -  When zero, the counting station may transmit","n":0.043}}},{"i":282,"$":{"0":{"v":"Component","n":1},"1":{"v":"\n# component\n\n## edge\n\n- hosts running applications: end system\n- client and server\n- p2p model\n- service: connection-oritented service, connectionless service\n\n## core\n\n- routers, interconnected networks\n\n## business\n\n- Tier 1 ISP: big network company in each country, Internet backbone providers\n    - direct connect with other tier 1\n    - connected to large number of tier-2\n    - international in coverage\n    - do not buy transit from another provider\n    - vertically intergrated: sell services to customers,\n    - no single tier-1 ISP can reach the whole Internet, it only peer with Tier-1\n- Tier 2 ISP:\n    - customers of Tier-1, provider of customers, peers with other tier-2\n    - why buy transit from tier-1 provide:\n        - usually reginal network and have limited resource\n        - need route traffic through Tier-1 ISP to reach a large protion of network\n    - why tie2 peer with each other\n        - exchanging traffic with a peer, reduce money\n        - improve performance\n- open peering policy: peer with anyone possible, costs of peering have to be balanced against gains for a Tier-2 ISP.\n        - management cost: send approx equal amount of traffic to each other\n        - matinentance cost: transmission capacity to meeting point, extra equipment\n- content providers:\n    - do not sell transit\n    - 1. focus on content creation, no peering\n    - 2. large-scale players: open peering policy","n":0.069}}},{"i":283,"$":{"0":{"v":"Applicationlayer","n":1},"1":{"v":"# Application layer\n\nhttp/smtp/dns/voip\n\n![](/assets/images/2021-03-25-16-43-51.png)\n## Goals\n\n- relaiable data transfer\n- high throughput\n- timing guarantees\n\n## http\n\n访问一个网址发生了什么\n\n1. The HTTP client process initiates a TCP connection to the server www.someSchool.edu on port number 80, which is the default port number for HTTP. Associated with the TCP connection, there will be a socket at the client and a socket at the server. 建立tcp\n\n2. The HTTP client sends an HTTP request message to the server via its socket. The request message includes the path name /someDepartment/home.index. (We will discuss HTTP messages in some detail below.) 发送请求\n\n3. The HTTP server process receives the request message via its socket, retrieves the object /someDepartment/home.index from its storage (RAM or disk), encapsulates the object in an HTTP response message, and sends the response message to the client via its socket. 返回请求\n\n4. The HTTP server process tells TCP to close the TCP connection. (But TCP doesn’t actually terminate the connection until it knows for sure that the client has received the response message intact.) 关闭tcp\n\n5. The HTTP client receives the response message. The TCP connection terminates. The message indicates that the encapsulated object is an HTML file. The client extracts the file from the response message, examines the HTML file, and finds references to the 10 JPEG objects. 关闭\n\n6. The first four steps are then repeated for each of the referenced JPEG objects.\n\n![](/assets/images/2021-03-14-19-59-53.png)\n\n\n### message format\n\n- message format:\n  - hypertext transfer protocol\n  - web's appliation layer protocol\n  - client/server model\n  - 2 type: requests from client to server and responses\n  - requests and response\n  - startline:request line (Method SP Request-URI SP HTTP-Version CRLF) | status line\n    - GET /index HTTP/1.1\n    - HTTP/1.1 200 OK\n  - zero or more headers: provide metadata about request or response:datas/times, application info,caching control,**host** must on requests\n  - an empty line\n  - message body\n  - request methods:\n  - GET: retrieve an object: conditional GET/ Partial GET\n  - HEAD: retrieve metadata about object\n  - OPTIONS: request info about the capabilities\n  - POST: upload data to server\n  - status code\n  - 1XX informational\n  - 2XX success\n  - 3XX redirection\n  - 4XX client error\n  - 5XX server error\n  - each request only retrieve one object\n\n### persistent http\n\n- persistent http\n  - reuse existing transport connection,subsequent http message between same client/server sent over open connection\n  - pipelining at application protocol level\n  - without pipeline: one RTT for each referenced object **RTT+transmission time(one object)**\n  - use pipeline: one RTT for all referenced objects\n  - reduce transport-layer connection cost\n  - reduce latency by avoid mulitple TCP slow-starts\n  - avoid bandwidth wastage and reduce all congestion\n\n### cookie\n\n![](/assets/images/2021-03-14-20-03-12.png)\n\n## DNS\n\n- mission: A directory service for the Internet\n- domain namespace: hierarchical structure\n  - type of dns ns: root/top-level domain/ authoritative/ local\n \n![](/assets/images/2021-03-14-20-07-56.png)\n\n- root server's job:\n    - what www.library.cmu.edu: go to ns for .edu\n    - know top-level domain 2.3M \n- tld ns' job: ask cmu.edu ns\n- authoritative ns: provide authoritative hostname to ip \n- local ns: resolver: act as proxy\n\n\n- Load distribution across replicated servers\n  - A name can map to multiple hosts \n  - thus multiple addresses\n  - DNS server returns all addresses \n  - but rotates ordering\n\n-  Simple query and reply mechanism, same message format, Resource Record\n-  Runs over UDP \n- * DNS did not need tcp retransmission when lost,try another ns\n  - tcp take long set-up time, query and request time need to be short\n- data used as Resource Record (RR) in query and reply messages:\n  - name(owner name), value, type, class (IN,internet), ttl\n  - A = Address \n  - ns = nameserver\n  - cname = canonical name\n  - mx = mail exchange\n- caching: once ns learns mapping, it caches mapping, timeout after ttl\n\n### tool\n\n- nslookup \n- dig\n- whois\n\n","n":0.041}}},{"i":284,"$":{"0":{"v":"Mlops","n":1}}},{"i":285,"$":{"0":{"v":"Data","n":1}}},{"i":286,"$":{"0":{"v":"Sampling","n":1},"1":{"v":"\n## 如何创建训练数据\n\n### 选择训练数据的抽样方法\n\n由于无法获取所有真实世界的数据，我们需要从中抽取一部分进行训练。关键在于如何实现有效的抽样。抽样方法大致分为两类：非概率抽样和随机抽样。\n\n#### 非概率抽样方法\n\n1. **便利抽样**（Convenience Sampling）  \n   主要基于数据的可获取性。\n\n2. **雪球抽样**（Snowball Sampling）  \n   以已有的样本为基础，逐渐扩大样本范围，类似于深度优先搜索（DFS）算法。\n\n3. **判断抽样**（Judgmental Sampling）  \n   由专家根据经验决定抽样方法。\n\n4. **配额抽样**（Quota Sampling）  \n   在每个类别中选择固定数量的样本进行调查。\n\n#### 随机抽样方法\n\n1. **简单随机抽样**  \n   随机选择数据的一个子集，例如随机选取10%的数据。\n\n2. **分层抽样**（Stratified Sampling）  \n   从不同的类别（如A和B）中各选取一定比例，如1%，以确保包含这些类别的数据。\n\n3. **加权抽样**（Weighted Sampling）  \n   对每个样本赋予不同的权重，代表其被抽中的可能性。\n\n4. **保留抽样**（Reservoir Sampling）  \n   适用于流数据。初始选择K个元素，对于新到的第N个元素，生成1到N之间的随机数。如果这个数在1到K之间，用第N个元素替换对应位置的元素。\n\n5. **重要性抽样**（Importance Sampling）  \n   当从一个分布P抽样成本很高时，可以使用一个替代的分布Q进行抽样，然后根据权重调整样本。\n\n","n":0.158}}},{"i":287,"$":{"0":{"v":"Labeling","n":1},"1":{"v":"\n\n## 数据标注方法\n\n### 手工标注\n\n- **隐私问题**：可能导致数据暴露给标注人员。\n- **效率问题**：这种方法通常比较慢。\n- **一致性问题**：来自不同数据源的标注可能会发生冲突，尤其当标注人员不一致时。\n- **专业知识差异**：需要高级专业知识时，标注的差异性更加明显。\n\n**解决方法**：明确定义问题，对标注者进行专业培训，确保标注的准确性和一致性。\n\n### 自然标注法\n\n- **利用现有数据**：例如，股票市场和推荐系统中，可以通过用户反馈来获得标注。\n- **猜测方法**：如果没有直接的标注，可以编写函数生成标注，利用数据库，或者应用半监督学习方法，使用少量的初始标注来推测其他标注。\n- **主动学习**：从模型获得结果，然后基于这些结果进行学习和生成标注。\n\n","n":0.302}}},{"i":288,"$":{"0":{"v":"Data_transformation","n":1},"1":{"v":"\n\n## 通过数据变体和增强生成更多训练数据\n\n### 图像数据增强\n\n- **分割和转换**：对图像进行分割和各种转换（如旋转、缩放等），生成视觉上不同但标签相同的图像变体。\n- **添加噪声**：在图像中添加噪声，增加训练数据的多样性。\n\n### 文本数据处理\n\n- **模板添加**：在文本数据中添加模板或结构，使得内容在结构上变长，但信息保持不变。这不仅增加了数据的多样性，还有助于解决隐私问题。\n\n### 综合方法\n\n- **数据整合**：整合不同的数据源，创建更丰富的训练集。\n- **使用生成对抗网络（GAN）**：利用GAN生成新的训练样本，进一步增强数据多样性。\n\n","n":0.316}}},{"i":289,"$":{"0":{"v":"Class_imbalance","n":1},"1":{"v":"\n\n## 类别不平衡问题及解决方法\n\n### 问题描述\n\n- **检测困难**：当某一类别数据较少时，模型难以检测到这个小众类别。\n- **倾向于多数类别**：模型倾向于将样本标注为数量较多的类别。\n- **错误估计增加**：由于类别不平衡，可能导致更高的错误估计。\n\n### 解决策略\n\n#### 选择正确的指标\n\n- **准确度**：真正例 / (真正例 + 假正例) Precision\n- **召回率**：真正例 / (真正例 + 假反例) Recall\n- **ROC曲线**：用于二元分类，通过准确度和召回率判断模型效果。\n\n#### 数据层面的处理\n\n- **过采样**：复制少数类别的数据，使得数据更平衡。适用于少数类别数据较少的情况。\n\n#### 算法层面的调整\n\n- **loss Function**：在损失函数中对不同类别的结果赋予不同的权重，实现类别平衡损失。\n- **类别分布的调整**：针对每个类别做适当的概率分布调整。\n","n":0.192}}},{"i":290,"$":{"0":{"v":"Feature","n":1},"1":{"v":"\n\n# 特征工程学习笔记\n\n## 概述\n特征工程需要对领域有一定的专业知识。了解领域后，能够识别出对模型有帮助的特征。\n\n## 基本操作\n\n### 1. 处理缺失数据\n- **确认缺失类型**：判断数据是随机缺失还是故意缺失，两者的处理方式不同。\n- **处理方法**：\n  - **随机缺失**：\n    - 删除缺失值：可选择删除整列或行。删除行可能导致模型偏差，因为数据量减少。\n    - 补全数据：使用默认值，需确保默认值不会与真实数据混淆。\n  - **故意缺失**：需根据情况具体分析处理。\n\n### 2. 尺度缩放\n- 目的：将不同范围的数据缩放到统一范围。\n- 方法：\n  - 数据归一化：数据减去最小值后除以最大值与最小值之差。\n  - 标准化：数据减去平均值后除以标准差，使数据落在0-1范围内。\n  - 对数变换：处理有偏数据，使其趋向正态分布。\n\n### 3. 离散化处理\n- 将连续数据离散成不同类别，便于建模，因不同类别可能更易于处理。\n\n### 4. 处理分类数据\n- 问题：实际中可能出现新类别，导致无法准确分类。\n- 解决方法：\n  - 哈希函数：固定空间大小，虽可能发生哈希冲突，但影响不大。\n  - 特征交叉：将两个特征拼接，形成新特征，在线性回归和逻辑回归中效果好。\n  - 位置分布的嵌入：结合位置信息。具体做法是将位置向量和词汇向量相加，得到含位置信息的新向量。\n","n":0.16}}},{"i":291,"$":{"0":{"v":"Data_leakage","n":1},"1":{"v":"# 数据泄漏问题\n\n数据泄漏是指在训练数据中不慎泄露了与测试数据相关的规律，可能导致模型过拟合，无法准确反映实际情况。\n\n## 常见原因\n\n1. **时间相关数据的随机分割**：\n   - 应按时间顺序分割数据，以捕捉每天的规律。\n   - 随机分割可能导致测试结果可预测。\n\n2. **在数据分割前进行尺度缩放**：\n   - 这可能导致整体数据的平均值和标准差泄露到训练集。\n\n3. **使用所有数据的统计值补齐数据**：\n   - 这也会导致数据泄漏。\n\n4. **未正确处理数据的重复性**：\n   - 分割时可能导致数据集中大量重复，尤其是当数据高度相关但被分割到不同组时。\n\n## 检测方法\n\n- **关注特征的重要性**：\n  - 如果某特征非常重要，可能存在数据泄漏。\n  - 特征重要性显示每个特征对模型性能的影响。\n\n- **检查特征覆盖率**：\n  - 观察特征在所有数据中的占比。\n","n":0.196}}},{"i":292,"$":{"0":{"v":"Ml","n":1}}},{"i":293,"$":{"0":{"v":"Feature","n":1},"1":{"v":"\n# F3\n\n![](/assets/images/2021-06-08-14-43-00.png)\n\n![](/assets/images/2021-06-08-14-43-18.png)\n\n![](/assets/images/2021-06-08-14-44-28.png)\n\n![](/assets/images/2021-06-08-14-45-22.png)\n\n![](/assets/images/2021-06-08-14-46-19.png)\n\n![](/assets/images/2021-06-08-14-47-56.png)\n\n","n":0.707}}},{"i":294,"$":{"0":{"v":"Automl","n":1},"1":{"v":"\n\n# automl pipeline\n\n- update tagged picture\n- gcp auto ml to auto classify\n- continuous train when having more data\n\n\n\n# No code/ low code\n\n- apple\n  - Create ML\n  - at least 10 pictures pre category\n- GCP\n  - vision automl\n  - text\n  - number prediction\n- aws\n  - comprehend\n- azure\n  - ml studio\n- ludwig automl","n":0.14}}},{"i":295,"$":{"0":{"v":"Bp","n":1},"1":{"v":"\n# blueprint\n\nAds ranking model development can be represented by an execution graph. Blueprint is a solution to describe and execute such an execution graph.\n\n![](/assets/images/2021-06-25-08-02-43.png)\n\n![](/assets/images/2021-08-18-13-35-10.png)\n\n![](/assets/images/2021-08-18-13-35-55.png)\n\n![](/assets/images/2021-08-18-13-38-43.png)\n\ngoal\n\n![](/assets/images/2021-08-18-13-40-31.png)\n\n\n## IR\n\nExecution graph is represented by a data structure which we call “Intermediate Representation” or IR. IR is in JSON format.\n\n## Module\n\nWhen implementing the function execute in GMBModule, we write normal Python code, which describes what execute does.\n\n```\nclass GMBModule(BaseModule):\n    @gmb_executor_method()\n    def execute(params=...):\n        process(params)\n```\n\n- When execution_mode = IR_GENERATION: calling execute(params=...) generates an IR which encodes the fact that the function execute will be called with params remotely later.\n- When execution_mode = IR_EXECUTION: calling execute(params=...) executes process(params)\n\n### edge between module\n\n```\nmodule_a = GMBModule()\nmodule_b = GMBModule2()\nmodule_a.execute()\nmodule_b.set_params(params=module_a.get_result())\nmodule_b.execute()\nresult = module_b.get_result()\n```\n## core\n\n![](/assets/images/2021-08-18-13-53-29.png)\n\n## BPS\n\n![](/assets/images/2021-08-18-13-52-15.png)\n\n\n![](/assets/images/2021-08-18-13-57-03.png)\n\n## AIR\n\n![](/assets/images/2021-08-18-14-02-44.png)","n":0.095}}},{"i":296,"$":{"0":{"v":"LLM","n":1},"1":{"v":"\n大语言模型是一种基于深度学习技术的自然语言处理模型，它能够学习和生成自然语言文本。大语言模型通常由多层神经网络组成，可以根据历史文本数据预测下一个单词或一段文本的概率。大语言模型的应用包括语言翻译、问答系统、自动摘要、语音识别等领域。其中最著名的大语言模型是Google的BERT、OpenAI的GPT-3等。大语言模型的优点是可以在大规模数据上进行训练，支持生成高质量的自然语言文本，但是也存在一些问题，比如需要大量的计算资源和数据、对于少见的单词或短语容易出现错误等。","n":1}}},{"i":297,"$":{"0":{"v":"transformer","n":1},"1":{"v":"\n[Attention Is All You Need paper](https://arxiv.org/pdf/1706.03762.pdf)\n\n![](/assets/images/2023-03-08-21-02-14.png)\n\n## attention node\n\n![](/assets/images/2023-03-08-21-07-48.png)\n![](/assets/images/2023-03-08-21-09-26.png)\n\n\n```\nclass CausalSelfAttention(nn.Module):\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # regularization\n        self.attn_dropout = nn.Dropout(config.dropout)\n        self.resid_dropout = nn.Dropout(config.dropout)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                    .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        # 除方差\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        # 只取下半部分，我们只能看到之前的内容\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        att = self.attn_dropout(att)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.resid_dropout(self.c_proj(y))\n        return y\n```\n\n$Attention(Q, K, V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})V$\n\n## add & norm\n\n```\nclass Block(nn.Module):\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = MLP(config)\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlp(self.ln_2(x))\n        return x\n```\n\n## feed forward\n\n$FFN(x) = max(0, xW_1 + b_1)W_2 + b_2$\n\n```\ndef fused_gelu(x):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass MLP(nn.Module):\n\n    def __init__(self, config):\n        super().__init__()\n        self.c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd)\n        self.c_proj  = nn.Linear(4 * config.n_embd, config.n_embd)\n        self.dropout = nn.Dropout(config.dropout)\n\n    def forward(self, x):\n        x = self.c_fc(x)\n        x = fused_gelu(x)\n        x = self.c_proj(x)\n        x = self.dropout(x)\n        return x\n```\n\n# All\n\n[link](https://github.com/karpathy/nanoGPT/blob/fe8042867ca499aef1df0d6c2606aabae3124b26/model.py)\n```\nclass GPT(nn.Module):\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            drop = nn.Dropout(config.dropout),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = self.transformer.drop(tok_emb + pos_emb)\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # sample from the distribution\n            idx_next = torch.multinomial(probs, num_samples=1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return \n```","n":0.036}}},{"i":298,"$":{"0":{"v":"tool","n":1},"1":{"v":"\n# MRKL\n\nMRKL（Karpas 等人，2022 年）是 \"模块化推理、知识和语言 \"的简称，是一种用于自主代理的神经符号架构。建议 MRKL 系统包含一系列 \"专家 \"模块，而通用 LLM 则作为路由器，将查询路由到最合适的专家模块。这些模块可以是神经模块（如深度学习模型），也可以是符号模块（如数学计算器、货币转换器、天气 API）。\n\n# HuggingGPT\n\n![](/assets/images/2023-09-21-22-49-51.png)\n\n该系统包括 4 个阶段：\n\n(1) 任务规划： LLM 充当大脑，将用户请求解析为多个任务。每个任务都有四个相关属性：任务类型、ID、依赖关系和参数。他们使用少量实例来指导 LLM 进行任务解析和规划。\n\n指令：\n\n> 人工智能助手可以将用户输入解析为多个任务： {\"task\"：任务，\"id\"：task_id，\"dep\"：依赖关系_task_ids，\"args\"：参数： {\"text\": 文本，\"image\"： URL, \"audio\"： URL, \"video\"： URL}}]。dep \"字段表示生成当前任务所依赖的新资源的前一个任务的 id。特殊标记\"-task_id \"指的是依赖任务中生成的文本图像、音频和视频，id 为 task_id。必须从以下选项中选择任务： {{可用任务列表 }}}。任务之间存在逻辑关系，请注意它们的顺序。如果无法解析用户输入，则需要回复空 JSON。以下是几个案例供您参考： {{ 演示 }}。聊天记录记录为 {{ 聊天记录 }}。从该聊天历史记录中，您可以找到用户提及的资源路径，以便进行任务规划。\n\n(2) 模型选择： LLM 会将任务分配给专家模型，其中的请求是一道多选题。LLM 会收到一份可供选择的模型列表。由于上下文长度有限，需要进行基于任务类型的过滤。\n\n指令：\n\n> 给定用户请求和调用命令后，人工智能助手会帮助用户从模型列表中选择一个合适的模型来处理用户请求。人工智能助手仅输出最合适模型的模型 ID。输出必须采用严格的 JSON 格式： \"id\"： \"id\", \"reason\"： \"您选择的详细原因\"。我们有一个模型列表供您选择 {{ 候选模型 }}。请从列表中选择一个模型。\n\n(3) 任务执行： 专家模型执行特定任务并记录结果。\n\n指示：\n\n> 有了输入和推理结果，人工智能助手需要描述过程和结果。前几个阶段可归纳为--用户输入： {{ 用户输入 }}、任务规划： {{ 任务 }}, 模型选择： {{ 模型分配 }}, 任务执行： {{ 预测 }}。首先，您必须直截了当地回答用户的请求。然后以第一人称向用户描述任务过程并展示您的分析和模型推理结果。如果推理结果包含文件路径，必须告诉用户完整的文件路径。\n\n(4) 生成响应： LLM 接收执行结果并向用户提供汇总结果。\n\n要将 HuggingGPT 投入实际应用，需要解决几个难题：（1）需要提高效率，因为 LLM 推理轮和与其他模型的交互都会减慢进程；（2）它依赖于较长的上下文窗口来交流复杂的任务内容；（3）提高 LLM 输出和外部模型服务的稳定性。\n\n","n":0.108}}},{"i":299,"$":{"0":{"v":"memory","n":1},"1":{"v":"\n# Memory\n\n感官记忆： 这是记忆的最早阶段，能够在原始刺激结束后保留对感官信息（视觉、听觉等）的印象。感官记忆通常只能持续几秒钟。其子类别包括图标记忆（视觉）、回声记忆（听觉）和触觉记忆（触觉）。\n\n短时记忆（STM）或工作记忆： 它存储我们当前意识到的信息，以及执行学习和推理等复杂认知任务所需的信息。据信，短时记忆的容量约为 7 个项目（米勒，1956 年），持续时间为 20-30 秒。\n\n长时记忆（LTM）： 长时记忆可以将信息存储很长时间，从几天到几十年不等，存储容量基本上是无限的。长时记忆有两种亚型：\n\n显性/陈述性记忆： 这是对事实和事件的记忆，指那些可以有意识地回忆起的记忆，包括外显记忆（事件和经历）和语义记忆（事实和概念）。\n内隐/程序性记忆： 这类记忆是无意识的，涉及自动执行的技能和例行程序，如骑车或在键盘上打字。\n\n![](/assets/images/2023-09-21-22-47-03.png)\n\n## Maximum Inner Product Search (MIPS)\n\n- LSH（位置敏感散列）： 它引入了一种散列函数，使相似的输入项以高概率映射到相同的桶中，其中桶的数量远远小于输入项的数量。\n- ANNOY（Approximate Nearest Neighbors Oh Yeah）： 其核心数据结构是随机投影树，这是一组二叉树，其中每个非叶节点代表一个超平面，将输入空间分成两半，每个叶节点存储一个数据点。树是独立随机建立的，因此在某种程度上，它模仿了哈希函数。ANNOY 搜索会在所有树中反复搜索最接近查询的那一半，然后汇总结果。这个想法与 KD 树很相似，但扩展性更强。\n- HNSW（层次导航小世界）： 它受到小世界网络理念的启发，在小世界网络中，任何其他节点都可以在少量步骤内到达大多数节点；例如，社交网络的 \"六度分隔 \"特征。HNSW 为这些小世界图建立了分层，其中底层包含实际数据点。中间层则创建快捷方式，以加快搜索速度。在执行搜索时，HNSW 从顶层的随机节点开始，向目标导航。当它无法再靠近目标时，就会向下移动到下一层，直到到达底层。在上层的每次移动都有可能覆盖数据空间中的较大距离，而在下层的每次移动都会提高搜索质量。\n- FAISS（Facebook 人工智能相似性搜索）： 它的运行假设是，在高维空间中，节点之间的距离遵循高斯分布，因此数据点应该存在聚类。FAISS 通过将向量空间划分为簇来应用向量量化，然后在簇内细化量化。搜索时，首先用粗量化寻找候选簇，然后用更精细的量化进一步搜索每个簇。\n- ScaNN（可扩展的最近邻域）： ScaNN 的主要创新是各向异性向量量化。\n\n\n![](/assets/images/2023-09-21-22-47-58.png)\n\nhttps://ann-benchmarks.com/","n":0.156}}},{"i":300,"$":{"0":{"v":"machine_memory","n":1},"1":{"v":"\n1. 模型加载：将模型参数移动到GPU，当前内存使用量为模型的大小。\n\n2. 前向传播：输入通过模型并存储中间输出（激活）。存储这些激活占用了记忆体。\n\n3. 反向传播：计算从网络末端到开始的梯度，并在进行时丢弃前向激活，因为我们有了一致的出价，当前内存使用量为模型加梯度的大小。\n\n4. 优化器步骤：更新参数并保留运行中的梯度估计，如一阶和二阶动量。这将占用模型大小的两倍内存对于使用动量的Adam优化器，对于使用一个动量的RMSprop，以及对于不使用动量的SGD，占用等同于模型大小的内存。\n\n5. 后续迭代：梯度计算后，优化器采取了一步，梯度和梯度动量仍然存在。所以你在未来迭代中的最大内存使用量将是模型+激活+梯度+梯度动量。\n\nmodel+activation+gradient+gradient momentum\n\n\n计算\n\nmax memory consumption = m+ f * batch_size * b + d * g + o * m\n\n\nm 是模型占用的内存。\n\nf 是单个数据样本前向传递所消耗的内存。\nbatch_size 是批量大小。\n\nb 是训练过程中使用的精度因子（如果使用混合精度训练，则为0.5；如果使用全精度训练，则为1）。\n\nd 是分布式训练的因子（如果在一个GPU上训练，则为1；如果在多个GPU上训练，则为2）。\n\ng 是梯度占用的内存。\n\no 是优化器存储的动量的数量（通常是0、1或2，取决于是否使用动量以及使用的动量类型）。\n\n# trick\n\n1. with torch.no_grad(): \n   1. 用于减少内存使用量，因为它不会跟踪梯度。","n":0.164}}},{"i":301,"$":{"0":{"v":"llama","n":1}}},{"i":302,"$":{"0":{"v":"quantize","n":1}}},{"i":303,"$":{"0":{"v":"qlora","n":1}}},{"i":304,"$":{"0":{"v":"new_gpu","n":1},"1":{"v":"\n1. install conda\n2. install dependencies\n3. git clone repo\n4. install dependencies\n5. download model\n6. run model \n7. train lora","n":0.243}}},{"i":305,"$":{"0":{"v":"huggingface","n":1},"1":{"v":"\n```\n#@title ## 8.1. Upload Config\nfrom huggingface_hub import login\nfrom huggingface_hub import HfApi\nfrom huggingface_hub.utils import validate_repo_id, HfHubHTTPError\n\n#@markdown Login to Huggingface Hub \n#@markdown > Get **your** huggingface `WRITE` token [here](https://huggingface.co/settings/tokens)\nwrite_token = \"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\" #@param {type:\"string\"}\nlogin(write_token, add_to_git_credential=True)\n\napi = HfApi()\nuser = api.whoami(write_token)\n\n#@markdown Fill this if you want to upload to your organization, or just leave it empty.\n\norgs_name = \"\" #@param{type:\"string\"}\n\n#@markdown If your model/dataset repo didn't exist, it will automatically create your repo.\nmodel_name = \"cczhong/chinese-alpaca-plus-lora-7b-merged-ggml-4b\" #@param{type:\"string\"}\n#dataset_name = \"your-dataset-name\" #@param{type:\"string\"}\nmake_this_model_private = False #@param{type:\"boolean\"}\nmodel_repo=model_name\n\nif model_name:\n  try:\n      validate_repo_id(model_repo)\n      api.create_repo(repo_id=model_repo, \n                      private=make_this_model_private)\n      print(\"Model Repo didn't exists, creating repo\")\n      print(\"Model Repo: \",model_repo,\"created!\\n\")\n\n  except HfHubHTTPError as e:\n      print(f\"Model Repo: {model_repo} exists, skipping create repo\\n\")\n\n\nfrom huggingface_hub import HfApi\nfrom pathlib import Path\n%store -r\n\napi = HfApi()\ncommit_message = \"add new model\" #@param {type :\"string\"}\nmodel_path = \"/home/ubuntu/llama.cpp/zh-models/alpaca-combined\"\nif not commit_message:\n  commit_message = \"feat: upload \"+project_name+\" lora model\"\npath_in_repo = None\ndef upload_model(model_paths, is_folder :bool, is_config :bool):\n  path_obj = Path(model_paths)\n  trained_model = path_obj.parts[-1]\n  \n  if path_in_repo:\n    trained_model = path_in_repo\n  \n  if is_config:\n    trained_model = f\"{project_name}_config\"\n\n  if is_folder:\n    print(f\"Uploading {trained_model} to https://huggingface.co/\"+model_repo)\n    print(f\"Please wait...\")\n    \n    api.upload_folder(\n        folder_path=model_paths,\n        path_in_repo=trained_model,\n        repo_id=model_repo,\n        commit_message=commit_message,\n        ignore_patterns=\".ipynb_checkpoints\"\n        )\n    print(f\"Upload success, located at https://huggingface.co/\"+model_repo+\"/tree/main\\n\")\n  else: \n    print(f\"Uploading {trained_model} to https://huggingface.co/\"+model_repo)\n    print(f\"Please wait...\")\n            \n    api.upload_file(\n        path_or_fileobj=model_paths,\n        path_in_repo=trained_model,\n        repo_id=model_repo,\n        commit_message=commit_message,\n        )\n        \n    print(f\"Upload success, located at https://huggingface.co/\"+model_repo+\"/blob/main/\"+trained_model+\"\\n\")\n      \ndef upload():\n    if model_path.endswith((\".ckpt\", \".safetensors\", \".pt\")):\n      upload_model(model_path, False, False)\n    else:\n      upload_model(model_path, True, False)\n\n    #if config_path:\n    #  upload_model(config_path, True, True)\n\nupload()\n```","n":0.068}}},{"i":306,"$":{"0":{"v":"instructGPT","n":1},"1":{"v":"\n# instructGPT\n\n[InstructGPT](https://arxiv.org/pdf/2203.02155)\n\n## step 1\n\n- collect data and write some prompt and result\n- fine tune GPT3\n\n\n## step 2\n\n- labeler rank LLM result\n- train a reward model\n\n\n![](/assets/images/2023-03-08-21-23-51.png)\n\n\n## step 3\n\n- optimize reward model with reinforcement learning\n\n![](/assets/images/2023-03-08-21-24-29.png)","n":0.174}}},{"i":307,"$":{"0":{"v":"agent","n":1},"1":{"v":"\n![](/assets/images/2023-09-21-22-34-13.png)\n\nIn a LLM-powered autonomous agent system, LLM functions as the agent’s brain, complemented by several key components:\n\n# Planning\n\nSubgoal and decomposition: The agent breaks down large tasks into smaller, manageable subgoals, enabling efficient handling of complex tasks.\nReflection and refinement: The agent can do self-criticism and self-reflection over past actions, learn from mistakes and refine them for future steps, thereby improving the quality of final results.\n\n[[development.ml.LLM.agent.planning]]\n[[development.ml.LLM.agent.self_reflection]]\n\n# Memory\n\nShort-term memory: I would consider all the in-context learning (See Prompt Engineering) as utilizing short-term memory of the model to learn.\nLong-term memory: This provides the agent with the capability to retain and recall (infinite) information over extended periods, often by leveraging an external vector store and fast retrieval.\n\n[[development.ml.LLM.agent.memory]]\n\n# Tool use\n\nThe agent learns to call external APIs for extra information that is missing from the model weights (often hard to change after pre-training), including current information, code execution capability, access to proprietary information sources and more.\n\n\n[[development.ml.LLM.agent.tool]]\n\n[reference](https://lilianweng.github.io/posts/2023-06-23-agent/)","n":0.082}}},{"i":308,"$":{"0":{"v":"self_reflectio","n":1},"1":{"v":"\n# ReAct\n\n通过将行动空间扩展为特定任务离散行动和语言空间的组合，在 LLM 中整合了推理和行动。前者使 LLM 能够与环境互动（例如使用维基百科搜索 API），而后者则促使 LLM 以自然语言生成推理痕迹。\n\nThe ReAct prompt template incorporates explicit steps for LLM to think, roughly formatted as:\n\nThought: ...\nAction: ...\nObservation: ...\n... (Repeated many times)\n\n# Reflexion\n\n![](/assets/images/2023-09-21-22-37-31.png)\n\n自我反思是通过向 LLM 展示two shot示例来创建的，每个示例都是一对（失败的轨迹、用于指导未来计划变更的理想反思）。然后将反思添加到代理的工作记忆中，最多可添加三个，作为查询 LLM 的上下文。","n":0.171}}},{"i":309,"$":{"0":{"v":"planning","n":1},"1":{"v":"\n# Chain of thought \n\n模型被要求 \"一步一步地思考\"，以利用更多的测试时间计算，将艰巨的任务分解为更小更简单的步骤。CoT 将大任务转化为多个可管理的任务，并对模型的思维过程进行解释。\n\n# Tree of thought\n\n通过在每一步探索多种推理可能性，对 CoT 进行了扩展。它首先将问题分解为多个思考步骤，并在每个步骤中生成多个思考，从而创建一个树状结构。","n":0.289}}},{"i":310,"$":{"0":{"v":"Database","n":1}}},{"i":311,"$":{"0":{"v":"Zippydb","n":1},"1":{"v":"\n# zippydb\n\nfb internal distributed key-value databse\n\nsingle node based on rockdb\n\n## arch\n\nZippyDB servers can be mapped to the roles in the Multi-Paxos protocol as follows:\n\nPrimary server = proposer/leader + acceptor + learner\nSecondary server = acceptor + learner\nFollower server = learner (An ordinary ZippyDB user may safely skip the details of the mapping above, as it is only intended to map terminology for readers who are familiar with Paxos.)\n\n## write \n\n![](/assets/images/2021-04-05-17-12-35.png)\n\n## read\n\n![](/assets/images/2021-04-05-17-13-08.png)\n\n## primary failover\n\nWhen the primary fails, Zeus detects the failure through lost heartbeats and notifies ShardManager. ShardManager chooses a most appropriate secondary and sends it a message to convert it into a new primary. \n\nSpecifically in this example, it is possible that, right before server X crashed, server X and server Y worked together to accept a write and server X has already sent the \"write-success\" response back to the client, but that write has not yet reached server Z. This is because server X and server Y form a majority and hence can accept a write without waiting for the \"accepted\" confirmation from server Z. Actually, server Z may never get the \"accept\" notification for this write from server X before server X crashed, e.g., due to slow network between server X and server Z. In this case, after server Z becomes the new primary, it needs to contact server Y to recover the missing write. The prepare phase of the Paxos protocol guarantees that the new primary will correctly discover all those missing writes, so long as only a minority of the replicas have failed.\nAfter bringing its local replica up-to-date, the new primary (server Z in this example) starts to handle reads and writes as normal. As shown in the figure below, the write path executes the following steps in sequence:\n\n1. When the client wants to send a new \"Put()\" request, the ServiceRouter library linked into the client notices that ShardManager has changed the shard's primary assignment, and automatically routes the request to the new primary (server Z).\n2. Server Z asks both server X and server Y to \"accept\" the write.\n3. Server Z gets the \"accepted\" confirmation from server Y, but gets no confirmation from server X.\n4. Since server Z collects a majority votes for the write (one from itself and another from server Y), server Z decides to commit the write and sends a \"write-success\" response back to the client. Server Z does not wait for server X to recover in order to accept the write. In other words, once server Z becomes the new primary, the failure of server X does not affect the database's availability .\n5. Server Z sends a \"commit\" message to server Y to inform server Y that an agreement has been reached on the write. This step is not shown in the figure for brevity.\n\n![](/assets/images/2021-04-05-17-15-33.png)\n\nThe process of primary fail-over takes about 10 seconds, including the time for Zeus to detect lost heartbeats from the old primary\n\n## A Failed Replica Rejoins\n\nServer X synchronizes with the new primary (server Z) to bring its local database up-to-date. It then starts to process protocol messages as normal. See the example in the figure below.\n\n![](/assets/images/2021-04-05-17-16-52.png)\n\n## Sharding and Load Balancing\n\nIn practice, each server runs a single ZippyDB process that can host multiple shards. In the figure below, each server hosts three shards: a primary for one shard, and two secondaries for two other shards. For example, server 1 hosts shard A's primary, shard D's secondary, and shard E's secondary. The three replicas of shard A are distributed across server 1 (primary), server 2 (secondary), and server 5 (secondary). ShardManager considers multiple factors in shard placement. In this figure, ShardManager places exactly one primary on each server for the purpose of load balancing, because a primary incurs a higher load than a secondary does. ShardManager may also place the different replicas of a shard across different clusters for the purpose of better fault tolerance.\n\n\n![](/assets/images/2021-04-05-17-18-35.png)\n\n## Asynchronous Replication Overview\n\n![](/assets/images/2021-04-05-17-22-52.png)\n\n![](/assets/images/2021-04-05-17-23-23.png)","n":0.039}}},{"i":312,"$":{"0":{"v":"Transaction","n":1},"1":{"v":"\n# Transaction\n\nTransaction is the **execution of a sequence of one or more operations** on a shared database to perform some higher level function. They are the basic unit of change in DBMS! It is a sequence of read and write operations. \n\nThe outcome of a transaction is either COMMIT or ABORT. If commit, all the transaction's modifications are saved to the database. If abort,  all the changes are undone so that this transaction is never happened. \n\n一种操作要么全部步骤成功，要不都失败.其中就有commit point的概念，在这之前是可以undo操作的，之后不行","n":0.113}}},{"i":313,"$":{"0":{"v":"Sql","n":1},"1":{"v":"\n# SQL Relational Model\n\nA relational database defines relationships in the form of tables.\n\n- data is organized into relations (called tables in SQL), where each relation is an unordered collection of tuples\n\nSQL programming can be effectively used to insert, search, update, delete database records.\n\n- vertically scalable: adding more power (CPU, RAM) to an existing machine.\n\n![](/assets/images/2021-03-23-23-04-33.png)\n\n- [[MySQL|development.database.sql.mysql]]\n\n## good \n\nmany-to-one, use id\n\nThe advantage of using an ID is that because it has no meaning to humans, it never needs to change: the ID can remain the same, even if the information it identifies changes. Anything that is meaningful to humans may need to change sometime in the future—and if that information is duplicated, all the redundant copies need to be updated. That incurs write overheads, and risks inconsistencies (where some copies of the information are updated but others aren’t). Removing such duplication is the key idea behind normalization in databases.\n## Problem\n\nMost application development today is done in object-oriented programming lan‐guages, which leads to a common criticism of the SQL data model: if data is stored in relational tables, an awkward translation layer is required between the objects in the application code and the database model of tables, rows, and columns. The discon‐nect between the models is sometimes called an impedance mismatch.\n\nIf you want to fetch a profile in the relational example, you need to either perform multiple queries (query each table by user_id) or perform a messy multiway join between the users table and its subordinate tables.","n":0.064}}},{"i":314,"$":{"0":{"v":"Replication","n":1},"1":{"v":"\n# leaders and followers\n\nEvery write to the database needs to be processed by every replica; otherwise, the rep‐licas would no longer contain the same data. The most common solution for this is called leader-based replication\n\n![](/assets/images/2021-05-11-21-10-46.png)\n\nAn important detail of a replicated system is whether the replication happens syn‐chronously or asynchronous\n\n![](/assets/images/2021-05-11-21-12-13.png)\n\nreplication to follower 1 is synchronous: the leader waits until follower 1 has confirmed that it received the write before reporting success to the user, and before making the write visible to other clients. The replication to follower 2 is asynchronous: the leader sends the message, but doesn’t wait for a response from the follower.\n\nThe advantage of synchronous replication is that the follower is guaranteed to have an up-to-date copy of the data that is consistent with the leader. If the leader sud‐denly fails, we can be sure that the data is still available on the follower. The disad‐vantage is that if the synchronous follower doesn’t respond (because it has crashed, or there is a network fault, or for any other reason), the write cannot be processed.\nThe leader must block all writes and wait until the synchronous replica is available again.\n\nIn practice, if you enable syn‐chronous replication on a database, it usually means that one of the followers is syn‐chronous, and the others are asynchronous. If the synchronous follower becomes unavailable or slow, one of the asynchronous followers is made synchronous. This guarantees that you have an up-to-date copy of the data on at least two nodes. This configuration is sometimes also called semi-synchronous.\n\nleader-based replication is configured to be completely asynchronous. In this case, if the leader fails and is not recoverable, any writes that have not yet been repli‐cated to followers are lost. This means that a write is not guaranteed to be durable, even if it has been confirmed to the client. However, a fully asynchronous configura‐tion has the advantage that the leader can continue processing writes, even if all of its followers have fallen behind.\n\n## Setting Up New Followers\n\n- Take a consistent snapshot of the leader’s database at some point in time\n- Copy the snapshot to the new follower node.\n-  The follower connects to the leader and requests all the data changes that have happened since the snapshot was taken\n-  When the follower has processed the backlog of data changes since the snapshot, we say it has caught up. It can now continue to process data changes from the leader as they happen.\n\n## fail-over \n\nfollower\n\nOn its local disk, each follower keeps a log of the data changes it has received from the leader. If a follower crashes and is restarted, or if the network between the leader and the follower is temporarily interrupted, the follower can recover quite easily: from its log, it knows the last transaction that was processed before the fault occurred\n\nleader\n\n- Determining that the leader has failed. There is no foolproof way of detecting what has gone wrong, so most systems simply use a timeout: nodes frequently bounce messages back and forth between each other, and if a node doesn’t respond for some period of tim\n- Choosing a new leader. This could be done through an election process (where the leader is chosen by a majority of the remaining replicas), or a new leader could be appointed by a previously elected controller node. The best candidate for leadership is usually the replica with the most up-to-date data changes from the old leader\n- Reconfiguring the system to use the new leader. Clients now need to send their write requests to the new leader\n\n# Implementation of Replication Logs\n\n## Write-ahead log (WAL) shipping\n\nthe log is an append-only sequence of bytes containing all writes to the database. We can use the exact same log to build a replica on another node: besides writing the log to disk, the leader also sends it across the network to its followers.\n\n. The main disadvantage is that the log describes the data on a very low level: a WAL con‐tains details of which bytes were changed in which disk blocks. This makes replica‐tion closely coupled to the storage engine. If the database changes its storage format from one version to another, it is typically not possible to run different versions of the database software on the leader and the followers.\n\n\n## Logical (row-based) log replication\n\nAn alternative is to use different log formats for replication and for the storage engine, which allows the replication log to be decoupled from the storage engine internals. This kind of replication log is called a logical log, to distinguish it from the storage engine’s (physical) data representation.\n\nA logical log for a relational database is usually a sequence of records describing writes to database tables at the granularity of a row: \n\n• For an inserted row, the log contains the new values of all columns.\n• For a deleted row, the log contains enough information to uniquely identify the row that was deleted. Typically this would be the primary key, but if there is no primary key on the table, the old values of all columns need to be logged.\n• For an updated row, the log contains enough information to uniquely identify the updated row, and the new values of all columns (or at least the new values of all columns that changed)","n":0.034}}},{"i":315,"$":{"0":{"v":"Redis","n":1},"1":{"v":"\n# 介绍\n\nRedis是一个使用ANSI C编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库。\n\n\nRedis支持不同无序、有序的列表，无序、有序的集合间的交集、并集等高级服务器端原子操作。\n\nRedis通常将全部的数据存储在内存中。2.4版本后可配置为使用虚拟内存，一部分数据集存储在硬盘上，但这个特性废弃了。\n\n目前通过两种方式实现持久化：\n\n使用快照，一种半持久耐用模式。不时的将数据集以异步方式从内存以RDB格式写入硬盘。\n1.1版本开始使用更安全的AOF格式替代，一种只能追加的日志类型。将数据集修改操作记录起来。Redis能够在后台对只可追加的记录进行修改，从而避免日志的无限增长。\n\nhttps://zh.wikipedia.org/wiki/Redis","n":0.577}}},{"i":316,"$":{"0":{"v":"Partition","n":1},"1":{"v":"\n- NAÏVE TABLE PARTITIONING: Each node stores one and only table.\n- HORIZONTAL PARTITIONING: Split a table's tuples into disjoint subsets. Choose column(s) that divides the database equally in terms of size, load, or usage. (Hash Partitioning, Range Partitioning)\n\n\n# Partitioning of Key-Value Data\n\nOne way of partitioning is to assign a continuous range of keys (from some mini‐mum to some maximum) to each partition. The partition boundaries might be chosen manually by an administrator, or the data‐base can choose them automatically. Within each partition, we can keep keys in sorted order. This has the advantage that range scans are easy, and you can treat the key as a concatenated index in order to fetch several related records in one query\n\nanother way is to use hash of key to partition, reduce the risk of skew and hot spots. by using the hash of the key for partitioning we lose a nice property of key-range partitioning: the ability to do efficient range queries. Keys that were once adjacent are now scattered across all the partitions, so their sort order is lost\n\n## secondary index\n\n[[Pattern|development.cloud.database.pattern#index table]]\n\nRather than each partition having its own secondary index (a local index), we can construct a global index that covers data in all partitions. The advantage of a global (term-partitioned) index over a document-partitioned index is that it can make reads more efficient: rather than doing scatter/gather over all partitions, a client only needs to make a request to the partition containing the term that it wants.\n\n## rebalancing\n\nsimple solution: create many more partitions than there are nodes, and assign several partitions to each node\n\n![](/assets/images/2021-05-11-20-57-57.png)\n\n## routing\n\n![](/assets/images/2021-05-11-20-59-11.png)","n":0.062}}},{"i":317,"$":{"0":{"v":"Nosql","n":1},"1":{"v":"\n# nosql\n\nNoSQL is a non-relational DMS, that does not require a fixed schema, avoids joins, and is easy to scale. \n\nNoSQL database is used for distributed data stores with humongous data storage needs\n\nNoSQL databases can be document based, key-value pairs, graph databases.\n\n- horizontally scalable (more machines)\n- use dynamic schema for unstructured data.\n\n![](/assets/images/2021-03-23-23-04-33.png)\n\n\nhere are several driving forces behind the adoption of NoSQL databases, including: \n\n- A need for greater **scalability** than relational databases can easily achieve, includ‐ing very large datasets or very high write throughput \n- A widespread preference for free and open source software over commercial database products \n- Specialized query operations that are not well supported by the relational model \n- Frustration with the restrictiveness of relational schemas, and a desire for a **more dynamic and expressive data model**\n\n## bad \n\n- one-to-many structure\n- access hard\n- hard to keep consistent if many-to-many\n- not need join\n\n## good\n\nA document is usually stored as a single continuous string, encoded as JSON, XML, or a binary variant thereof (such as MongoDB’s BSON). If your application often needs to access the entire document (for example, to render it on a web page), there is a performance advantage to this storage locality.\n\nSchema flexibility in the document model\n\n# cassandra\n\nSetting up Cassandra is quite simple and the maintenance is automatically done. The platform is quite fast even when it is scaled up or a node is added. Cassandra also takes care of re-syncing, balancing or distribution of data. The platform is known to provide high velocity random read writes compared to other NoSQL platforms since it has columnar storage capability and distributed decentralized architecture.\n\nFlexible Sparse & Wide Column requirements talk about capability to increase your columns as and when you need. It is suitable only in those cases where secondary index needs are less, which means you have it absolutely de-normalized. In other words all information is available to serve a specific query and does not go across multiple tables to get server specific client query.\n\nIt is important to know that Cassandra is suitable with non-group by kind of models. For applications that have requirement of group-by functionality, Cassandra would not be the right system to choose. This also includes bringing in secondary indexes, which will result into overall performance of system going down.\n\n very high velocity of random read & writes & wide column requirements.\n\n与BigTable和其模仿者HBase不同，Cassandra的数据并不存储在分布式文件系统如GFS或HDFS中，而是直接存于本地。与BigTable一样，Cassandra也是日志型数据库，即把新写入的数据存储在内存的Memtable中并通过磁盘中的CommitLog来做持久化，内存填满后将数据按照key的顺序写进一个只读文件SSTable中，每次读取数据时将所有SSTable和内存中的数据进行查找和合并。这种系统的特点是写入比读取更快，因为写入一条数据是顺序计入commit log中，不需要随机读取磁盘以及搜索。\n\n集群没有master的概念，所有节点都是同样的角色，彻底避免了整个系统的单点问题导致的不稳定性，集群间的状态同步通过Gossip协议来进行P2P的通信。每个节点都把数据存储在本地，每个节点都接受来自客户端的请求。每次客户端随机选择集群中的一个节点来请求数据，对应接受请求的节点将对应的key在一致性哈希的环上定位是哪些节点应该存储这个数据，将请求转发到对应的节点上，并将对应若干节点的查询反馈返回给客户端。\n\n在一致性、可用性和分区耐受能力（CAP）的折衷问题上，Cassandra和Dynamo一样比较灵活。Cassandra的每个keyspace可配置一行数据会写入多少个节点(设这个数为N)，来保证数据不因为机器宕机或磁盘损坏而丢失数据，即保证了CAP中的P。用户在读写数据时可以指定要求成功写到多少个节点才算写入成功(设为W)，以及成功从多少个节点读取到了数据才算成功(设为R)。可推理得出，当W+R>N时，读到的数据一定是上一次写入的，即维护了强一致性，确保了CAP中的C。当W+R<=N时，数据是最终一致性因为存在一段时间可能读到的并不是最新版的数据。当W=N或R=N时，意味着系统只要有一个节点无响应或宕机，就有一部分数据无法成功写或者读，即失去了CAP中的可用性A。因此，大多数系统中，都将N设为3，W和R设为QUORUM，即“过半数”——在N为3时QUORUM是2。\n## partition\n- ring techonology.\n- hash round off\n- hash value used assign key to nodes\n\n## replication\n- rack unware: data at next N-1\n- rack aware: use zookeeper to choose a leader to tell nodes the range they replica for\n- datacenter aware: datacenter level\n\n## gossip protocol\n\n- Periodic, Pairwise, inter-node communication.\n- Random selection of peers.\n- Example – Node A wish to search for pattern in data\n    - Round 1 – Node A searches locally and then gossips with node B. \n    - Round 2 – Node A,B gossips with C and D.\n    - Round 3 – Nodes A,B,C and D gossips with 4 other nodes ......\n- Round by round doubling makes protocol very robust.\n\n## Local Persistence\n\n- Write operations happens in 2 steps\n    - Write to commit log in local disk of the node\n    - Update in-memory data structure.\n- Read operation\n    - Looks up in-memory ds first before looking up files on disk.\n    - Uses Bloom- Filter (summarization of keys in file store in memory) to avoid looking up files that do not contain the key.\n\n# HBase\n\nHBase是Apache Hadoop项目的一个子项目，是Google BigTable的一个克隆，与Cassandra一样，它们都使用了BigTable的列族式的数据模型，但是：\n\nCassandra只有一种节点，而HBase有多种不同角色，除了处理读写请求的region server之外，其架构在一套完整的HDFS分布式文件系统之上，并需要ZooKeeper来同步集群状态，部署上Cassandra更简单。\nCassandra的数据一致性策略是可配置的，可选择是强一致性还是性能更高的最终一致性；而HBase总是强一致性的。\nCassandra通过一致性哈希来决定一行数据存储在哪些节点，靠概率上的平均来实现负载均衡；而HBase每段数据(region)只有一个节点负责处理，由master来动态分配一个region是否大到需要拆分成两个，同时会将过热的节点上的一些region动态的分配给负载较低的节点，因此实现动态的负载均衡。\n因为每个region同时只能有一个节点处理，一旦这个节点无响应，在系统将这个节点的所有region转移到其他节点之前这些数据便无法读写，加上master也只有一个节点，备用master的恢复也需要时间，因此HBase在一定程度上有单点问题；而Cassandra无单点问题。\nCassandra的读写性能优于HBase[17]。","n":0.042}}},{"i":318,"$":{"0":{"v":"Logging","n":1},"1":{"v":"\n\n- **what**:recording events as they occur.\n- **why**: need to use log to restore\n- **how**: combine with checkpoint, periodically checkpoint to save complete state. increment log to maintain updates from that state.\n    - synchronous logging: spend so many time to recovery\n    - asynchronous: log buffered in memory, reduce overhead, but leave log entries vulnerable to loss.\n        - GDV, global dependency vectors\n        - interval is how many messages I got since beginning\n        - if someone vector is bigger than the original one, it means it is inconsistence\n- **problem**: we can use prune log to reduce playback time\n    - it may resend messages that having negative effects on system. Use incarnation numbers to enable recipients to do the same.\n    - expensive in times\n\n\n## checkpoint\n\n\n- **what**: \bused to restore state. \n- **why**:for global consistent copy.\n- **how**: set point, **freezing** the system,no write to maintain consistency. inbound messages will not frozen but write into buffer.\n    - uncoordinated checkpoint: \n        - periodically recorded its state\n        - need recovery line to recover\n    - coordinated checkpoints:\n        - record message sequences: know who sent us message since last checkpoint\n        - synchronized clocks, add timestamp in all messages and act as a sequence number;:\n- **problem**: freeze\n- incarnation number: restarted will +1, use this to distinguish whether I should accept this message.","n":0.069}}},{"i":319,"$":{"0":{"v":"LSM","n":1},"1":{"v":"\n\n## LSM\n\nhttp://www.benstopford.com/2015/02/14/log-structured-merge-trees/\n\n1. idea: collect and batch updates in memory. 放满buffer再写入。\b\b删除的时候\b先放到tombstone里，再删除。\n2. merge 的\b想法：使用bloom filter在query的时候可以知道这个文件会不会在里面。在merge update可以prune tree。在merge的时候删tombstone。\n3. LSMT，memory里的数据结构是C0，disk里的是C1\n    1. fill memory\n    2. spill to disk. use SSTables(连续key value pair) and SSIndexes(key index pair) support random access \n    3. Index and bloom filter in memory\n    4. merge perform comaction\n    5. write-ahead logs to aid recovery\n    6. C0 is smaller and entirely resident in memory, whereas C1 is resident on disk. New records are inserted into the memory-resident C0 component. If the insertion causes the C0 component to exceed a certain size threshold, a contiguous segment of entries is removed from C0 and merged into C1 on disk.\n\nhttp://distributeddatastore.blogspot.com/2013/08/cassandra-sstable-storage-format.html)\n\n\n\n## Bloom Filter\n\n- **what**: one bit per hash function consumed per key. ignore collision. use bit to reprensent exist or not.\n- **why**: secondary storage is slow to search and access\n- **whow**: use k hash function for the item and get k array, set these all in 1 and when we query this item, we will check all k array result","n":0.078}}},{"i":320,"$":{"0":{"v":"Index","n":1},"1":{"v":"\n# index\n\nIn order to efficiently find the value for a particular key in the database, we need a different data structure: an index\n\nA table index is a **replica of a subset** of a table's columns that are organized and/or sorted for efficient access using a subset of those column\n\n## B+ tree\n\n- b+ tree:\n    - **self-balancing** tree data structure that keeps data sorted and allows searches, sequential access, insertions, and deletions in O(log n).\n    - m-way search tree: every leaf node is at the same depth\n    - every node with m/2+1 <= k <= m keys, k keys, k+1 child\n    - |link(< k )|key1|link( < k2 )|key2|link3( >= k2)|...\n    - node is an array of key/value pairs, key is column, value differ based on whether the node is classified as inner nodes or leaf nodes.\n    - only stores values in leaf nodes. Inner nodes only guide the search process.\n- B+TREE DESIGN CHOICES\n    - node size\n    - Merge Threshold : maybe delay merge operation\n    - Variable Length Keys : \n    - Non-Unique Indexes : \n    - Intra-Node Search: binary search \n- optimization:\n    - prefix compression: store prefix and only store defferent substring, leaf node\n    - suffix truncation: key very different and you only need suffix to see which key to go left or right, inner node\n    - bulk insert\n    - POINTER SWIZZLING\n\n## other index\n\n- skip list\n    - dynamic order-preserving index use a sorted linked list\n    - **Multiple levels** of linked lists with extra pointers that skip over intermediate nodes.\n    - To insert a new key, **flip a coin** to decide how many levels to add the new key into. Provides approximate O(log n) search times.\n    - First logically remove a key from the index by setting a flag to tell threads to ignore.\n    - Then physically remove the key once we know that no other thread is holding the reference.\n    - pros\n        - less space\n        - no rebalance\n    - cons\n        - not disk friendly, reverse search not good\n- radix tree\n    - Represent keys as individual digits. This allows threads to examine prefixes one-by-one instead of comparing entire key.\n    - 可能的问题就是一些不好表示，比如signed int，float\n- inverted index\n    - full text search index\n","n":0.053}}},{"i":321,"$":{"0":{"v":"Graph","n":1},"1":{"v":"\n# Graph-Like Data Models\n\nA graph consists of two kinds of objects: vertices (also known as nodes or entities) and edges (also known as relationships or arcs)","n":0.196}}},{"i":322,"$":{"0":{"v":"Distributed_system","n":1},"1":{"v":"\n\n## 多个server的concurrency解决思路\n\n### Centralized Approach 中央集权\n\n- what: 直接指派一个作为中央\n- why:easy and gurante\n- how: 3 messeages per cs entry : (request, permission, done)\n- problem: central dies and threads dies in the cs\n\n### lamport timestamp\n\n- what: global pripority queue for cs. send to each node request\n- why:  every node know what happens.\n- how: 3(N-1) messeages per requests (request,reply,release)\n- problem: no falut tolerant. message may not arrive in time, especially when sending requst\n\n### Ricarti and Agrawala timestamp approach\n\n- what: combine reply and release. change global queue to voting.\n- why: reduce message number\n- how: send request to others and if other agree(not in CS, or in cs and exit will reply) will reply. Get enough vote can start. 2*(n-1) messages.\n- problem: workhorses. too much messages. Even a single failure can disable the entire system. Both timestamp approaches require more messages than a centralized approach -- and have lower fault tolerance. The centralized approach provides one single point of failure (SPF). These timestamp approaches have N SPFs.\n\n### Voting\n\n- what: send request to others, if other have voted, put it in queue. When one exit cs, it send release to others and other could handle request in the queue.\n- why: only majority agree is ok. change the way of message and queue. \n- how: break ties could use **lamport time**. break deadlock when no one win, use inqure message, and other could vote again.It sends an INQUIRE message to the candidate for who it voted. If this candidate won the election, it can just ignore the INQUIRE and RELEASE normally when done. But, if it hasn't yet entered the critical section, it gives back the vote and signals this by sending back a RELINQUISH. Upon receipt of the RELINQUISH, the voter is free to vote for the preceding request.\n- problem: less message. (3+x)(1/2 N+?) request, vote, release\n\n### voting districts\n\n- what: send message to districts, just in the same line and cloumn. \n- why: reduce message\n- how: same voting techniques. 3*(2sqrt(N)-1)\n- problem: not falut tolerant, no deadlock. one server die may change.选择多个进入cs\n\n### token ring\n\n- what: everyone know successor, and move token one by one. hold it until done cs\n- why: fault tolerance. good at high contention\n- how: if one dies with token, last one see time out and generate a new one. Under high contention, message low. Every one has limited time with token.\n- problem: not good at low contention. \n\n### raymond's algorithm\n\n- what: use tree to pass token ring. \n- why: more quick in low contention\n- how: pass by node.\n- problem: worst case, travel long\n\n### path compression\n\n- what: allow short cut to pass token ring\n- why: current_dir may out-of-date, when request happened, node can get into current_dir end and enqueue in **next** queue. \n- how: use a queue of pending request with current_dir and next. current_dir point to next waiting, next is current(with token) point to waiting.","n":0.046}}},{"i":323,"$":{"0":{"v":"Voting","n":1},"1":{"v":"\n\n## 多个server的选举策略\n\ndifference between cs:\n\n- other do not need to know who enter cs. election need other know who is coordinator.\n- fault tolerance is primary consideration in election.\n\n### bully algorithm\n\n- what: use highest number as coordinator.\n- why: easy\n- how: when coordinator dies, send election to high number, if not recieve ack, it become coo and send to others. \n- problem: assumption is not realible(network is ok and we could know who dies accurately). failure need detect accurately.\n\n### invitation algorithm\n\n- what: form group to elect one and create a large one.\n- why: communication failure and high latency. use partition to handle is the best way.\n- how: merge them partition into group. choose one in partition and merge with another and get one.\n- problem: state is not consistence among group.\n\n### ring election\n\n- what:非同步算法。find cooridator die, send election around ring, every one add itself in the message. assume highest is new and everyone get message again remove itself.\n- why: good at high contention, and less messge","n":0.079}}},{"i":324,"$":{"0":{"v":"Raft","n":1},"1":{"v":"\n\n# \b共识机制 raft\n\nmain idea is to allow a collection of machines to work as a group that can survive the failures fo some of its members.\n\n## leader election\n\n- what: in each term, elect a leader. when time out, start a new election.\n- why: one leader to recieve request and syn among all machines.\n- how: begin one election with term++, every one vote itself first and request others, if it finds other have more latest term, it will become follower.\n\n## log replication\n\n- what: append command as a log entry.\n- why: make sure everyone has same log\n- how: commit, if consistence, duplicate leader's\n- When AppendEntries consistency check fails, decrement nextIndex and try again\n- When follower overwrites inconsistent entry, it deletes all subsequent entries    \n","n":0.091}}},{"i":325,"$":{"0":{"v":"Paxos","n":1},"1":{"v":"\n\n\n# paxos\n\nA collection of process can propose values\nA consensus algorithm ensures \n\n- That a single proposal is chosen\n- The processes can learn the proposed value \n- No value is chosen if there are no proposals.\n\n- **what**: consensus probelm algorith.\n- **how**:\n    - **Prepare**:propersor sends a Prepare message containing this **proposal** to a **Quorum** of Acceptors\n    - **Promise**:If the proposal's number N is higher than any previous proposal number received from any Proposer by the Acceptor, then the Acceptor must return a **promise** to **ignore** all future proposals having a number less than N. If the Acceptor accepted a proposal at some point in the past, it must include the previous proposal number and previous value in its response to the Proposer.\n    - **Accept request**:If a Proposer receives enough promises from a Quorum of Acceptors, it needs to set a value to its proposal. If any Acceptors had previously accepted any proposal, then they'll have sent their values to the Proposer, who now must set the value of its proposal to the value associated with the highest proposal number reported by the Acceptors. The Proposer sends an **Accept Request message** to a Quorum of Acceptors with the chosen value for its proposal.\n    - **Accepted**:If an Acceptor receives an Accept Request message for a proposal N, it must accept it if and only if it has not already promised to only consider proposals having an identifier greater than N. In this case, it should register the corresponding value v and send an Accepted message to the Proposer and every Learner. Else, it can ignore the Accept Request.","n":0.062}}},{"i":326,"$":{"0":{"v":"Filesystem","n":1},"1":{"v":"\n\n# file system\n\n- **what**: a file is a unit of data organized by user. a service responsible for managing files\n- **why**: key is robust and high-throughput\n- **how**: name, access, physical allocation, security and protection, resource administration.\n\n\n## NFS and AFS\n\n1. NFS has no client caching, cliented cached anyway, central system\n2. AFS is stateful server and has cache protocol. called to have data client there is an update, their cache is invalid. Whole file semantic\n3. CODA, add replication and added weakly connected mode.\n\n# RAIDS and HDFS\n\n## Normal disk\n\n- An error-correcting code (ECC) or forward error correction (FEC) code is a process of adding **redundant** data, or parity data, to a message, such that it can be recovered by a receiver even when a number of errors (up to the capability of the code being used) were introduced, either during the process of transmission, or on storage.\n- RAM could cache the data. It will only read data from disks. If there was error, disk will return nothing.\n\n## RAIDS\n\n- **what**:Redundant Array of Independent Disks,combines multiple physical disk drive components into one or more logical units for the purposes of data redundancy, performance improvement, or both.\n- **why**: more rebust, larger volume,higher throughput\n- **how**:\n    - RAID 0 它將兩个以上的磁盘並联起来，**成为一个大容量的磁盘**。在存放数据时，分段后分散儲存在这些磁盘中，因為读写時都可以并行處理，所以在所有的级别中，RAID 0的**速度**是最快的。no redundancy,just split into serveral disks\n    - RAID 1: mirroring,disk0=disk1,在一些多线程操作系统中能有很好的**读取**速度,replication，理論上读取速度等於硬盘數量的倍數，与RAID 0相同\n    - RAID 2:这是RAID 0的改良版，以汉明码（Hamming Code）的方式将数据进行编码后分割为独立的位元，并将数据分别写入硬盘中。因为在数据中加入了错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些. log2. Have disks save error correction code for each partition.\n    - RAID3: a disk save **parity**. 採用Bit－interleaving（数据交错儲存）技術，它需要通过编码再将数据位元分割後分别存在硬盘中，而将同位元检查後单独存在一个硬盘中，但由于数据内的位元分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适于读取大量数据时使用。\n    - RAID4:它与RAID 3不同的是它在分割时是以block为单位分别存在硬盘中\n    - RAID5:RAID Level 5是一种储存性能、数据安全和存储成本兼顾的存储解决方案。它使用的是Disk Striping（硬盘分割）技术。RAID 5至少需要三块硬碟，RAID 5不是对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储於不同的磁盘上。**当RAID5的一个磁盘数据发生损坏後，可以利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据**。![](https://en.wikipedia.org/wiki/File:RAID_5.svg)\n    - RAID6:与RAID 5相比，RAID 6增加第二个独立的奇偶校验信息块\n    - RAID10 = RAID0+RAID1\n\n## LUSTRE\n\n- **what**:a type of parallel distributed file system, generally used for large-scale cluster computing\n- **why**: used for supercomputing, network RAID\n- **how**:\n    - Files are broken into objects, very similar to stripes. These stripes can be stored by different nodes.\n    - One or more metadata servers (MDS) nodes that has one or more metadata target (MDT) devices per Lustre filesystem that stores namespace metadata, such as filenames, directories, access permissions, and file layout(different access pattern,data is small)\n    - One or more object storage server (OSS) nodes that store file data on one or more object storage target (OST) devices.(enable either OSS talk to either OST)\n    - Client(s) that access and use the data. Lustre presents all clients with a unified namespace for all of the files and data in the filesystem\n    - high performance network to transfer data and manage network to manage data\n\n## MOGILEFS\n\n- **what**:distributed filesystem\n- **why**:no editing, whole file,fast deliver to clients\n- **how**:\n    - replicated storage:it replicates objects across servers. The number of replicas is associated with the class of the file, so, for example, photos might have three replicas, each, but thumbnails, which can be recreated from the original photos, might only have one replica of each. this reduces the cost of the storage by allowing less expensive components.\n    - http+MySQL:MogileFS uses HTTP to server objects from each replica, as opposed to a home-grown protocol, for portability. For the same reason, it keeps its metadata in a standard MySQL database. \n    - portable\n    - no hierachy: it maintains simple namespaces, rather than directory trees,  is much simpler and more efficient than a full-blown directory system\n\n## HDFS\n\n### assumption\n\n- failure is a norm, especially on datanode. It is used to handle streaming data. \n- emphasis is on throughput not on latency\n- large data sets\n- simple coherency model: write once and read many\n- moving computation is cheaper than moving data\n-  The good news is that it won't be edited in place. We'll just be collecting it, adding to it.\n-  \n![](/assets/images/2021-04-12-19-59-50.png)\n\n\n## namenode\n\n- **what**: master-slave architecture\n- **why**: manage namespace as coordinator, only 1\n- **how**: block to DataNodes mapping\n- data never go to namenode\n- hierarchical name space: maybe not needed, low overhead\n\n## datanode\n\n- manage storage attached to node\n- create and delete block, replicate blocks\n\n## access mode\n\n- read anywhere\n- write only at end(append)\n- no edit/random write\n\n## replication\n\n- blocks are all same size\n- fault tolerance\n- namenode managed replication\n- pipelining\n    - When a client is writing data to an HDFS file, its data is first written to a local file as explained in the previous section.\n    -  The **first** DataNode starts receiving the data in small portions (4 KB), writes each portion to its local repository and transfers that portion to the **second** DataNode in the list. The second DataNode, in turn starts receiving each portion of the data block, writes that portion to its repository and then flushes that portion to the **third** DataNode.\n    -  less bandwidth and less hot-spot","n":0.037}}},{"i":327,"$":{"0":{"v":"Concurrency","n":1},"1":{"v":"\n\n\n## concurrency control\n\nThe goal of a concurrency control is to generate an execution schedule that is equivalent to some serial execution:\n\n- serial schedule: a schedule does not interleave the actions of different transactions\n- equivalent schedules: the effect of executing two schedules are same\n- serializable schedule: a schedule is equivalent to some serial execution of transactions.\n\nThere are some problems when interleaves the operations:\n\n- Read-write conflicts (unrepeatable reads): A transaction cannot get the same value when reading the same object multiple Times.\n- Write-read conflicts(Dirty read): a transaction sees the write effects of a different transaction before that transaction committed its changes.\n- Write-Write conflicts (Lost updates): one transaction overwrites the uncommitted data of another concurrent transitions.\n\nSchedule S is **conflict serializable** if you are able to transform S into a serial schedule by **swapping consecutive non-conflicting operations** of different transactions. We could use dependency graphs to check. $T_i$ -> $T_j$ means if one operation $O_i$ of $T_i$ conflicts with an operation $O_j$ of $T_j$ and $O_i$ appears earlier in the schedule in $O_j$. A schedule is conflict serializable if and only the graph is acyclic. \n\nFor View serializable, it means if one write is overwrote by another transaction and there is no read, it is fine. It allows all conflict serializable schedules and blind writes. It is hard to enforce efficiently. It allows more schedules.\n\nFor durability. All of the changes of committed transactions must be durable (i.e., persistent) after a crash or restart. The\nDBMS can either use logging or shadow paging to ensure that all changes are durable.\n","n":0.063}}},{"i":328,"$":{"0":{"v":"Replication","n":1},"1":{"v":"\n# master-slave\n\nFor replica configurations,  Master-Replica will receive all updates and it propagates those updates to its replicas. K-safety is a threshold for determining the fault tolerance of the replicated database. The value K represents the number of replicas per data object that must exist at all times.\n\n# propagation\n\nWhen a txn commits on a replicated database, the DBMS has to decide whether it has to wait for that txn's changes to propagate to other nodes before it can send the acknowledgement to application.\n\n- Synchronous: The master sends updates to replicas and then waits for them to acknowledge that they fully applied (i.e., logged) the changes.\n- Asynchronous: The master immediately returns the acknowledgement to the client without waiting for replicas to apply the changes.\n- Semi-Synchronous:  Replicas immediately send acknowledgements without logging them\n\n## CVV\n\n1. It asks all replicas for their version number\n2. It then asks the replica with the greatest version number for the file\n3. If the servers don't agree about the files version, the client can direct the servers to update a client that is behind, or inform them of a conflict. CVVs are compared just like vector timestamps. A conflict exists if two CVVs are concurrent, because concurrent vectors indicate that each server involved has seen some changes to the file, but not all changes.","n":0.068}}},{"i":329,"$":{"0":{"v":"Recovery","n":1},"1":{"v":"\nRecovery algorithms are techniques to ensure database consistency, transaction atomicity, and durability despite failures. Recovery algorithm has two parts: actions during normal transaction, actions after a failure to recover the database.The key primitives are UNDO, the process of removing the effects of an incomplete or aborted transaction. REDO: the process of re-instating the effects of a committed transaction for durability.\n\nStorage can be volatile storage, data will be lost after powering off. Non-Volatile have data persistent after powering off. Stable storage never lose data. It could achieve approximately by using multiple storages. \n\nFailure can be transaction failure: transaction cannot complete due to some internal error and DBMS must terminate an active transaction due to an error condition. System failure is DBMS fails and system is crashed, non-volatile storage are not corrupted. Storage media failure is a disk failure and destroy parts of non-volatile storage. \n\n**Buffer pool management steal policies** will decide whether the DBMS allow an uncommitted transaction to overwrite the most recent committed value of an object in non-volatile storage. No-steal policy will not write uncommitted transaction value back to disk,  steal policy, allows the system to write modified blocks to disk even if the transactions that made those modifications have not all committed, could steal other transaction's memory. Force policy ensures that all updates made by a transaction are reflected on non-volatile\nstorage before the transaction is allowed to commit. No-force is not enforced to do this. NO-STEAL + FORCE means no redo: all committed transactions' changes are reflected in disk, no undo: all aborted transactions' changes are not written to disk. Limitation is memory because of no-steal policy.\n\nShadow paging means updates are only made in the shadow copy. When a transaction commits, atomically switch the shadow to become the new master. Disadvantages: Copying the entire page table is expensive and the commit overhead is high. Organize the database pages in a tree structure where the root is a single disk page. The root points to the master copy, updates are applied to the shadow copy. To install updates, overwrite the root so it points to the shadow, thereby swapping the master and\nshadow. For undo, it remove the shadow pages. Leave master and the DB root pointer alone. Do not need redo.\n\n**Write-Ahead Logging** means DBMS records all changes made to the db in log file before changes is made to a disk page. The log contains information to perform undo and redo. It has fast runtime performance but slow recovery time. Log records are written to disk before update is allowed to be written on disk. Transaction is committed until all its log records have been written to stable storage.Write BEGIN in the beginning, COMMITTED to make sure all log records are flushed. Log records contains tid, object id, before value(UNDO), after value(REDO). If we use NO-STEAL policy, we don't need original value, but in that way we could not undo for aborted transaction.\n\nDBMS can periodically takes a checkpoint where it flushes all buffers out to disk. The DBMS stops accepting new transactions and waits for all active transactions to complete. Flush all log records and dirty blocks currently residing in main memory to stable storage. Write a <CHECKPOINT> entry to the log and flush to stable storage.\n\nLogging schemes could be physical logging: record the changes made to a specific location in the database. Logical logging records the high operations executed by transactions. Physiological logging means log records target a single page but do not specify data organization of the page.\n\n\n## ARIES\n\nAlgorithms for Recovery and Isolation Exploiting Semantics. \n\n- WAL\n- Repeat history in redo\n- logging changes during undo\n\nIn WAL, each log record has a global unique log sequence number. Each data page contains a pageLSN, the LSN of the most recent update to that page. prevLSN: The previous LSN for the transaction. System keeps track of flushedLSN: the max LSN flushed so far. Before page i can be written to disk, we must flush log at least to the point where $pageLSN_i$ ≤ flushedLSN.\n\nTransaction commit will first write COMMIT record to log. All log records to to transaction’s COMMIT record are flushed to disk. When the commit succeeds, write a special TXN-END record to log. \n\nTransaction abort just an UNDO operation. Use prevLSN to undo transaction. Compensation Log Record, CLR describes the actions taken to undo the actions of a previous update record. It has all the fields of an update log record plus the undoNext pointer. CLRs are added to the log like any other record but they never need to be undone.\n\n1. First write ABORT record to log.\n2. Then play back updates in reverse order to remove their effects. For each update, write a CLR entry and restore old value.\n3. At end, write a TXN-END log record.\n\nBlocking checkpoints will halt the start of any new transactions and wait until all active transactions finish executing, flush dirty pages on disk.\n\nBetter one will halt new transaction and just pause transactions while the DBMS takes the checkpoint. It uses \n**Active Transaction Table (ATT)** to record active transaction and their lastLSN(most recent lsn written by transaction). Entry is removed when transaction commits or aborts. In **Dirty Page Table (DPT)**, it keeps track of pages in the buffer pool contain changes from uncommitted transactions. And there is **recLSN** field, the LSN of the log record that first caused the page to be dirty.\n\nFuzzy checkpoints allows other transactions to continue to run. Add new log records to track checkpoint boundaries, <CHECKPOINT-BEGIN>: Indicates the start of the checkpoint, <CHECKPOINT-END>: Contains the ATT + DPT.\n\nThere are three phases in ARIES.\n\nAnalysis: Read the WAL to identify dirty pages in the buffer pool and active transactions at the time of the crash.\n\n- Scan log forward from the checkpoint.\n- If you find a TXN-END record, remove its transaction from ATT.\n- All other records, add transaction to ATT with status UNDO, and on commit, change transaction status to COMMIT.\n- For UPDATE records, if page P not in DPT, add P to DPT and set its recLSN=LSN\n\nREDO: repeat history to reconstruct state at the moment of the crash. Reapply all updates (even aborted transactions) and redo CLRs:\n\n- Scan forward from log record containing smallest recLSN in PDT.\n- For each update log record or CLR with a given LSN, redo the action unless:\n\t– Affected page is not in the DPT, or\n\t– Affected page is in DPT but that record’s LSN is greater than smallest recLSN, or \n\t– Affected pageLSN (on disk) ≥ LSN.\n- To redo an action:\n\t– Reapply logged action.\n\t– Set pageLSN to log records LSN.\n\t– At the end of the redo phase, write TXN-END log records for all transactions with status “C” and remove them from the ATT.\n\nUndo Phase:\n\n- Undo All transactions active at the time of crash\n- These are all transactions with “U” status in the ATT after the Analysis phase \n- Process them in reverse LSN order using the lastLSN to speed up traversal\n- Write a CLR for every modification","n":0.029}}},{"i":330,"$":{"0":{"v":"Consistency","n":1},"1":{"v":"\n# Weak consistency\n\nAfter a write, reads may or may not see it. A best effort approach is taken.\n\nThis approach is seen in systems such as memcached. Weak consistency works well in real time use cases such as VoIP, video chat, and realtime multiplayer games. For example, if you are on a phone call and lose reception for a few seconds, when you regain connection you do not hear what was spoken during connection loss.\n\n# Eventual consistency\n\nAfter a write, reads will eventually see it (typically within milliseconds). Data is replicated asynchronously.\n\nThis approach is seen in systems such as DNS and email. Eventual consistency works well in highly available systems.\n\n# Strong consistency\n\nAfter a write, reads will see it. Data is replicated synchronously.\n\nThis approach is seen in file systems and RDBMSes. Strong consistency works well in systems that need transactions.","n":0.085}}},{"i":331,"$":{"0":{"v":"Cap","n":1},"1":{"v":"\n# CAP theorem: Consistency, Availability, Partition Tolerant. \n\nConsistency: If master says the txn committed, then it should be immediately visible on replicas. \n\nAvailability: Achieving availability in a distributed system requires that the system remains operational 100% of the time. \n\nPartition TOLERANCE means tolerance to a network partition. A network partition is when two nodes can't talk to each other, but there are clients able to talk to either one or both of those nodes.\n\n\n- By consistency we mean that all participating systems share the same view of the data.\n- By **Availability** we mean that the system is able to **respond quickly** enough for the user's needs.\n- By **Partition** tolerance we mean that, in the event of the failure or isolation of some participants, the other participants can continue to do whatever they can.\n- CA : mysql\n- CP: commuication among server to get consistence but not availability\n- PA: several servers but no consisitence\n\nNetworks aren't reliable, so you'll need to support partition tolerance. You'll need to make a software tradeoff between consistency and availability.\n\nCP - consistency and partition tolerance\nWaiting for a response from the partitioned node might result in a timeout error. CP is a good choice if your business needs require atomic reads and writes.\n\nAP - availability and partition tolerance\nResponses return the most readily available version of the data available on any node, which might not be the latest. Writes might take some time to propagate when the partition is resolved.\n\nAP is a good choice if the business needs allow for eventual consistency or when the system needs to continue working despite external errors.\n\n![](https://qph.fs.quoracdn.net/main-qimg-23a75bd8c77d030f3ca9e1fd0621c10c.webp)\n![](http://www.andrew.cmu.edu/course/14-736/applications/ln/dividework.jpg)\n![](http://www.andrew.cmu.edu/course/14-736/applications/ln/addcomm.jpg)","n":0.062}}},{"i":332,"$":{"0":{"v":"Basic","n":1},"1":{"v":"\n\n# Classical Non-Distributed Concurrency Control \n\n## spin-lock\n\n- **what**:Atomic compare-and-swap/test-and-set instructions\n- **why**: easy\n- **how**: Requires locking memory bus on multi-core/multi-processor\n- **problem**:Busy wait not good for high contention. busy-waiting, busy-looping or spinning is a technique in which a process repeatedly checks to see if a condition is true, such as whether keyboard input or a lock is available.\n\n## mutex\n\n- **what**:Semaphores, At-Most-N policies,Mutual Exclusion\n- **why**:Conceptually,manages a pool of resources.\n- **how**:\n    - P operation: Wait for resource to be available (lock s-=1)\n    - V operation: Make resource available (unlock s+=1)\n    - Deschedule (move to blocked queue) blocked thread or process \n    - Reschedule (move to ready queue) when resource available\n    - 初始s=1，s不会是负值\n\n## CONDITION VARIABLES\n\nEvent based \n\n- Wait – always waits. No predicate\n- Signal – Wake up a waiter\n- Broadcast – Wake up all waiters.","n":0.088}}},{"i":333,"$":{"0":{"v":"TOCC","n":1},"1":{"v":"\nTimestamp ordering (T/O) is an optimistic class of concurrency control protocols where the DBMS assumes that transaction conflicts are rare. DBMS instead uses timestamps to determine the serializability order of transactions. Timestamp could allocate using system lock, logical counter and hybrid.\n\nFor every database object X is tagged with timestamp of the last transaction that successfully did read/write. W-TS(X) and R-TS(X). If transaction tries to access an object “from the future”, then the DBMS aborts that transaction and restarts it.\n\nIn read operations, if $TS(T_i)$ < W-TS(X), the transaction will read a value that was already overwritten and this transaction will be rejected and abort, restart with same TS. If $TS(T_i)$ >= W-TS(X), it allows $TS(T_i)$ to read X and update R-TS(X). Depends on isolation levels, it can make a local copy of X to ensure repeatable reads for $T_i$.\n\nIn write operations, if $TS(T_i)$ < W-TS(X) or if $TS(T_i)$ < R-TS(X), it tries to write an obsolete value or the value needed is in the past. Transaction will be aborted and roll back. Else it could write X and update W-TS(X).\n\nFor Thomas Write Rule\n\nIf $TS(T_i)$ < R-TS(X), it will abort and restart. If $TS(T_i)$ < W-TS(X), ignore the write and allow transaction to continue. It make use of view serializability, deleting obsolete write operations from the transactions that issue them. \n\nThe basic timestamp ordering cannot have deadlocks because no transaction ever waits. But there is a possibility of starvation for long transactions if short transactions keep causing conflicts.\n\nIt also permits schedules that are not **recoverable**. A schedule is recoverable if transactions commit only after all transactions whose changes they read or commit. Otherwise, the DBMS cannot guarantee that transactions read data that will be restored after recovering from a crash.\n\nIssues:\n\n- High overhead from copying data to transaction’s workspace and from updating timestamps.\n- Long running transactions can get starved: The likelihood that a transaction will read something from a newer transaction increases.\n- Suffers from the timestamp allocation bottleneck on highly concurrent systems.","n":0.055}}},{"i":334,"$":{"0":{"v":"MVCC","n":1},"1":{"v":"# Multi-Version Concurrency Control\n\nThe DBMS maintains multiple physical versions of a single logical object in the database. When a transaction writes to an object, the DBMS creates a new version of that object. When a transaction reads an object, it reads the newest version that existed when the transaction started.\n\nThe key properties: Writers don’t block the readers. Readers don’t block the writers. Read-only transactions can read a consistent snapshot without acquiring locks. Timestamps are used to determine visibility. It supports time-travel queries. \n\nVersion storage will help DBMS decide how to store different physical versions of a logical object. The DBMS uses the tuple’s pointer field to create a version chain per logical tuple. Indexes always point to the head of the chain. A thread traverses chain until you find the version thats visible to you. \n\n- Append-Only Storage – New versions are appended to the same table space.\n\t- Oldest-To-Newest (O2N): Append new version to end of chain, look-ups require entire chain traversal.\n\t- Newest-To-Oldest (N2O): Head of chain is newest, look-ups are quick, but indexes need to be up- dated every version.\n- Time-Travel Storage – Old versions are copied to separate table space.\n- Delta Storage – The original values of the modified attributes are copied into a separate delta record space.\n\nGarbage Collection: The DBMS needs to remove reclaimable physical versions from the database over time. \n\n- Tuple Level Garbage Collection – Find old versions by examining tuples directly\n\t- Background Vacuuming: Separate threads periodically scan the table and look for reclaimable ver- sions, works with any version storage scheme.\n\t- Cooperative Cleaning: Worker threads identify reclaimable versions as they traverse version chain. Only works with O2N.\n- Transaction Level – Each transaction keeps track of its own read/write set. When a transaction completes, the garbage collector can use that to identify what tuples to reclaim.\n\nIndex Management: All primary key (pkey) indexes always point to version chain head. \n- Logical Pointers – Use a fixed identifier per tuple that does not change. Requires an extra indirection layer that maps the logical id to the physical location of the tuple\n- Physical Pointers – Use the physical address to the version chain head","n":0.053}}},{"i":335,"$":{"0":{"v":"ACID","n":1},"1":{"v":"\n\nACID:\n\n- Atomicity: all actions in the transaction happen or none happen.\n- Consistency: if each transaction is consistent and database is consistent in the beginning, it is guaranteed to be consistent when the transaction completes.\n- Isolation: the execution of one transaction is isolated from that of other transactions.\n- Durability: If a transaction commits, then its effects on the database persist.\n\nFor atomicity, there are two ways: shadow paging or logging. DBMS makes copies of pages and transaction make changes to those copies, only become visible when the transaction commits. DBMS could logs all actions so that it can undo the actions of aborted transactions. \n\nFor consistency, DBMS will make sure it return correct results. Database consistency means it can accurately represents the real world entity and the future transaction could see the effect of past committed transaction correctly. Transaction consistency make sure DB consistency after executing transaction.\n\nFor Isolation, transaction will not see other concurrent transaction's effect. It is equivalent to a system where transactions are executed in serial order. That's why we need concurrency control. It tells DBMS how to interleaving of operations from multiple transactions. There are two categories of concurrency control: pessimistic and optimistic. Pessimistic assume transactions will conflict, optimistic will assume conflicts are rare.\n","n":0.07}}},{"i":336,"$":{"0":{"v":"2PL","n":1},"1":{"v":"\nWe need to make all executes are correct without knowing the entire schedule ahead of time, using locks to protect database objects could make it work. **Two lock types: Shared lock and exclusive lock**. Locks are requested by transactions from the lock manager. The lock manager grants or block requests based on what locks are currently held by other transactions. Transaction will release lock when they do not need them. The lock manager updates its internal lock-table and then gives locks to waiting transactions. \n\nTwo phase locking is **pessimistic** concurrency control protocol. **The first phase is growing phase, each transaction requests the locks that it needs from the DBMS's lock manager. The second phase is shrinking phase, transaction enters this phase when it releases its first lock**. It cannot acquire new locks in this phase. The problem is **cascading aborts**(why?), when one transaction aborts, another transaction must be rolled back. Some schedule is serializable but not allowed by 2PL. S**trict 2PL means the transaction only releases exclusive-modes locks when it finishes**. Rigorous will take all lock until finishes. A schedule is strict if a value **written** by a transaction is not read or overwritten by other transactions until that transaction finishes. There is no cascading aborts here. \n\nBut it is possible to have deadlock in 2PL. A deadlock is a cycle of transactions waiting for locks to be released by each other. Deadlock detection will create a waits-for graph. Edge from $T_i$ to $T_j$ means $T_i$ is waiting $T_j$. The system will periodically check for cycles in waits-for graph and then make a decision on how to break it. When the DBMS detects a deadlock, it will select a “victim” transaction to rollback to break the cycle. DBMS can also decide the rollback length, it could just roll back.\n\nDeadlock prevention will prevent transaction waiting a transaction. Assign priorities based on timestamps, older means higher. These schemes guarantee no deadlocks because only one type of direction is allowed when waiting for a lock. When a transaction restarts, its (new) priority is its old timestamp.\n\n- Wait-Die (“Old waits for Young”): If T1 has higher priority, T1 waits for T2. Otherwise T1 aborts \n- Wound-Wait (“Young waits for Old”): If T1 has higher priority, T2 aborts. Otherwise T1 waits.\n\nWe could use a use a lock hierarchy that allow a transaction to take more coarse-grained locks in the system. Intention locks allow a **higher level node** to be locked in shared or exclusive mode without having to check all descendant nodes. If a node is in an intention mode, then **explicit locking is being done at a lower level**.\n\n\n- Intention-Shared (IS): Indicates explicit locking at a lower level with shared locks.\n- Intention-Exclusive (IX): Indicates explicit locking at a lower level with exclusive or shared locks. \n- Shared+Intention-Exclusive (SIX): The subtree rooted at that node is locked explicitly in shared mode and explicit locking is being done at a lower level with exclusive-mode locks.\n","n":0.045}}},{"i":337,"$":{"0":{"v":"2PC","n":1},"1":{"v":"\n# 2 phase commit\n\nIn two-phase commit, phase 1 is prepare, when receive commit request, it sends two all participants Ready? And wait for ok back. Then phase 2 is commit and wait for OK, then send SUCCESS to application server. If there is ABORT, it will send back to application server with ABORT and send ABORT to participants in phase 2. \n\nThe improvement is using Early Prepare Voting(using when it is the last one, return the result is the transaction result), Early Acknowledgement After Prepare (If all votes to commit a ten, it can send acknowledgement to client before phase 2 finishes). Two-Phase Commit will block if coordinator fails after the prepare message is sent, until coordinator recovers.\n\n## pharse1\n### Coordinator \n\n- Precommit (write to log and.or atomic storage)\n- Send request to all participants\n- Coordinator blocks waiting for ALL replies\n\n\n### Participant\n\n - Wait for request\n - Upon request, if ready:\n    - Precommit\n    - Send coordinator YES \n - Upon request, if not ready:\n    - Send coordinator NO\n\n## pharse2\n\n### Coordinator \n\n- This is the point of no return!\n- If all participants voted YES then send commit to each participant \n- Otherwise send ABORT to each participant\n\n\n### Participant\n\nWait for \"the word\" from the coordinator\n- If COMMIT, then COMMIT (transaction becomes visible)\n- If ABORT, then ABORT (gone for good)\n\n\nAnother real-world atomic commit protocol is three-phase commit (3PC). This protocol can reduce the amount of blocking and provide for more flexible recovery in the event of failure.\n\n\n![](http://www.andrew.cmu.edu/course/14-736/applications/ln/2pc-coord.jpg)\n![](http://www.andrew.cmu.edu/course/14-736/applications/ln/2pc-part.jpg)\n\n![](http://www.andrew.cmu.edu/course/14-736/applications/ln/3pc-coord.jpg)\n![](http://www.andrew.cmu.edu/course/14-736/applications/ln/3pc-part.jpg)\n","n":0.064}}},{"i":338,"$":{"0":{"v":"CDN","n":1},"1":{"v":"![](/assets/images/2021-03-25-17-04-36.png)\n\n![](/assets/images/2021-03-25-16-59-58.png)\n\n- FNA 只有static content， untrust environment\n- PoP point of presence\n\n![](/assets/images/2021-03-25-17-08-48.png)\n\n![](/assets/images/2021-03-25-17-12-24.png)\n\n![](/assets/images/2021-03-25-17-15-31.png)\n\n![](/assets/images/2021-03-25-17-19-05.png)\n\n\n![](/assets/images/2021-06-30-17-11-41.png)\n\n![](/assets/images/2021-06-30-17-21-16.png)\n\n![](/assets/images/2021-06-30-17-29-33.png)\n## real life\n\n- aws cloud front","n":0.258}}},{"i":339,"$":{"0":{"v":"Cache","n":1},"1":{"v":"\n# memcache\n\n![](/assets/images/2021-03-26-13-03-11.png)\n\n## memcached\n\n- **what**:使用LRU的一个巨大的hashtable。定时遗忘，high throughput\n- **why**：集合很多web server 的内存, use memory is fast and low latency\n- **how**: 出问题回disk找\n- **problem**：没有稳定的存储\n- handle common problem, much simple\n- Designed for volatile data\n    - failure: just go to disk\n    - recovery: just turn back on and wait. repopulated again\n\n# redis\n\nREmote DIctionary SErver\n\n- **what**: 支持多种数据类型，LRU，稳定存储\n- **why**: 解决同样的问题\n- **how**：定时写回disk，持久。\n    - simple client: ask any node and get redirected.(redirected may take long time)\n    - smart client: know the map, return this to the client(map maybe useless later)\n\n\n","n":0.113}}},{"i":340,"$":{"0":{"v":"Computer","n":1},"1":{"v":"\n# kernel\n\n![](/assets/images/2021-05-11-19-38-22.png)","n":0.707}}},{"i":341,"$":{"0":{"v":"Shell","n":1},"1":{"v":"\n# shell\n\n## execute\n\nshell首先检查命令是否是内部命令，若不是再检查是否是一个应用程序（这里的应用程序可以是Linux本身的实用程序，如ls和rm，也可以是购买的商业程序，如xv，或者是自由软件，如emacs）。然后shell在搜索路径里寻找这些应用程序（搜索路径就是一个能找到可执行程序的目录列表）。如果键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。如果能够成功找到命令，该内部命令或应用程序将被分解为系统调用并传给Linux内核。","n":0.577}}},{"i":342,"$":{"0":{"v":"Service_management","n":1},"1":{"v":"\n# systemd\n\nsystemd allows you to create and manage services in extremely powerful and flexible ways. \n\n## Unit files\n\nIf you're creating a brand new unit file for your service, you must first come up with a name. The name you select must not collide with any existing service name.\n\nCreate your service's unit file with the \".service\" suffix in the /etc/systemd/system directory. In our example, we will be creating a /etc/systemd/system/myservice.service file.\n\nThe first thing you must identify is what type of service you will be managing. Most services should use the simple type, which means a program that runs in the foreground. If your service normally runs itself in the background, search the documentation to see if it has an option to disable that. Running in the foreground is preferred.\n\n## command \n\n- systemctl start service\n- systemctl status 命令查看一下该服务的状态\n- 终止正在运行的服务，需要执行systemctl stop命令\n\n[reference](https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html)","n":0.085}}},{"i":343,"$":{"0":{"v":"Program","n":1},"1":{"v":"\n# how to get executable\n\n*.c -> *.i (ASCII中间文件) -> *.s (汇编) -> *.o (relocatable object file) -> ld -> prog (executable object file)\n\nlinux 调用loader把prog代码和数据复制到内存，然后转移到程序开头。\n\n","n":0.204}}},{"i":344,"$":{"0":{"v":"Linker","n":1},"1":{"v":"\n# 主要功能\n\n1. 符号解析：将符号应用和符号定义关联起来\n2. 重定位：生成从地址0开始的代码和数据节\n\n## ELF (object file)\n\nexecutable and linkable format\n\n![](/assets/images/2021-04-21-22-03-08.png)\n\n. text The machine code of the compiled program .\n\n. rodata Read-only data such as the format strings in printf statements, and jump tables for switch statements.\n\n. data Initialized global and static C variables. Local C variables are maintained at run time on the stack and do not appear in either the .data or .bss sections.\n\n. bss Uninitialized global and static C variables, along with any global or static variables that are initialized to zero. This section occupies no actual space in the pbject file; it is merely a placeholder.\n\n. symtab A symbol table with information about functions and global variables that are defined and referenced in the program. \n\n. rel.text •A list of locations in the .text section that will need to be modified **when the linker combines this object file with others**. In general, any instruction that calls an external function or references a global variable will need to be modified. On the other hand, instructions that call local functions do not need to be modified. Note that relocation information is not needed in executable object files, and is usually omitted unless the user explicitly instructs the linker to include it.\n\n. rel.data Relocation information for any **global variables** that are referenced or defined by the module. In general, any initialized global variable whose initial value is the address of a global variable or externally defined function will need to be modified.\n\n. debug A debugging symbol table with entries for local variables and typedefs defined in the program, global variables defined and referenced in the program, and the original C source file. It is only present if the compiler driver is invoked with the -g option .\n\n. line A mapping between line numbers in the original C source program and machine code instructions in' the . text section. It is only pre~~nt if the ,.compiler driver is invoked with the -g option .\n\n. strtab A string table for the symbol tables in the . symtab and . debug sections and for. the section names in the section headers. A string table is a sequence of null-terminated character strings.\n\n\n## 符号和符号表\n\n- Global symbols that are defined by module m and that can be referenced by other modules.\n- Global symbols\"that are referenced by module m but defined by some other module.\n- Local symbols that are defined and referenced exclusively by module m.\n\n在符号解析时，编译器不会报错，认为这个函数定义在其他地方，linker在链接时找不到会报错\n\nRule 1. Multiple strong symbols with the same name are not allowed.\n\nRule 2. Given a strong symbol and multiple weak symbols with the same name, choose the strong symbol.\n\nRule 3. Given multiple weak symbols with the same name, choose any of the weak symbols.\n\n## 静态库 \n\n相关函数编译为独立的目标模块，封装成单独的静态库文件。linker值复制被程序引用的目标模块，减少了可执行文件在磁盘和内存中的大小。\n\n*.a 存档文件 -> *.o 只有相关的函数\n\n![](/assets/images/2021-04-21-22-09-54.png)\n\n## 动态库\n\n目标模块在运行或加载时，可以加载到任意内存地址。在静态链接时需要加载一些symbol table\n\n![](/assets/images/2021-04-21-22-11-14.png)\n\n## 重定位\n\n- 合并节和符号定义\n- 重定位符号引用\n\n\n## executable file\n\n![](/assets/images/2021-04-21-22-12-36.png)\n\n![](/assets/images/2021-04-21-22-12-54.png)\n\nEach' program in a Linux , system runs in the context of a process with its own virtual address space. When the shell runs a program, the parent shell process forks a child process that is a duplicate of the parent. The child process invokes the loader via the execve system call. The loader deletes the child's existing virtual memory segments and creates a neW set of code, data, heap, and stack segments, The new stack and heap segments are initialized to zero. The new code and data segments are initialized to the contents of the executable file by mapping pages in the virtual address space to page-size chunks of the executable file. Finally, the loader jumps to the start address, which eventually calls the application's main routine. Aside from some header information, there is no copying of data from disk to memory during loading. The copying is deferred until the CPU referencb a mapped virtual page, at which point the operating system automatically transfers the page from disk to memory using its paging mechanism.","n":0.04}}},{"i":345,"$":{"0":{"v":"Pipeline","n":1},"1":{"v":"\n执行一条命令有以下几步\n\n1. Instruction fetch\n2. Instruction decode and register fetch\n3. Execute\n4. Memory access\n5. Register write back\n\n\n## 分支预测\n\n## 加stall避免数据race","n":0.25}}},{"i":346,"$":{"0":{"v":"Multitask","n":1}}},{"i":347,"$":{"0":{"v":"Process","n":1},"1":{"v":"\n# process\n\n![](/assets/images/2021-05-11-20-16-21.png)\n\n是执行中程序的实例，系统中的每一个程序都运行在某个进程的上下文中，上下文是由程序正确运行所需状态组成的，这个状态包括存放内存中程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量，以及打开文件描述符的集合。每次用户通过shell输入一个可执行目标文件，shell就会创建新的进程。\n\nThe classic definition of a process is an instance of a program in execution. Each program in the system runs in the context of some process.The context consists of the state that the program needs to run correctly. This state includes the program's code and data stored in memory, its stack, the contents of its general-purpose registers, its program counter, environment variables, and the set of open file descriptors.\n\n进程是一个独立的逻辑控制流，轮流使用处理器的，每个进程执行流的一部分，然后被强占（preempted）,暂时被挂起。time slicing, concurrency\n\n每个process有私有的地址空间，代码段都从0x400000开始。\n\n内核调度一个新的进程，运行之后，它就会抢占当前进程，并使用一种上下文切换机制来将控制转移到新进程中。\n\n\n加载并运行程序使用execve函数。execve调用一次从不返回。加载filename之后，调用启动代码，设置栈，将控制传递给新程序的main。\n\nthe typical difference is that **threads** (of the same process) run in a **shared memory space**, while processes run in separate memory spaces. thread有自己的tid，栈，sp，pc，general register and flag, **the code, data and heap areas are shared**\n\n![](/assets/images/2022-04-19-19-44-28.png)\n\n## struct\n\n在Linux操作系统上运行的所有进程都是通过task_struct结构来管理的，其也被称为“进程描述符”。一个进程描述符包含了单个进程在运行期间所有必要的信息，比如进程标识、进程的属性、构建进程的资源等。如果知道进程的结构，就能了解进程的执行对性能的重要性。\n\n![](/assets/images/2022-04-19-19-32-18.png)\n\n![](/assets/images/2022-04-19-19-48-42.png)\n## process control\n\n进程控制：获取进程id。进程有三种状态：运行，停止(suspended) 收到SIGSTOP, SIGTSTP,SIGTTIN or SIGTTOU，直到收到SIGCONT继续。终止，收到终止进程的信号，从主程序返回，调用exit函数。\n进程创建用fork， 当一个进程由于某种原因终止时，内核并不是立刻把它从系统中清除，相反进程将会，被保持在一种已经终止的状态，直到被父进程回收。waitpid 等待子进程终止。进程休眠就是sleep。\n\n\n- run \n- suspend: A process stops as a result of receiving a SIGSTOP, SIGTSTP, SIGTI1N, or SIGTTOU signal, and it remains stopped until it receives a SIGCONT signal, at which point it becomes running again. \n- terminate： exit\n\n![[dendron://my_note/development.computer.call.fork]]\n## context switch\n\n![](/assets/images/2021-04-25-23-04-15.png)\n\nregisters是唯一被所有过程共享的资源，当调用时，把所有原始值压入栈中，改变寄存器的值，在返回之前从栈中弹出旧值。\n\nIt consists of the values of objects such as the general-purpose registers, the floating-point registers, the program counter, user's stack, status registers, kernel's stack, and various kernel data structures such as a page table that characterizes the address space, a process table that contains information about the current process, and a file table that contains information about the files that the process has opened.\n\nContext Switch 流程：上下文切换，第一，保存当前进程的上下文，第二，恢复某个先前被抢占的进程，被保存的上下文，第三，将控制传递给这个新恢复的进程。\n(1) saves the context of the current process, (2) restores the saved context of some previously preempted process, and (3) passes control to this newly restored process.\n \nThe context is the state that the kernel needs to restart a preempted process. It consists of the values of objects such as the **general-purpose registers, the floating-point registers, the program counter, user's stack, status registers, kernel's stack, and various kernel data structures such as a page table that characterizes the address space, a process table that contains information about the current process, and a file table that contains information about the files that the process has opened**.\n\n![](/assets/images/2022-04-19-19-47-02.png)\n## zombie process\n\nZombie process\nwhat is zombie process? When does it become zombie process?\n\n当进程由于某种原因终止时，内核不会立即清除，而是保持在一种已经终止的状态直至被父进程回收，一个终止未被回收的叫zombie。用waitpid函数等待子进程终止或停止。\n\nOn Unix and Unix-like computer operating systems, a zombie process or defunct process is a process that has completed execution (via the exit system call) but **still has an entry in the process table**: it is a process in the \"Terminated state\". This occurs for child processes, where the entry is still needed to allow the parent process to read its child's exit status: once the exit status is read via the wait system call, the zombie's entry is removed from the process table and it is said to be \"reaped\".\n","n":0.048}}},{"i":348,"$":{"0":{"v":"Signal","n":1},"1":{"v":"\n# signal\n\n![](/assets/images/2021-04-25-23-16-50.png)\n\n\n**信号允许进程和内核中断其他进程**，一个信号就是一条消息，他通知进程系统中发生了一个某种类型的事件。ctrl+c 是sigint， 终止信号是sigkill，ctrlz是 sigtstp。 发送信号可以用kill函数以及内核检测到一个系统事件。sigkill和sigstop不能捕捉，忽略和修改默认行为。\n\n信号处理程序，任何进程只能收到一个信号，并处理一个信号，如果一个进程有一个带出的信号，但是有其他的信号要被接收，都不会排队等待而简单的被抛弃。临时阻塞信号可以用sigprocmask。\n\nIn eval, the parent must use sigprocmask to block SIGCHLD, SIGINT, and SIGTSTP signals before it forks the child, and then unblock these signals, again using sigprocmask after it adds the child to the job list by calling addjob. Since children inherit the blockedvectors of their parents, the child must be sure to then unblock these signals before it executes the new program. The child should also restore the default handlers for the signals that are ignored by the shell.\n\n\n","n":0.108}}},{"i":349,"$":{"0":{"v":"Memory","n":1},"1":{"v":"\n[reference](https://gywbd.github.io/posts/2016/1/segmentation-fault.html)\n\n# phycical memory\n\n\nstack（栈）是一块用于保存函数调用信息——传递的参数、每个函数的本地变量的内存区域\n\nheap（堆）是一块程序可以任意使用的内存区域，程序员有完全自由的权限对这个区域进行任何想要的操作\n\nstack部分的大小在程序运行过程中是可变的。当函数调用发生时，stack就会扩大，当函数调用结束时：之前扩大的stack就会缩小为调用之前的样子\nheap同样也是一个大小可变的区域，当程序员从heap中请求内存（malloc()）时，heap就会扩大，当这些内存被释放后（free()），heap就会缩小。\nstack和heap都是可伸缩的区域，它们处于整个地址空间中的相对位置：stack会向下扩展（由高地址到低地址），而heap则会向上扩展（由低地址到高地址）。它们都是可以自由增长的区域，只是增长的方向刚好相反。操作系统只需要检查这两个区域不会出现重叠的情况，这是它们主要的使用限制。\n\n![](/assets/images/2021-04-05-23-02-01.png)\n\n\n一个分页（page）是物理内存（page frame）或虚拟内存中一组连续线性地址。Linux内核以内存页为单位处理内存。一个内存页通常是4KB大小。当一个进程请求一定数量内存页的时候，如果有有效的内存页，Linux内核立刻将它们分配给进程。否则，需要从一些其他的进程或分页缓存中得到。内核知道有多少内存页是有效的，并且也知道它们在什么位置。\n\n\n\n\n# virtaul memory\n\nThe virtual memory abstracts the details of physical memory from the application software, allows to keep only needed information in the physical memory (demand paging) and provides a mechanism for the protection and controlled sharing of data between processes.\n\n虚拟内存提供三个重要的能力，第一个把主存看作一个存储在磁盘上地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式高效的使用的主存，第二点，他为每个进程提供了一致的地址空间，从而简化了内存管理，第三它保护了每个进程地址空间，不被其他进程破坏。\n\n虚拟内存其实是在磁盘上，需要用的时候放到主存里。每个虚拟地址指向一个PTE, 包含有效位以及物理页号或者磁盘地址。缓存不命中是缺页，调用缺页异常处理程序，选择一个页面换成需要的页面。之后重新启动缺页异常的指令。重新地址翻译。可以利用TLB加速地址翻译或者使用多级页表。\n\n\n## VSZ - Virtual Set Size\n\nThe Virtual Set Size is a memory size assigned to a process ( program ) during the initial execution. The Virtual Set Size memory is simply a number of how much memory a process has available for its execution.\n\n## RSS - Resident Set Size\n\nAs opposed to VSZ ( Virtual Set Size ), RSS is a memory currently used by a process. This is a actual number in kilobytes of how much RAM the current process is using.\n\n## 缓存的工具\n\n每个字节有唯一的虚拟地址。\n\nvirutal page有三种类型\n\n- 未分配的：VM系统中未分配的页，不占任何磁盘空间\n- 缓存的：当前已缓存的在物理内存中的已分配页\n- 未缓存的：未缓存在物理内存中的已分配页\n\n![](/assets/images/2021-05-03-19-20-38.png)\n\nDRAM 比 SRAM(L1,L2,L3)慢10倍，虚拟页比较大。, DRAM caches always use write-back instead of write-through.\n\nIn write through, data is simultaneously updated to cache and memory. \nwrite back: The data is updated only in the cache and updated into the memory in later time. \n\n通过mmu, 页表(page table)判断一个虚拟页是否缓存在DRAM中的某一个地方，mmu把VP->PP\n\nPTE(page table entry) 有效位表明当前VP是否缓存在DRAM\n\n![](/assets/images/2021-05-03-19-25-39.png)\n\n页命中：如果有效，可以获得物理地址\n\n缺页：page fault，调用内核缺页处理程序。程序选择一个牺牲页，修改DRAM，把磁盘里的VP复制到DRAM，重新启动缺页的指令，把导致缺页的虚拟地址重新发到MMU，命中。\n\nThe activity of transferring a page between disk and memorf is known as swapping or paging. Pages are swapped in (paged in) from disk to DRAM, anct swapped out (paged out) from DRAM to disk\n### swap\n\n- What is swap, when will it be used?\nSwap space is located on hard drives for inactive pages in memory\nSwapping is the process whereby a page of memory is copied to the preconfigured space on the hard disk,\ncalled swap space, to free up that page of memory.\n\n- What's the situation that a process will swap\nSwap space in Linux is used when the amount of physical memory (RAM) is full.\nIf the system needs more memory resources and the RAM is full,\ninactive pages in memory are moved to the swap space.\n\n- What's the down side of swap?\nSwap space is located on hard drives, which have a slower access time than physical memory.\n \n## 内存管理\n\n不同进程里的VP可以共享一个PP。简化linking，loading，share，内存分配\n\n两个进程将私有对象映射到它们的虚拟内存的不同区域，但是共享这个对象，统一个物理副本，对于每个应设是有对象的进程，相应的所有区域的业表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要没有进程，试图修改他们自己的私有区域，他们就可以继续共享物理内存对象的一个单独副本，但是只要有一个进程，试图写私有区域内的某个页面，他就会复制一个新的，在那个里面写。\n\n## 内存保护\n\n在page table有许可位，判定这个page的访问权限。\n\n## 地址翻译 mmu\n\nMMU memory management unit.\nThe mapping between virtual address and physical address.\n\n![](/assets/images/2021-04-05-22-38-37.png)\n\n当一个用户级进程想访问一些内存，它会产生一个访问请求，MMU会把请求的虚拟地址转换为对应的物理内存地址。但是如果这个地址访问存在错误：转换后的物理地址超出了物理段的界限，或者违反了段保护权限（例如请求向只读段中写入数据），此时默认情况下操作系统会产生一个表示需要进行错误处理的信号：SIGSEGV，对这个信号的默认处理行为（default handler）是杀死（kill）这个进程，并且输出一个消息：“Segmentation fault”。\n\n![](/assets/images/2021-05-03-19-35-51.png)\n## TLB\n\n快速重编址缓冲器（Translation-lookaside Buffer : TLB）\n\n在每次虚拟内存访问时都会使用MMU，它会先从地址中提取出VPN，然后根据这个VPN查找TLB中是否有对应的VPN。如果命中（hit），它会直接返回TLB中记录的对应的物理地址，完成它的使命。如果没有命中（miss），那么它会查找进程的页表，如果对这个物理地址的访问是合法的，那么它会更新TLB，那么之后再访问这个虚拟地址，就会命中了。\n\n![](/assets/images/2021-05-03-19-36-10.png)\n\n## multi-level page table\n\n![](/assets/images/2021-05-03-19-42-35.png)\n\n## os\n\n- 不同进程共享同一个物理page\n- 写时复制，一开始指向同一个，改变一个的时候copy另一个\n\n![](/asets/images/2021-05-03-19-46-33.png)\n\n### heap\n\n![](/assets/images/2021-05-03-19-47-09.png)\n\n- malloc\n- free\n\n在头部和尾部都有a/f表示 上一个/下一个是不是allocate，常数时间合并空闲块\n\n### 垃圾收集\n\nA garbage collector is a dynamic storage allocator that automatically frees allocated blocks that are no longer needed by the program.\n\n有一些根节点可以到达堆节点\n\n![](/assets/images/2021-05-03-19-50-10.png)\n\n","n":0.052}}},{"i":350,"$":{"0":{"v":"Tools","n":1},"1":{"v":"\n# ulimit \n\n“ulimit” is an interesting Linux shell command that can set or report the resource limit of the current user.\n\nThere are 2 types of resource limitation: “hard” and “soft”. Hard resource limit defines the physical limit that the user can reach. The “soft” resource limit is manageable by the user. Its value can go up to the “hard” limit.","n":0.129}}},{"i":351,"$":{"0":{"v":"Overcommit","n":1},"1":{"v":"\nOvercommit refers to the practice of giving out virtual memory with no guarantee that physical storage for it exists. To make an analogy, it's like using a credit card and not keeping track of your purchases. A system performing overcommit just keeps giving out virtual memory until the debt collector comes calling — that is, until some program touches a previously-untouched page, and the kernel fails to find any physical memory to instantiate it — and then stuff starts crashing down.","n":0.111}}},{"i":352,"$":{"0":{"v":"Namespace","n":1},"1":{"v":"\n# kernal space, user space\n\n为什么Kernel和User Space 分开（因为安全啊）。为什么Kernel不能只检查User 是否有call system function的权限（因为还要检查user 是否还要touch合法的地址，参数类型等，反例是buffer overflow） \n \nKernel space is where the kernel (i.e., the core of the operating system) executes (i.e., runs) and provides its services.\n \nUser space is that set of memory locations in which user processes (i.e., everything other than the kernel) run. A process is an executing instance of a program. One of the roles of the kernel is to manage individual user processes within this space and to prevent them from interfering with each other.\n \nProcessors typically provide this capability with a mode: bit in some control register that characterizes the privileges that the process currently enjoys. When the mode bit is set, the process is running in kernel mode (sometimes called supervisor mode). A process running in kernel mode can execute any instruction in the instruction and access any memory location in the system.\n\n## namespaces\n\n","n":0.082}}},{"i":353,"$":{"0":{"v":"Malloc","n":1},"1":{"v":"\nWhen user space applications call malloc(), that call isn't implemented in the kernel. Instead, it's a library call (implemented glibc or similar).\n\nThe short version is that the malloc implementation in glibc either obtains memory from the brk()/sbrk() system call or anonymous memory via mmap(). This gives glibc a big contiguous (regarding virtual memory addresses) chunk of memory, which the malloc implementation further slices and dices in smaller chunks and hands out to your application.\n\nHere's a small malloc implementation that'll give you the idea, along with many, many links.\n\nNote that nothing cares about physical memory yet -- that's handled by the kernel virtual memory system when the process data segment is altered via brk()/sbrk() or mmap(), and when the memory is referenced (by a read or write to the memory).\n\nTo summarize:\n\nmalloc() will search its managed pieces of memory to see if there's a piece of unused memory that satisfy the allocation requirements.\nFailing that, malloc() will try to extend the process data segment(via sbrk()/brk() or in some cases mmap()). sbrk() ends up in the kernel.\nThe brk()/sbrk() calls in the kernel adjust some of the offsets in the struct mm_struct of the process, so the process data segment will be larger. At first, there will be no physical memory mapped to the additional virtual addresses which extending the data segment gave.\nWhen that unmapped memory is first touched (likely a read/write by the malloc implementation) a fault handler will kick in and trap down to the kernel, where the kernel will assign physical memory to the unmapped memory.\n","n":0.063}}},{"i":354,"$":{"0":{"v":"Linux","n":1},"1":{"v":"![](/assets/images/2022-04-19-19-52-20.png)\n\n应用程序通常不直接向磁盘子系统写入，而是向高速缓存（cache）或者缓冲区（buffer）写入。当时间片到达时，或者一个文件的大小超出缓冲缓存时，内核线程pdflush/Per-BDI flush会将缓存／缓冲中的数据刷新到磁盘中。\n\n# 伙伴系统（buddy system）\n\nLinux内核使用一种被称为伙伴系统（buddy system）的机制来维护它的空闲分页。伙伴系统维护空闲分页，并尝试给分页分配请求分配分页。它试图保持内存区域是连续的。如果不考虑分散的小分页，这可能会导致内存碎片，并会导致更加难以在连续的区域中分配一个很大的分页。它也可能导致低效的内存使用和性能下降。\n\n当分配分页失败时，会进行分页回收。\n\n![](/assets/images/2022-04-19-19-54-11.png)\n\n# 分页回收\n\n当一个进程请求映射一定数量分页的时候，如果没有有效的分页，Linux内核将尝试释放一定数量的分页（这是之前使用但是不再使用且基于某些原因仍被标记为活跃的分页），然后将这些分页分配给新的请求内存的进程。这个过程被称为分页回收（page reclaiming）。内核线程kswapd和内核函数try_to_free_page()负责分页回收。\n\nkswapd在任务中通常处于可中断睡眠状态，当区域中的空闲分页低于一个阀值时它被称为伙伴系统。基于最近最少使用（Least Recently Used, LRU）原则，它试图找到候选分页并将其取出作为活跃分页。最近最少使用的分页被首先释放。活跃列表和非活跃列表用于维护候选分页。kswapd扫描活跃列表，并检查最近使用的分页，将最近没有使用的分页放入非活跃列表中。可以通过vmstat -a 命令查看活跃和非活跃的内存有多少。","n":0.289}}},{"i":355,"$":{"0":{"v":"Cgroup","n":1},"1":{"v":"\nA control group (cgroup) is a Linux kernel feature that limits, accounts for, and **isolates the resource usage** (CPU, memory, disk I/O, network, and so on) of a collection of processes.\n\nCgroups provide the following features:\n\n- Resource limits – You can configure a cgroup to limit how much of a particular resource (memory or CPU, for example) **a process can use**.\n- Prioritization – You can control how much of a resource (CPU, disk, or network) a process can use compared to processes in another cgroup when there is resource contention.\n- Accounting – Resource limits are monitored and reported at the cgroup level.\n- Control – You can change the status (frozen, stopped, or restarted) of all processes in a cgroup with a single command.\n\n# how to configure\n\nThe following command creates a v1 cgroup (you can tell by pathname format) called foo and sets the memory limit for it to 50,000,000 bytes (50 MB).\n\n```\nroot # mkdir -p /sys/fs/cgroup/memory/foo\nroot # echo 50000000 > /sys/fs/cgroup/memory/foo/memory.limit_in_bytes\n```\n\nI start test.sh in the background and its PID is reported as 2428. The script produces its output and then I assign the process to the cgroup by piping its PID into the cgroup file /sys/fs/cgroup/memory/foo/cgroup.procs.\n```\nroot # ./test.sh &\n[1] 2428\nroot # cgroup testing tool\nroot # echo 2428 > /sys/fs/cgroup/memory/foo/cgroup.procs\n```","n":0.069}}},{"i":356,"$":{"0":{"v":"Io","n":1},"1":{"v":"\n# file\n\nfile是一个m个字节的序列。所以I/O设备被模型化为文件，输入输出变成读和写。\n\n## 打开文件\n\napp通过要求内核打开相应文件，访问一个I/O设备，内核返回一个小的非负整数，叫做描述符。内核记录有关这个文件的信息，app只记住这个描述符。\n\n创建进程都有三个打开的文件，stdin，stdout，stderr。\n\n改变当前文件位置，对于每个打开的文件，内核保持一个文件位置k，是从文件开始的字节偏移量。通过seek设置当前位置k。\n\n## 读写文件\n\n- 读：从文件复制n>0到内存，从当前位置k增加到k+n，当到末尾，触发EOF\n- 写：从内存复制到n>0到一个文件，从k开始\n\n\n# file type\n\n- regular file: text and binary\n- directory: 包含一组link的文件，将filename link to one file。至少包括“.” and “..”\n- socket: 与另一个进程进行网络通讯\n\n\n# 数据结构\n\n![](/assets/images/2021-05-03-19-57-58.png)\n\n- 描述符表： 每个进程独立\n- 文件表：打开文件集合，所有进程共享，当前文件位置，引用计数以及指向v-node表中对应的指针\n- v-node:所有进程共享，包含stat结构中的信息\n\nfor fork\n\n![](/assets/images/2021-05-03-20-05-52.png)\n\n## 重定向\n\ndup2 复制oldfd到newfd，删除老的file table item，新的reference count+=1，老的v-node删除\n","n":0.171}}},{"i":357,"$":{"0":{"v":"Functioncall","n":1},"1":{"v":"\n# 过程\n\n1. 传递过程： 在进入过程Q时，程序计数器设置成Q的代码起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。\n2. 传递数据：P必须能向Q提供一个或多个参数，Q必须向P返回一个值\n3. 分配和释放内存。在开始时Q可能需要为局部变量分配空间，而在返回前又释放这些内存。\n\n## 栈\n\n![](/assets/images/2021-04-17-17-39-13.png)\n\n1. 转移控制：把地址A压入栈，PC设置为Q的起始位置\n2. 数据传送：寄存器 %rdi，%rsi，在进入新的过程时压栈。\n3. 本地数据存在栈里","n":0.302}}},{"i":358,"$":{"0":{"v":"Exception_handle","n":1},"1":{"v":"\n# exception\n\n在控制流中的突变，用来响应处理器状态中的变化。\n\n当有事件(event),通过一张异常表的跳转表，进行了一个间接过程调用（异常），到一个专门设计用来处理这类事件的子程序（exception handler)\n\n![](/assets/images/2021-04-25-22-27-49.png)\n\n每种异常有一个异常号，到跳转表。\n\n与过程调用不同，压入栈的可能是当前指令或下一条指令。如果控制从用户->内核，项目压到内核栈而不是用户栈。\n\n## 几种exception\n\n- interrupt: 由I/O 设备信号，异步。I/O 将某个引脚电位拉高，cpu执行完发现电位上升，执行中断放异常号到总线\n- trap：将控制返回下一条，同步，提供用户与内核的系统调用。\n- fault/abort\n  - segment fault: 引用了未定义的虚拟内存区域，尝试写一个只读的文本段\n\n![](/assets/images/2021-04-25-22-34-15.png)\n![](/assets/images/2021-04-25-22-34-24.png)","n":0.267}}},{"i":359,"$":{"0":{"v":"Call","n":1},"1":{"v":"\n# system call\n\nIn computing, a system call is the programmatic way in which a computer program requests a service from the kernel of the operating system it is executed on.\n\n流程：\n\n- Application program makes a system call. When I write the program in ARM. I used SWI instruction. SWI means software interrupt exception. SWI will cause an interrupt. So the kernel will handle this interrupt. The handler is called SWI hander.\n- Stack is used to pass these arguments to the function in the kernel.\n- Each system call has a unique call number which is used by kernel to identify which system call is invoked.\n- Now the SWI handler executes a specific instruction (int 0x80). This instruction causes the processor to switch from 'User Mode' to 'Kernel Mode'\n- kernel invokes system_call() routine\n- This function saves register values onto kernel stack and does some validations like verifying system call number etc.\n- A map of system call number as key and the appropriate system call as value exists. This is called system_call_table. The handler uses this table to invoke appropriate system call service routine. It also validates the arguments if present.\n- After proper validations, the service routine performs required actions. After all these actions, service routine returns status of execution to user mode call.\n","n":0.069}}},{"i":360,"$":{"0":{"v":"Fork","n":1},"1":{"v":"\nsystem call\n\nfork函数调用一次，返回两次，并发执行，**相同但是独立的地址空间**。相同代码和数据段、堆、共享库以及用户栈，共享文件，最大区别是父和子有不同的pid。\n\n对所有fork 拓扑排序，可以得到一个输出顺序。\n\nfork为当前进程调用，是内核，为新进程创建各种数据结构，并分配给他一个唯一的pid.为了给这个新进程创建虚拟内存，它创建当前进程的mm_struct, 区域结构和页表的原样副本，他将两个进程中的每个页面都标记为只读，并将两个进程中每个区域结构都标记为私有的写时复制 copy on write。\n\nCopy-on-write or COW: when a write request is made, the data are copied into a new storage area, and then the original data are modified.\n\n![](/assets/images/2022-04-19-19-34-30.png)","n":0.18}}},{"i":361,"$":{"0":{"v":"Execve","n":1},"1":{"v":"\n加载并运行可执行目标文件，调用一次从不返回。\n\n\nexecve使用新的程序，有效替代当前程序，加载并运行，可执行目标程序需要以下几个步骤，第一点删除已存在的用户区域，第二点映射私有区域，为新程序区域创建新的区域结构。所以我现在去都是私有的，写时复制的。第三点应设共享区域。还要设置程序计数器，使之指向代码区的入口点。","n":1}}},{"i":362,"$":{"0":{"v":"Cache","n":1},"1":{"v":"\n# cache\n\n用(S, E, B, m)表示，m是计算机的位数，s是组的个数，E是每组E行，B是块的大小\n\n![](/assets/images/2021-04-21-21-54-22.png)\n\nt用来找组里的哪一行\n\ns是组索引\n\nb是块偏移\n\n中位索引可以防止数据被整体换入换出\n# buffer and cache\n\n[link](https://stackoverflow.com/questions/6345020/what-is-the-difference-between-buffer-vs-cache-memory-in-linux)\n \nBuffers are associated with a specific block device, and cover caching of filesystem metadata as well as tracking in-flight pages. The cache only contains parked file data. That is, the buffers remember what's in directories, what file permissions are, and keep track of what memory is being written from or read to for a particular block device. The cache only contains the contents of the files themselves.","n":0.115}}},{"i":363,"$":{"0":{"v":"Boot","n":1},"1":{"v":"\n# boot process\n\n![](/assets/images/2021-04-05-22-42-45.png)\n\nWhat happened when I press the power-on button of Linux operating system, i.e., what happened during the bootstrap process of Linux?\n1. BIOS\n\n- BIOS stands for Basic Input/output System\n- Performs some system integrity checks\n- Searches, loads, and executes the boot loader program.\n- It looks for boot loader in floppy, cd-rom, or hard drive. You can press a key (typically F12 of F2, but it depends on your system) during the BIOS startup to change the boot sequence.\n- Once the boot loader program is detected and loaded into the memory, BIOS gives the control to it. And the boot loader program is MBR, Master Boot Record.\n\n读取其中所存储的程序。这一程序通常知道一些直接连接在主板上的硬件(硬盘，网络接口，键盘，串口，并口)。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。\n\n2. MBR\n- It is in the 1st sector of the bootable disk.\n- The MBR holds the information on how the logical partitions, containing file systems, are organized on that medium.\n- So MBR will tell computer to read boot loader from one specific partition.\n- Typical boot loader include GRUB, LILO.\n下一步，计算机将从你所选择的存储设备中读取起始的512个字节(bytes)。如果我们从光盘启动的话，那么计算机就会读取光盘最开始的512个字节。这512个字节叫做主引导记录MBR (master boot record)。MBR会告诉电脑从该设备的某一个分区(partition)来装载引导加载程序(boot loader)。引导加载程序储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (内核)所在位置等。常用的引导加载程序有GRUB和LILO。 \n3. GRUB\n- GRUB stands for Grand Unified Bootloader. It will help us load the kernel.\nGRUB displays a splash screen, waits for few seconds, if you don’t enter anything, it loads the default kernel image as specified in the grub configuration file.\nGRUB has the knowledge of the filesystem (the older Linux loader LILO didn’t understand filesystem).\nGrub configuration file is /boot/grub/grub.conf (/etc/grub.conf is a link to this). The following is sample grub.conf of CentOS.\n\n4. Kernel\n- Kernel executes the /sbin/init program\n- Kernel will reserve some space for itself to run and use driver to detect computer hardware.\n- Then it executes init. init was the 1st program to be executed by Linux Kernel, it has the process id (PID) of 1.\n如果我们加载的是Linux内核，Linux内核开始工作。内核会首先预留自己运行所需的内存空间，然后通过驱动程序(driver)检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，内核会启动一个init进程。它是Linux系统中的1号进程(Linux系统没有0号进程)。到此，内核就完成了在计算机启动阶段的工作，交接给init来管理。\n5. init process\n- Init will run some start up scripts. For example, configure the name of the computer, configure time zone, detect the file system, mount some hard drive, configure the network, activate raid, etc.\n- Then it will give the login dialogue box to prompt login.\n随后，init会运行一系列的初始脚本(startup scripts)，这些脚本是Linux中常见的shell scripts。这些脚本执行如下功能：\n\n设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……\n当这些初始脚本，操作系统已经完全准备好了，只是，还没有人可以登录。init会给出登录(login)对话框，或者是图形化的登录界面。\n\nIn Unix-based computer operating systems, init (short for initialization) is the first process started during booting of the computer system. Init is a daemon process that continues running until the system is shut down. It is the direct or indirect ancestor of all other processes and automatically adopts all orphaned processes. Init is started by the kernel during the booting process; a kernel panic will occur if the kernel is unable to start it. Init is typically assigned process identifier 1.\n","n":0.05}}},{"i":364,"$":{"0":{"v":"Cloud","n":1}}},{"i":365,"$":{"0":{"v":"Messaging","n":1}}},{"i":366,"$":{"0":{"v":"Pattern","n":1},"1":{"v":"\n# Asynchronous Request-Reply\n\nDecouple backend processing from a frontend host, where backend processing needs to be asynchronous, but the frontend still needs a clear response.\n\nOne solution to this problem is to use HTTP polling. Polling is useful to client-side code, as it can be hard to provide call-back endpoints or use long running connections. Even when callbacks are possible, the extra libraries and services that are required can sometimes add too much extra complexity.\n\n- The client application makes a synchronous call to the API, triggering a long-running operation on the backend.\n- The API responds synchronously as quickly as possible. It returns an HTTP 202 (Accepted) status code, acknowledging that the request has been received for processing.\n- The response holds a location reference pointing to an endpoint that the client can poll to check for the result of the long running operation.\n- The API offloads processing to another component, such as a message queue.\n- While the work is still pending, the status endpoint returns HTTP 202.\n\n![](/assets/images/2021-05-10-22-21-30.png)\n\n- At some point, the work is complete and the status endpoint returns 302 (Found) redirecting to the resource.\n- The client fetches the resource at the specified URL.\n\n![](/assets/images/2021-05-10-22-21-54.png)\n\n# Claim Check\n\nSplit a large message into a claim check and a payload. Send the claim check to the messaging platform and store the payload to an external service. This pattern allows large messages to be processed, while protecting the message bus and the client from being overwhelmed or slowed down. This pattern also helps to reduce costs, as storage is usually cheaper than resource units used by the messaging platform.\n\n![](/assets/images/2021-05-10-22-26-15.png)\n\nStore the entire message payload into an external service, such as a database. Get the reference to the stored payload, and send just that reference to the message bus. The reference acts like a claim check used to retrieve a piece of luggage, hence the name of the pattern. Clients interested in processing that specific message can use the obtained reference to retrieve the payload, if needed.\n\n# Choreography\n\nHave each component of the system participate in the decision-making process about the workflow of a business transaction, instead of relying on a central point of control.\n\n![](/assets/images/2021-05-10-22-27-37.png)\n\nA client request publishes messages to a message queue. As messages arrive, they are pushed to subscribers, or services, interested in that message. Each subscribed service does their operation as indicated by the message and responds to the message queue with success or failure of the operation. In case of success, the service can push a message back to the same queue or a different message queue so that another service can continue the workflow if needed. If an operation fails, the message bus can retry that operation.\n\n\n# Competing Consumers\n\nEnable multiple concurrent consumers to process messages received on the same messaging channel. This enables a system to process multiple messages concurrently to optimize throughput, to improve scalability and availability, and to balance the workload.\n\n\n![](/assets/images/2021-05-10-22-30-54.png)\n\nThe application posts requests in the form of messages to the queue, and the consumer service instances receive messages from the queue and process them. This approach enables the same pool of consumer service instances to handle messages from any instance of the application.\n\nThis solution has the following benefits:\n\nIt provides a load-leveled system that can handle wide variations in the volume of requests sent by application instances. The queue acts as a buffer between the application instances and the consumer service instances. This can help to minimize the impact on availability and responsiveness for both the application and the service instances, as described by the Queue-based Load Leveling pattern. Handling a message that requires some long-running processing doesn't prevent other messages from being handled concurrently by other instances of the consumer service.\n\nIt improves reliability. If a producer communicates directly with a consumer instead of using this pattern, but doesn't monitor the consumer, there's a high probability that messages could be lost or fail to be processed if the consumer fails. In this pattern, messages aren't sent to a specific service instance. A failed service instance won't block a producer, and messages can be processed by any working service instance.\n\nIt doesn't require complex coordination between the consumers, or between the producer and the consumer instances. The message queue ensures that each message is delivered at least once.\n\nIt's scalable. The system can dynamically increase or decrease the number of instances of the consumer service as the volume of messages fluctuates.\n\nIt can improve resiliency if the message queue provides transactional read operations. If a consumer service instance reads and processes the message as part of a transactional operation, and the consumer service instance fails, this pattern can ensure that the message will be returned to the queue to be picked up and handled by another instance of the consumer service.\n\n# Priority Queue\n\nPrioritize requests sent to services so that requests with a higher priority are received and processed more quickly than those with a lower priority. This pattern is useful in applications that offer different service level guarantees to individual clients.\n\n![](/assets/images/2021-05-10-22-33-12.png)\n\nA queue is usually a first-in, first-out (FIFO) structure, and consumers typically receive messages in the same order that they were posted to the queue. However, some message queues support priority messaging. The application posting a message can assign a priority and the messages in the queue are automatically reordered so that those with a higher priority will be received before those with a lower priority\n\n\n# Publisher-Subscriber\n\nEnable an application to announce events to multiple interested consumers asynchronously, without coupling the senders to the receivers.\n\n![](/assets/images/2021-05-10-22-34-05.png)\n\n# Queue-Based Load Leveling\n\nUse a queue that acts as a buffer between a task and a service it invokes in order to smooth intermittent heavy loads that can cause the service to fail or the task to time out. This can help to minimize the impact of peaks in demand on availability and responsiveness for both the task and the service.\n\n![](/assets/images/2021-05-10-22-35-25.png)\n\n# Scheduler Agent Supervisor\n\nCoordinate a set of distributed actions as a single operation. If any of the actions fail, try to handle the failures transparently, or else undo the work that was performed, so the entire operation succeeds or fails as a whole. This can add resiliency to a distributed system, by enabling it to recover and retry actions that fail due to transient exceptions, long-lasting faults, and process failures.\n\n\n\n![](/assets/images/2021-05-10-22-36-25.png)\n\n- The Scheduler arranges for the steps that make up the task to be executed and orchestrates their operation. \n- The Agent contains logic that encapsulates a call to a remote service, or access to a remote resource referenced by a step in a task. \n- The Supervisor monitors the status of the steps in the task being performed by the Scheduler. It runs periodically (the frequency will be system-specific), and examines the status of steps maintained by the Scheduler. If it detects any that have timed out or failed, it arranges for the appropriate Agent to recover the step or execute the appropriate remedial action\n\n![](/assets/images/2021-05-10-22-37-41.png)\n\n# Sequential Convoy\n\nProcess a set of related messages in a defined order, without blocking processing of other groups of messages.\n\n\nPush related messages into categories within the queuing system, and have the queue listeners lock and pull only from one category, one message at a time.\n\n![](/assets/images/2021-05-10-22-38-54.png)\n\nIn the queue, messages for different categories may be interleaved, as shown in the following diagram:\n\n![](/assets/images/2021-05-10-22-39-00.png)","n":0.029}}},{"i":367,"$":{"0":{"v":"Design","n":1}}},{"i":368,"$":{"0":{"v":"Pattern","n":1},"1":{"v":"\n[reference](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/design-implementation)\n\n# Ambassador\n\nCreate helper services that send network requests on behalf of a consumer service or application. An ambassador service can be thought of as an out-of-process proxy that is co-located with the client.\n\nThis pattern can be useful for offloading common client connectivity tasks such as monitoring, logging, routing, security (such as TLS), and resiliency patterns in a language agnostic way. It is often used with legacy applications, or other applications that are difficult to modify, in order to extend their networking capabilities. It can also enable a specialized team to implement those features.\n\nPut client frameworks and libraries into an external process that acts as a proxy between your application and external services. Deploy the proxy on the same host environment as your application to allow control over routing, resiliency, security features, and to avoid any host-related access restrictions. You can also use the ambassador pattern to standardize and extend instrumentation. The proxy can monitor performance metrics such as latency or resource usage, and this monitoring happens in the same host environment as the application.\n\n![](/assets/images/2021-05-09-23-18-43.png)\n\n![](/assets/images/2021-05-10-21-02-50.png)\n\n# Anti-Corruption Layer pattern\n\nThis layer translates requests that one subsystem makes to the other subsystem. Use this pattern to ensure that an application's design is not limited by dependencies on outside subsystems. \n\nIsolate the different subsystems by placing an anti-corruption layer between them. This layer translates communications between the two systems, allowing one system to remain unchanged while the other can avoid compromising its design and technological approach.\n\n![](/assets/images/2021-05-10-21-04-52.png)\n\nUse this pattern when:\n\n- A migration is planned to happen over multiple stages, but integration between new and legacy systems needs to be maintained.\n- Two or more subsystems have different semantics, but still need to communicate.\n\n# Backends for Frontends pattern\n\nCreate separate backend services to be consumed by specific frontend applications or interfaces. \n\n![](/assets/images/2021-05-10-21-16-24.png)\n\nBecause each backend is specific to one interface, it can be optimized for that interface. As a result, it will be smaller, less complex, and likely faster than a generic backend that tries to satisfy the requirements for all interfaces. Each interface team has autonomy to control their own backend and doesn't rely on a centralized backend development team. This gives the interface team flexibility in language selection, release cadence, prioritization of workload, and feature integration in their backend.\n\n# Compute Resource Consolidation pattern\n\nonsolidate multiple tasks or operations into a single computational unit. This can increase compute resource utilization, and reduce the costs and management overhead associated with performing compute processing in cloud-hosted applications.\n\nTasks can be grouped according to criteria based on the features provided by the environment and the costs associated with these features. A common approach is to look for tasks that have a similar profile concerning their scalability, lifetime, and processing requirements. Grouping these together allows them to scale as a unit. The elasticity provided by many cloud environments enables additional instances of a computational unit to be started and stopped according to the workload.\n\n# External Configuration Store pattern\n\nMove configuration information out of the application deployment package to a centralized location. This can provide opportunities for easier management and control of configuration data, and for sharing configuration data across applications and application instances.\n\nStore the configuration information in external storage, and provide an interface that can be used to quickly and efficiently read and update configuration settings. The type of external store depends on the hosting and runtime environment of the application. In a cloud-hosted scenario it's typically a cloud-based storage service, but could be a hosted database or other system.\n\nThe backing store you choose for configuration information should have an interface that provides consistent and easy-to-use access. It should expose the information in a correctly typed and structured format. The implementation might also need to authorize users’ access in order to protect configuration data, and be flexible enough to allow storage of multiple versions of the configuration\n\n![](/assets/images/2021-05-10-21-22-53.png)\n\n# Gateway Aggregation pattern\n\nUse a gateway to aggregate multiple individual requests into a single request. This pattern is useful when a client must make multiple calls to different backend systems to perform an operation.\n\n![](/assets/images/2021-05-10-21-24-17.png)\n\nThis pattern can reduce the number of requests that the application makes to backend services, and improve application performance over high-latency networks.\n\n# Gateway Offloading pattern\n\nOffload shared or specialized service functionality to a gateway proxy. This pattern can simplify application development by moving shared service functionality, such as the use of SSL certificates, from other parts of the application into the gateway.\n\nOffload some features into a gateway, particularly cross-cutting concerns such as certificate management, authentication, SSL termination, monitoring, protocol translation, or throttling.\n\nThe following diagram shows a gateway that terminates inbound SSL connections. It requests data on behalf of the original requestor from any HTTP server upstream of the gateway.\n\n![](/assets/images/2021-05-10-21-27-11.png)\n\n- Simplify the development of services by removing the need to distribute and maintain supporting resources, such as web server certificates and configuration for secure websites. Simpler configuration results in easier management and scalability and makes service upgrades simpler.\n\n- Allow dedicated teams to implement features that require specialized expertise, such as security. This allows your core team to focus on the application functionality, leaving these specialized but cross-cutting concerns to the relevant experts.\n\n- Provide some consistency for request and response logging and monitoring. Even if a service is not correctly instrumented, the gateway can be configured to ensure a minimum level of monitoring and logging.\n\n# Gateway Routing pattern\n\nRoute requests to multiple services using a single endpoint. This pattern is useful when you wish to expose multiple services on a single endpoint and route to the appropriate service based on the request.\n\n![](/assets/images/2021-05-10-21-30-11.png)\n\nWith this pattern, the client application only needs to know about and communicate with a single endpoint. If a service is consolidated or decomposed, the client does not necessarily require updating. It can continue making requests to the gateway, and only the routing changes.\n\n# Leader Election pattern\n\nCoordinate the actions performed by a collection of collaborating instances in a distributed application by electing one instance as the leader that assumes responsibility for managing the others. This can help to ensure that instances don't conflict with each other, cause contention for shared resources, or inadvertently interfere with the work that other instances are performing.\n\nThe system must provide a robust mechanism for selecting the leader. This method has to cope with events such as network outages or process failures. In many solutions, the subordinate task instances monitor the leader through some type of heartbeat method, or by polling. If the designated leader terminates unexpectedly, or a network failure makes the leader unavailable to the subordinate task instances, it's necessary for them to elect a new leader.\n\n\nThere are several strategies for electing a leader among a set of tasks in a distributed environment, including:\n\n- Selecting the task instance with the lowest-ranked instance or process ID.\n- Racing to acquire a shared, distributed mutex. The first task instance that acquires the mutex is the leader. However, the system must ensure that, if the leader terminates or becomes disconnected from the rest of the system, the mutex is released to allow another task instance to become the leader.\n- Implementing one of the common leader election algorithms such as the Bully Algorithm or the Ring Algorithm. These algorithms assume that each candidate in the election has a unique ID, and that it can communicate with the other candidates reliably.\n\n# Pipes and Filters pattern\n\nDecompose a task that performs complex processing into a series of separate elements that can be reused. This can improve performance, scalability, and reusability by allowing task elements that perform the processing to be deployed and scaled independently.\n\nBreak down the processing required for each stream into a set of separate components (or filters), each performing a single task. By standardizing the format of the data that each component receives and sends, these filters can be combined together into a pipeline. \n\n![](/assets/images/2021-05-10-21-37-14.png)\n\n![](/assets/images/2021-05-10-21-37-40.png)\n\n# Sidecar pattern\n\nDeploy components of an application into a separate process or container to provide isolation and encapsulation. This pattern can also enable applications to be composed of heterogeneous components and technologies.\n\n![](/assets/images/2021-05-10-22-12-00.png)\n\nAdvantages of using a sidecar pattern include:\n\nA sidecar is independent from its primary application in terms of runtime environment and programming language, so you don't need to develop one sidecar per language.\n\nThe sidecar can access the same resources as the primary application. For example, a sidecar can monitor system resources used by both the sidecar and the primary application.\n\nBecause of its proximity to the primary application, there’s no significant latency when communicating between them.\n\nEven for applications that don’t provide an extensibility mechanism, you can use a sidecar to extend functionality by attaching it as its own process in the same host or sub-container as the primary application.","n":0.027}}},{"i":369,"$":{"0":{"v":"Database","n":1}}},{"i":370,"$":{"0":{"v":"Pattern","n":1},"1":{"v":"\n# cache-aside pattern\n\nLoad data on demand into a cache from a data store. This can improve performance and also helps to maintain consistency between data held in the cache and data in the underlying data store.\n\nMany commercial caching systems provide read-through and write-through/write-behind operations. In these systems, an application retrieves data by referencing the cache. If the data isn't in the cache, it's retrieved from the data store and added to the cache. Any modifications to data held in the cache are automatically written back to the data store as well.\n\nFor caches that don't provide this functionality, it's the responsibility of the applications that use the cache to maintain the data.\n\nAn application can emulate the functionality of read-through caching by implementing the cache-aside strategy. This strategy loads data into the cache on demand. The figure illustrates using the Cache-Aside pattern to store data in the cache.\n\n\n![](/assets/images/2021-05-09-22-49-50.png)\n\n[reference](https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside)\n\n# Command and Query Responsibility Segregation (CQRS) pattern\n\nThe Command and Query Responsibility Segregation (CQRS) pattern separates read and update operations for a data store. Implementing CQRS in your application can maximize its performance, scalability, and security. The flexibility created by migrating to CQRS allows a system to better evolve over time and prevents update commands from causing merge conflicts at the domain level.\n\n![](/assets/images/2021-05-09-22-51-59.png)\n\n- Commands should be task based, rather than data centric. (\"Book hotel room\", not \"set ReservationStatus to Reserved\").\n- Commands may be placed on a queue for asynchronous processing, rather than being processed synchronously.\n- Queries never modify the database. A query returns a DTO that does not encapsulate any domain knowledge.\n\n# Event Sourcing pattern\n\nInstead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data. The store acts as the system of record and can be used to materialize the domain objects. This can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness. It can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions.\n\nThe Event Sourcing pattern defines an approach to handling operations on data that's driven by a sequence of events, each of which is recorded in an append-only store. Application code sends a series of events that imperatively describe each action that has occurred on the data to the event store, where they're persisted. Each event represents a set of changes to the data \n\n![](/assets/images/2021-05-09-22-54-18.png)\n\n# Index Table \n\nCreate indexes over the fields in data stores that are frequently referenced by queries. This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.\n\nIf the data store doesn't support secondary indexes, you can emulate them manually by creating your own index tables. An index table organizes the data by a specified key. Three strategies are commonly used for structuring an index table, depending on the number of secondary indexes that are required and the nature of the queries that an application performs.\n\nThe first strategy is to duplicate the data in each index table but organize it by different keys (complete denormalization). The next figure shows index tables that organize the same customer information by Town and LastName.\n\n![](/assets/images/2021-05-09-22-58-10.png)\n\nThe second strategy is to create normalized index tables organized by different keys and reference the original data by using the primary key rather than duplicating it, as shown in the following figure. The original data is called a fact table.\n\n![](/assets/images/2021-05-09-22-58-20.png)\n\nThe third strategy is to create partially normalized index tables organized by different keys that duplicate frequently retrieved fields. Reference the fact table to access less frequently accessed fields. The next figure shows how commonly accessed data is duplicated in each index table.\n\n![](/assets/images/2021-05-09-22-58-32.png)\n\n# Materialized View pattern\n\nGenerate prepopulated views over the data in one or more data stores when the data isn't ideally formatted for required query operations. This can help support efficient querying and data extraction, and improve application performance.\n\n![](/assets/images/2021-05-09-22-59-51.png)\n\n- Creating materialized views over data that's difficult to query directly, or where queries must be very complex to extract data that's stored in a normalized, semi-structured, or unstructured way.\n- Creating temporary views that can dramatically improve query performance, or can act directly as source views or data transfer objects for the UI, for reporting, or for display.\n- Supporting occasionally connected or disconnected scenarios where connection to the data store isn't always available. The view can be cached locally in this case.\n- Simplifying queries and exposing data for experimentation in a way that doesn't require knowledge of the source data format. For example, by joining different tables in one or more databases, or one or more domains in NoSQL stores, and then formatting the data to fit its eventual use.\n- Providing access to specific subsets of the source data that, for security or privacy reasons, shouldn't be generally accessible, open to modification, or fully exposed to users.\n- Bridging different data stores, to take advantage of their individual capabilities. For example, using a cloud store that's efficient for writing as the reference data store, and a relational database that offers good query and read performance to hold the materialized views.\n- When using microservices, you are recommended to keep them loosely coupled, including their data storage. Thefore, materialized views can help you consolidate data from your services. If materialized views are not appropiate in your microservices architecture or specific scenario, please consider having well-defined boundaries that align to domain driven design (DDD) and aggregate their data when requested.\n\n# Sharding pattern\n\nDivide a data store into a set of horizontal partitions or shards. This can improve scalability when storing and accessing large volumes of data.\n\n## Sharding strategies\n\nThe Lookup strategy. In this strategy the sharding logic implements a map that routes a request for data to the shard that contains that data using the shard key. \n\n![](/assets/images/2021-05-09-23-07-49.png)\n\nThe Range strategy.\n\nThis strategy groups related items together in the same shard, and orders them by shard key—the shard keys are sequential. It's useful for applications that frequently retrieve sets of items using range queries\n\n![](/assets/images/2021-05-09-23-08-04.png)\n\nThe Hash strategy. The purpose of this strategy is to reduce the chance of hotspots \n\n![](/assets/images/2021-05-09-23-11-52.png)\n\n# Static Content Hosting patter\n\nDeploy static content to a cloud-based storage service that can deliver them directly to the client. This can reduce the need for potentially expensive compute instances.\n\n# Valet Key pattern\n\nUse a token that provides clients with restricted direct access to a specific resource, in order to offload data transfer from the application. This is particularly useful in applications that use cloud-hosted storage systems or queues, and can minimize cost and maximize scalability and performance.\n\nYou need to resolve the problem of controlling access to a data store where the store can't manage authentication and authorization of clients. One typical solution is to restrict access to the data store’s public connection and provide the client with a key or token that the data store can validate.\n\nThe client uses this token to access a specific resource in the data store for only a specific period, and with specific restrictions on access permissions, as shown in the figure. After the specified period, the key becomes invalid and won't allow access to the resource.\n\n![](/assets/images/2021-05-09-23-13-56.png)\n","n":0.029}}},{"i":371,"$":{"0":{"v":"Automation","n":1}}},{"i":372,"$":{"0":{"v":"Web","n":1},"1":{"v":"\n# IFTTT\n\n\n# inoreader\n\n\n# 简阅\n\n\n# pocket\n\n# slack\n\n# telegram\n\n","n":0.378}}},{"i":373,"$":{"0":{"v":"Vscode","n":1},"1":{"v":"\n# vscode\n\n## debug\n\n1. create `launch.json`\n2. add configuration by click button\n3. add field can do more custimzation\n\n\n## keyboard shortcuts\n\n1. view -> command pattern\n2. can see the key shortcut\n3. file -> preference -> key shortcut to change \n4. command K command S show all keyshort\n5. open preference keyboard shortcut json to have personalize key binding\n\n\n## setting\n\n1. can use json to custimize setting\n2. can set language based setting\n\n\n## open a file\n\n1. `:` go to a line\n2. `@` go to a symbol\n3. `?` view command suggestion\n4. `#` go to symbol in workplace\n\n## editing\n\n1. Format On Type and Format On Paste\n2. change lauguage command K M\n3. zen mode `command K Z`\n4. new pannel `command \\`\n5. change pannel `command 1 2 3`\n6. change all occurance `ctrl shift L`\n7. `alt + click` to change select place\n8. `alt + command + 上` copy line\n9. `alt 上下` move line\n10. `ctrl comand shift 左右` group selection\n11. `F12` go to definition, `shift F12` go to reference\n\n## snippets\n\nCode > Preferences > User Snippets on macOS\n\n- [link](https://code.visualstudio.com/docs/editor/userdefinedsnippets)\n\n\n## command\n\n- `code --diff <file1> <file2>`\n- `code -n` new window\n\n\n## window\n\n- Errors and warnings ⇧⌘M\n- F8 go to the error and warning\n- navigation history window `ctrl tab`\n- navigate back `ctrl -` \n\n# tasks\n\n- write build / run task \n- command + shift + B run task\n- can config user tasks\n- can config tasks depend on other tasks","n":0.067}}},{"i":374,"$":{"0":{"v":"Syncthing","n":1},"1":{"v":"\n# Syncthing\n\n## install on linux\n\n```bash\ncurl -s https://syncthing.net/release-key.txt | gpg --dearmor | sudo tee /usr/share/keyrings/syncthing-archive-keyring.gpg >/dev/null\necho \"deb [signed-by=/usr/share/keyrings/syncthing-archive-keyring.gpg] https://apt.syncthing.net/ syncthing stable\" | sudo tee /etc/apt/sources.list.d/syncthing.list\nsudo apt-get update\nsudo apt-get install syncthing\n```\n\n## start syncthing\n\n```bash\nsyncthing\n```\n\n## open port 8384\n\nin webui or `sudo ufw allow 8384/tcp`\n\n## add syncthing to autostart\n\n```bash\nsudo systemctl enable syncthing@$USER.service\n```\n\n## allow device\n\nin webui\n","n":0.141}}},{"i":375,"$":{"0":{"v":"iPhone","n":1},"1":{"v":"\n# 捷径的使用\n\n# IFTTT\n","n":0.577}}},{"i":376,"$":{"0":{"v":"Home","n":1},"1":{"v":"\n# 树莓派\n","n":0.707}}},{"i":377,"$":{"0":{"v":"Computer","n":1},"1":{"v":"\n# automator\n\n\n# alfred\n\n# script\n\n","n":0.5}}},{"i":378,"$":{"0":{"v":"Algo","n":1},"1":{"v":"\n# 算法\n\n## 数据结构\n\n- [[数组|development.algo.array]]\n- [[哈希表|development.algo.hashmap]]\n- [[链表|development.algo.linkedlist]]\n- [[树|development.algo.tree]]\n- [[堆|development.algo.heap]]\n- [[队列|development.algo.queue]]\n- [[栈|development.algo.stack]]\n- [[图|development.algo.graph]]\n\n## 算法\n\n- [[排序|development.algo.sort]]\n- [[搜索|development.algo.search]]\n- [[动态规划|development.algo.dp]]\n- [[贪心|development.algo.greedy]]\n- [[递归|development.algo.recursive]]\n- [[哈希|development.algo.hashing]]\n- [[图搜索|development.algo.graphsearch]]\n\n1. 减治法:它利用了一个问题给定实例的解和同样问题较小实例的解之间的关系。一旦建立了这样一种关系，我们既可以自顶至下（递归）也可以自底至上地运用这种关系。\n2. 分治法：将一个问题划分为同一类型的若干子问题，子问题最好规模相同。对这些子问题求解。有必要的、合并这些子问题的解，以得到原始问题的答案。 T(n) = aT(n/b)+f(n)\n3. 变治法：变换为同样问题的一个更简单或者更方便的实例一我们称之为实例化简。变换为同样实例的不同表现——我们称之为改变表现（representation change）。变换为另一个问题的实例，这种问题的算法是已知的一—我们称之为问题化简\n4. 时空权衡。输入增强：将问题进行预处理，预构造：使用额外的空间实现更快和更方便的数据存取\n5. 动态规划\n6. 贪婪算法","n":0.186}}},{"i":379,"$":{"0":{"v":"Tree","n":1},"1":{"v":"\n# basic\n\n* Root: The node at the top of the tree.\n* Parent: When any node (except the root) has exactly one edge running upward to another node. The node above is called parent of the node.\n* Child: Any node may have one or more lines running downward to other nodes. These nodes below the given node called its children.\n* Leaf: A node that has no children is called a leaf. There can be only one root in a tree but there can be many leaves.\n* Level (Height): the level of a particular node refers to how many generations the node is from the root. The root is at level 0 and its children are at level 1 and so on.\n\n## 思想\n\n重点就是把握树的递归特性。题目要想办法改变成对于左右子树的子问题。binary tree: node with left and right child\n\n- 深度问题:\b 整棵树的深度可以看成右子树的深度与左子树的深度的最大值\n- 长度问题：左右子树最大值加上中心节点\n- 颠倒：左子树和右子树分别交换自己，最后根节点交换左右子树\n- merge:类似链表merge\n- 判断是否相同。左右子树分别判断\n- BST valid: 设定左右子树的上下限\n- 可以利用binary search 分解题目\n\n\n## 遍历\n\nAlgorithm Inorder(tree)\n\n   1. Traverse the left subtree, i.e., call Inorder(left-subtree)\n   2. Visit the root.\n   3. Traverse the right subtree, i.e., call Inorder(right-subtree)\n\nAlgorithm Preorder(tree)\n   1. Visit the root.\n   2. Traverse the left subtree, i.e., call Preorder(left-subtree)\n   3. Traverse the right subtree, i.e., call Preorder(right-subtree) \n\nAlgorithm Postorder(tree)\n   1. Traverse the left subtree, i.e., call Postorder(left-subtree)\n   2. Traverse the right subtree, i.e., call Postorder(right-subtree)\n   3. Visit the root.","n":0.07}}},{"i":380,"$":{"0":{"v":"Stack","n":1},"1":{"v":"\n# basic\n\n- 大小是固定的\n- last in first out (LIFO)\n- 可以用数组实现\n\n## 时间复杂度\n\n- O(1) insert and delete\n- O(n) search\n\n## 算法\n\n- 可以用来reverse string","n":0.229}}},{"i":381,"$":{"0":{"v":"Sort","n":1},"1":{"v":"\n# merge sort\n\n```python\ndef mergeSort(arr):\n    if len(arr) > 1:\n \n         # Finding the mid of the array\n        mid = len(arr)//2\n \n        # Dividing the array elements\n        L = arr[:mid]\n \n        # into 2 halves\n        R = arr[mid:]\n \n        # Sorting the first half\n        mergeSort(L)\n \n        # Sorting the second half\n        mergeSort(R)\n \n        i = j = k = 0\n \n        # Copy data to temp arrays L[] and R[]\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n \n        # Checking if any element was left\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n \n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n```\n\n# quick sort\n\n```python\ndef partition(arr, low, high): \n    i = (low-1)         # index of smaller element \n    pivot = arr[high]     # pivot \n  \n    for j in range(low, high): \n  \n        # If current element is smaller than or \n        # equal to pivot \n        if arr[j] <= pivot: \n  \n            # increment index of smaller element \n            i = i+1\n            arr[i], arr[j] = arr[j], arr[i] \n  \n    arr[i+1], arr[high] = arr[high], arr[i+1] \n    return (i+1) \n  \n# The main function that implements QuickSort \n# arr[] --> Array to be sorted, \n# low  --> Starting index, \n# high  --> Ending index \n  \n# Function to do Quick sort \n  \n  \ndef quickSort(arr, low, high): \n    if len(arr) == 1: \n        return arr \n    if low < high: \n  \n        # pi is partitioning index, arr[p] is now \n        # at right place \n        pi = partition(arr, low, high) \n  \n        # Separately sort elements before \n        # partition and after partition \n        quickSort(arr, low, pi-1) \n        quickSort(arr, pi+1, high) \n```\n\n# heap sort\n\n![[dendron://my_note/development.algo.heap#heap sort]]\n\n# 拓扑排序\n\n有向图，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。\n\n- 选择一个入度为0的顶点并输出之；\n- 从图中删除此顶点及其所有出边；\n- 找下一个入度为0的点","n":0.057}}},{"i":382,"$":{"0":{"v":"Search","n":1},"1":{"v":"\n# binary search\n\n1. array 是sorted\n\n```java\n\npublic static int indexOf(int[] a, int key) {\n        int lo = 0;\n        int hi = a.length - 1;\n        while (lo <= hi) {\n            // Key is in a[lo..hi] or not present.\n            int mid = lo + (hi - lo) / 2;\n            if      (key < a[mid]) hi = mid - 1;\n            else if (key > a[mid]) lo = mid + 1;\n            else return mid;\n        }\n        return -1;\n```","n":0.12}}},{"i":383,"$":{"0":{"v":"Queue","n":1},"1":{"v":"\n# basic\n\n1. Every time add, Back index ++\n2. Every time remove item, Front index++ using an array to implement.\n3. Make sure you set index = back%cap\n4. FIFO","n":0.192}}},{"i":384,"$":{"0":{"v":"Linkedlist","n":1},"1":{"v":"\n# basic\n\n1. Advantages: dynamic access\n2. Disadvantages: **cannot random access and extra memory to save reference to next node**.\n3. 动态分配空间，只知道下个节点\n4. a sequence of node, each one contains object reference to next one\n\n## 时间复杂度\n\n- insert, delete O(1). \n- search O(n)\n\n## 思路\n\n- 递归[[development.algo.recursive]]\n- recursive one by one, each one could be the new linkedlist head: merge, reverse\n- two iterates:cycle, overlapping,delete node.\n- use dummy head to avoid checking empty: pivoting,using new node to form new list","n":0.118}}},{"i":385,"$":{"0":{"v":"Heap","n":1},"1":{"v":"\n# basic \n\n堆（英语：Heap）是计算机科学中的一种特别的完全二叉树。若是满足以下特性，即可称为堆：“给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）\n\n## heap sort\n\n```\nprocedure heapsort(a, count) is\n    input: an unordered array a of length count\n \n    (建立推，root是最大值)\n    heapify(a, count)\n\n    (a[0:end]是堆，end到最后是排列好的))\n    end ← count - 1\n    while end > 0 do\n        swap(a[end], a[0])\n        (heap大小减一)\n        end ← end - 1\n        (the swap ruined the heap property, so restore it)\n        siftDown(a, 0, end)\n```\n\n```python\n\ndef heapify(arr, n, i):\n    largest = i  # Initialize largest as root\n    l = 2 * i + 1     # left = 2*i + 1\n    r = 2 * i + 2     # right = 2*i + 2\n \n    # See if left child of root exists and is\n    # greater than root\n    if l < n and arr[largest] < arr[l]:\n        largest = l\n \n    # See if right child of root exists and is\n    # greater than root\n    if r < n and arr[largest] < arr[r]:\n        largest = r\n \n    # Change root, if needed\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n \n        # Heapify the root.\n        heapify(arr, n, largest)\n \n# The main function to sort an array of given size\n \n \ndef heapSort(arr):\n    n = len(arr)\n \n    # Build a maxheap.\n    for i in range(n//2 - 1, -1, -1):\n        heapify(arr, n, i)\n \n    # One by one extract elements\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # swap\n        heapify(arr, i, 0)\n \n```\n\n- api: heapq.heapify(x)\n- heapq.heappop(heap)","n":0.066}}},{"i":386,"$":{"0":{"v":"Hashmap","n":1},"1":{"v":"\n# basic\n\n- put value in hash slot like array\n- store keys and values, insert, delete,lookup O(1) time on average\n- key not in order\n- hash method needs to be good","n":0.186}}},{"i":387,"$":{"0":{"v":"Hashing","n":1},"1":{"v":"\n# collision\n\n\n- Static Hashing Schemes \n - linear probe hashing: find next available\n  - good for insert but bad for delete and update\n  - if non-unique key\n   - Choice #1: Separate Linked List. key point to a table save all value\n   - Choice #2: Redundant Keys: Store duplicate keys entries together in the hash table.\n - ROBIN HOOD HASHING:\n  - Variant of linear probe hashing that **steals slots from \"rich\"** keys and give them to \"poor\" keys.\n  - Each key tracks the number of positions **difference** its **optimal** position in the table.\n  - no grantee better, avoid worst case\n - cuckoo hashing\n  - Use multiple hash tables with different hash functions.\n  - ping pong, 出现collision去另一个\n  - 如果两个都collision，选一个替换，把被替换的放在另一个table里\n  - If we find a cycle, then we can rebuild the entire hash tables with new hash functions.\n- Dynamic Hashing Schemes\n - chained hashing: use linkedlist\n  - grow infinitely because you just keep adding new buckets to the linked list.\n - extendible hashing\n  - split buckets \n  - local depth: 就是之前没分的长度\n - linear hashing\n  - Maintain a pointer that tracks the next bucket to split. \n  - When any bucket overflows, split the bucket at the pointer location.\n\n## python dict\n\n- 存hash|key|value，每次都是看hash和key是不是一样\n- [处理collusion](https://stackoverflow.com/questions/9010222/why-can-a-python-dict-have-multiple-keys-with-the-same-hash)\n  - 出现collision，看`j = ((5*j) + 1) mod 2**i` 下一个是不是空的，是的话就放进去","n":0.069}}},{"i":388,"$":{"0":{"v":"Graphsearch","n":1},"1":{"v":"\n\n# BFS\n\n```python\ndef BFS(self, s):\n \n    # Mark all the vertices as not visited\n    visited = [False] * (max(self.graph) + 1)\n\n    # Create a queue for BFS\n    queue = []\n\n    # Mark the source node as \n    # visited and enqueue it\n    queue.append(s)\n    visited[s] = True\n\n    while queue:\n\n        # Dequeue a vertex from \n        # queue and print it\n        s = queue.pop(0)\n        print (s, end = \" \")\n\n        # Get all adjacent vertices of the\n        # dequeued vertex s. If a adjacent\n        # has not been visited, then mark it\n        # visited and enqueue it\n        for i in self.graph[s]:\n            if visited[i] == False:\n                queue.append(i)\n                visited[i] = True\n \n\n```\n# DFS\n\n```python\ndef DFSUtil(self, v, visited):\n \n    # Mark the current node as visited\n    # and print it\n    visited.add(v)\n    print(v, end=' ')\n \n    # Recur for all the vertices\n    # adjacent to this vertex\n    for neighbour in self.graph[v]:\n        if neighbour not in visited:\n            self.DFSUtil(neighbour, visited)\n \n# The function to do DFS traversal. It uses\n# recursive DFSUtil()\ndef DFS(self, v):\n\n    # Create a set to store visited vertices\n    visited = set()\n\n    # Call the recursive helper function\n    # to print DFS traversal\n    self.DFSUtil(v, visited)\n\n```\n\n# 最短路径算法\n\n单点最短路径算法： bellman-ford 算法，基本思路就是每次更新从起点到v的距离，如果起点到u再到v的路程短，那么就更新。\n\n```\n for i from 1 to size(vertices)-1:\n       for each edge (u, v) with weight w in edges:\n           if distance[u] + w < distance[v]:\n               distance[v] := distance[u] + w\n```\n\nDijkstra’s 算法，这也是单点最短路径算法，基本思路是每次从q中取最小的节点，之后更新从该点到其他的点的距离。\n\n```\nfunction Dijkstra(G, w, s)\n    for each vertex v in V[G]        // 初始化\n           d[v] := infinity           // 將各點的已知最短距離先設成無窮大\n    d[s] := 0                        // 因为出发点到出发点间不需移动任何距离，所以可以直接将s到s的最小距离设为0\n     S := empty set\n     Q := set of all vertices\n     while Q is not an empty set      // Dijkstra演算法主體\n        u := Extract_Min(Q)\n        S.append(u)\n        for each edge outgoing from u as (u,v)\n            if d[v] > d[u] + w(u,v)  // 拓展边（u,v）。w(u,v)为从u到v的路径长度。\n                d[v] := d[u] + w(u,v)  // 更新路径长度到更小的那个和值。\n```\n\n# A*","n":0.059}}},{"i":389,"$":{"0":{"v":"Graph","n":1},"1":{"v":"\n# basic\n\n## bfs\n## dfs\n## min distance","n":0.408}}},{"i":390,"$":{"0":{"v":"Dp","n":1},"1":{"v":"\n# basic\n\n- the original problem can be solved relatively easy once solution to the sub problem are available\n- subproblems can be cached\n- when you have to make **choices** to arrive solution\n- counting and decision problem\n- build bottom up","n":0.162}}},{"i":391,"$":{"0":{"v":"Array","n":1},"1":{"v":"\n# Basic\n\n- 数据集比较小\n- 数据的大小可以预测\n- 数据是连续存储的，速度快\n\n## 时间复杂度\n\n1. Addition and search worst O(N)\n2. Removal also O(N)\n\n## static和dynamic 数组\n\n- static是系统preallocate好大小，不能改变\n- dynamic是系统分配好，之后会根据情况进行变化，java里的ArrayList是1.5*","n":0.236}}}]}
