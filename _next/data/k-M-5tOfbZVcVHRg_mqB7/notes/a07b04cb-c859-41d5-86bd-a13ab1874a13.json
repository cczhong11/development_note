{"pageProps":{"note":{"id":"a07b04cb-c859-41d5-86bd-a13ab1874a13","title":"Pattern","vault":{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},"type":"note","desc":"","links":[{"from":{"fname":"development.database.partition","id":"3e4896bc-c74a-42d0-94d9-3ab9e6fdacdd","vaultName":"my_note"},"type":"backlink","position":{"start":{"line":14,"column":1,"offset":1103},"end":{"line":14,"column":59,"offset":1161},"indent":[]},"value":"development.cloud.database.pattern"}],"anchors":{"cache-aside-pattern":{"type":"header","value":"cache-aside-pattern","line":8,"column":0},"command-and-query-responsibility-segregation-cqrs-pattern":{"type":"header","value":"command-and-query-responsibility-segregation-cqrs-pattern","line":23,"column":0},"event-sourcing-pattern":{"type":"header","value":"event-sourcing-pattern","line":33,"column":0},"index-table":{"type":"header","value":"index-table","line":41,"column":0},"materialized-view-pattern":{"type":"header","value":"materialized-view-pattern","line":59,"column":0},"sharding-pattern":{"type":"header","value":"sharding-pattern","line":73,"column":0},"sharding-strategies":{"type":"header","value":"sharding-strategies","line":77,"column":0},"static-content-hosting-patter":{"type":"header","value":"static-content-hosting-patter","line":93,"column":0},"valet-key-pattern":{"type":"header","value":"valet-key-pattern","line":97,"column":0}},"fname":"development.cloud.database.pattern","updated":1620627277095,"created":1620625741692,"parent":"256b6a95-a183-45ef-9fbd-546b30a092cf","children":[],"data":{},"custom":{},"contentHash":"7291d76381c9c908dad690591fb3a645"},"body":"<h1 id=\"pattern\">Pattern<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#pattern\"></a></h1>\n<h1 id=\"cache-aside-pattern\">cache-aside pattern<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#cache-aside-pattern\"></a></h1>\n<p>Load data on demand into a cache from a data store. This can improve performance and also helps to maintain consistency between data held in the cache and data in the underlying data store.</p>\n<p>Many commercial caching systems provide read-through and write-through/write-behind operations. In these systems, an application retrieves data by referencing the cache. If the data isn't in the cache, it's retrieved from the data store and added to the cache. Any modifications to data held in the cache are automatically written back to the data store as well.</p>\n<p>For caches that don't provide this functionality, it's the responsibility of the applications that use the cache to maintain the data.</p>\n<p>An application can emulate the functionality of read-through caching by implementing the cache-aside strategy. This strategy loads data into the cache on demand. The figure illustrates using the Cache-Aside pattern to store data in the cache.</p>\n<p><img src=\"/assets/images/2021-05-09-22-49-50.png\"></p>\n<p><a href=\"https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside\">reference</a></p>\n<h1 id=\"command-and-query-responsibility-segregation-cqrs-pattern\">Command and Query Responsibility Segregation (CQRS) pattern<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#command-and-query-responsibility-segregation-cqrs-pattern\"></a></h1>\n<p>The Command and Query Responsibility Segregation (CQRS) pattern separates read and update operations for a data store. Implementing CQRS in your application can maximize its performance, scalability, and security. The flexibility created by migrating to CQRS allows a system to better evolve over time and prevents update commands from causing merge conflicts at the domain level.</p>\n<p><img src=\"/assets/images/2021-05-09-22-51-59.png\"></p>\n<ul>\n<li>Commands should be task based, rather than data centric. (\"Book hotel room\", not \"set ReservationStatus to Reserved\").</li>\n<li>Commands may be placed on a queue for asynchronous processing, rather than being processed synchronously.</li>\n<li>Queries never modify the database. A query returns a DTO that does not encapsulate any domain knowledge.</li>\n</ul>\n<h1 id=\"event-sourcing-pattern\">Event Sourcing pattern<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#event-sourcing-pattern\"></a></h1>\n<p>Instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data. The store acts as the system of record and can be used to materialize the domain objects. This can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness. It can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions.</p>\n<p>The Event Sourcing pattern defines an approach to handling operations on data that's driven by a sequence of events, each of which is recorded in an append-only store. Application code sends a series of events that imperatively describe each action that has occurred on the data to the event store, where they're persisted. Each event represents a set of changes to the data </p>\n<p><img src=\"/assets/images/2021-05-09-22-54-18.png\"></p>\n<h1 id=\"index-table\">Index Table<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#index-table\"></a></h1>\n<p>Create indexes over the fields in data stores that are frequently referenced by queries. This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.</p>\n<p>If the data store doesn't support secondary indexes, you can emulate them manually by creating your own index tables. An index table organizes the data by a specified key. Three strategies are commonly used for structuring an index table, depending on the number of secondary indexes that are required and the nature of the queries that an application performs.</p>\n<p>The first strategy is to duplicate the data in each index table but organize it by different keys (complete denormalization). The next figure shows index tables that organize the same customer information by Town and LastName.</p>\n<p><img src=\"/assets/images/2021-05-09-22-58-10.png\"></p>\n<p>The second strategy is to create normalized index tables organized by different keys and reference the original data by using the primary key rather than duplicating it, as shown in the following figure. The original data is called a fact table.</p>\n<p><img src=\"/assets/images/2021-05-09-22-58-20.png\"></p>\n<p>The third strategy is to create partially normalized index tables organized by different keys that duplicate frequently retrieved fields. Reference the fact table to access less frequently accessed fields. The next figure shows how commonly accessed data is duplicated in each index table.</p>\n<p><img src=\"/assets/images/2021-05-09-22-58-32.png\"></p>\n<h1 id=\"materialized-view-pattern\">Materialized View pattern<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#materialized-view-pattern\"></a></h1>\n<p>Generate prepopulated views over the data in one or more data stores when the data isn't ideally formatted for required query operations. This can help support efficient querying and data extraction, and improve application performance.</p>\n<p><img src=\"/assets/images/2021-05-09-22-59-51.png\"></p>\n<ul>\n<li>Creating materialized views over data that's difficult to query directly, or where queries must be very complex to extract data that's stored in a normalized, semi-structured, or unstructured way.</li>\n<li>Creating temporary views that can dramatically improve query performance, or can act directly as source views or data transfer objects for the UI, for reporting, or for display.</li>\n<li>Supporting occasionally connected or disconnected scenarios where connection to the data store isn't always available. The view can be cached locally in this case.</li>\n<li>Simplifying queries and exposing data for experimentation in a way that doesn't require knowledge of the source data format. For example, by joining different tables in one or more databases, or one or more domains in NoSQL stores, and then formatting the data to fit its eventual use.</li>\n<li>Providing access to specific subsets of the source data that, for security or privacy reasons, shouldn't be generally accessible, open to modification, or fully exposed to users.</li>\n<li>Bridging different data stores, to take advantage of their individual capabilities. For example, using a cloud store that's efficient for writing as the reference data store, and a relational database that offers good query and read performance to hold the materialized views.</li>\n<li>When using microservices, you are recommended to keep them loosely coupled, including their data storage. Thefore, materialized views can help you consolidate data from your services. If materialized views are not appropiate in your microservices architecture or specific scenario, please consider having well-defined boundaries that align to domain driven design (DDD) and aggregate their data when requested.</li>\n</ul>\n<h1 id=\"sharding-pattern\">Sharding pattern<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#sharding-pattern\"></a></h1>\n<p>Divide a data store into a set of horizontal partitions or shards. This can improve scalability when storing and accessing large volumes of data.</p>\n<h2 id=\"sharding-strategies\">Sharding strategies<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#sharding-strategies\"></a></h2>\n<p>The Lookup strategy. In this strategy the sharding logic implements a map that routes a request for data to the shard that contains that data using the shard key. </p>\n<p><img src=\"/assets/images/2021-05-09-23-07-49.png\"></p>\n<p>The Range strategy.</p>\n<p>This strategy groups related items together in the same shard, and orders them by shard key—the shard keys are sequential. It's useful for applications that frequently retrieve sets of items using range queries</p>\n<p><img src=\"/assets/images/2021-05-09-23-08-04.png\"></p>\n<p>The Hash strategy. The purpose of this strategy is to reduce the chance of hotspots </p>\n<p><img src=\"/assets/images/2021-05-09-23-11-52.png\"></p>\n<h1 id=\"static-content-hosting-patter\">Static Content Hosting patter<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#static-content-hosting-patter\"></a></h1>\n<p>Deploy static content to a cloud-based storage service that can deliver them directly to the client. This can reduce the need for potentially expensive compute instances.</p>\n<h1 id=\"valet-key-pattern\">Valet Key pattern<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#valet-key-pattern\"></a></h1>\n<p>Use a token that provides clients with restricted direct access to a specific resource, in order to offload data transfer from the application. This is particularly useful in applications that use cloud-hosted storage systems or queues, and can minimize cost and maximize scalability and performance.</p>\n<p>You need to resolve the problem of controlling access to a data store where the store can't manage authentication and authorization of clients. One typical solution is to restrict access to the data store’s public connection and provide the client with a key or token that the data store can validate.</p>\n<p>The client uses this token to access a specific resource in the data store for only a specific period, and with specific restrictions on access permissions, as shown in the figure. After the specified period, the key becomes invalid and won't allow access to the resource.</p>\n<p><img src=\"/assets/images/2021-05-09-23-13-56.png\"></p>\n<hr>\n<strong>Backlinks</strong>\n<ul>\n<li><a href=\"/notes/3e4896bc-c74a-42d0-94d9-3ab9e6fdacdd\">Partition (my_note)</a></li>\n</ul>","noteIndex":{"id":"0f1b48c7-3a25-4016-83a5-15864d7803ad","title":"Development","vault":{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},"type":"note","desc":"","links":[{"from":{"fname":"root","id":"c95dc4f5-23db-45e7-a15b-64582a183ccc","vaultName":"my_note"},"type":"backlink","position":{"start":{"line":8,"column":3,"offset":63},"end":{"line":8,"column":21,"offset":81},"indent":[]},"value":"development"}],"anchors":{},"fname":"development","updated":1618381238346,"created":1612940782409,"parent":null,"children":["400115e9-30f7-4a13-9776-db059bc9cd42","xsX5v3ZsyJ0i6gf9","1bc3b45a-b6f4-4150-87d3-5bd5b6eb8c24","6cea4852-6e7c-4140-b476-85c07b48a642","a40ef849-d301-4d74-a778-e6d9469dfb5d","09d9081f-3dff-453d-8488-7d2344cc8895","p11phg7nb10yw0wck1fyagq","92917ea3-452e-48dc-875e-5cd0002041db","2e151826-cb22-4d89-8ce0-71dad7204ce8","baa39444-0da9-4c55-8df7-2a6f8f787fa4","q4um3bc3st86ilkkvdjom6x","62daf50d-a39e-463f-aabd-be53790281fd","3524d0a7-be73-45d6-847e-c970f5c1c760","eac0f243-05b3-4b95-bec3-848e33edbc40","ubbcds8vm331to6kyei2kwk"],"data":{},"custom":{"nav_order":0,"permalink":"/"},"body":"\n","contentHash":"38357962f5a50c6fd7d318dfa66bea90"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"previewV2Enabled":false,"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"randomNote":{},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"dendronVersion":"0.90.0","vaults":[{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableUserTags":true,"enableHashTags":true,"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"enableEditorDecorations":true,"enableHandlebarTemplates":true,"enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["development","life"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"my_note","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","enableMermaid":true,"siteUrl":"https://notes.tczhong.com","siteFaviconPath":"favicon.ico","siteIndex":"development"}}},"__N_SSG":true}