{"pageProps":{"note":{"id":"afdca563-1075-4f32-8569-76abb00d833d","title":"Pattern","vault":{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},"type":"note","desc":"","links":[],"anchors":{"asynchronous-request-reply":{"type":"header","value":"asynchronous-request-reply","line":8,"column":0},"claim-check":{"type":"header","value":"claim-check","line":27,"column":0},"choreography":{"type":"header","value":"choreography","line":35,"column":0},"competing-consumers":{"type":"header","value":"competing-consumers","line":44,"column":0},"priority-queue":{"type":"header","value":"priority-queue","line":65,"column":0},"publisher-subscriber":{"type":"header","value":"publisher-subscriber","line":74,"column":0},"queue-based-load-leveling":{"type":"header","value":"queue-based-load-leveling","line":80,"column":0},"scheduler-agent-supervisor":{"type":"header","value":"scheduler-agent-supervisor","line":86,"column":0},"sequential-convoy":{"type":"header","value":"sequential-convoy","line":100,"column":0}},"fname":"development.cloud.messaging.pattern","updated":1620711827891,"created":1620710001469,"parent":"7f67fdcf-10d9-43e4-841c-a129a21aa69f","children":[],"data":{},"custom":{},"contentHash":"9e44d022bcbee3f81370fa3bb3e2b652"},"body":"<h1 id=\"pattern\">Pattern<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#pattern\"></a></h1>\n<h1 id=\"asynchronous-request-reply\">Asynchronous Request-Reply<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#asynchronous-request-reply\"></a></h1>\n<p>Decouple backend processing from a frontend host, where backend processing needs to be asynchronous, but the frontend still needs a clear response.</p>\n<p>One solution to this problem is to use HTTP polling. Polling is useful to client-side code, as it can be hard to provide call-back endpoints or use long running connections. Even when callbacks are possible, the extra libraries and services that are required can sometimes add too much extra complexity.</p>\n<ul>\n<li>The client application makes a synchronous call to the API, triggering a long-running operation on the backend.</li>\n<li>The API responds synchronously as quickly as possible. It returns an HTTP 202 (Accepted) status code, acknowledging that the request has been received for processing.</li>\n<li>The response holds a location reference pointing to an endpoint that the client can poll to check for the result of the long running operation.</li>\n<li>The API offloads processing to another component, such as a message queue.</li>\n<li>While the work is still pending, the status endpoint returns HTTP 202.</li>\n</ul>\n<p><img src=\"/assets/images/2021-05-10-22-21-30.png\"></p>\n<ul>\n<li>At some point, the work is complete and the status endpoint returns 302 (Found) redirecting to the resource.</li>\n<li>The client fetches the resource at the specified URL.</li>\n</ul>\n<p><img src=\"/assets/images/2021-05-10-22-21-54.png\"></p>\n<h1 id=\"claim-check\">Claim Check<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#claim-check\"></a></h1>\n<p>Split a large message into a claim check and a payload. Send the claim check to the messaging platform and store the payload to an external service. This pattern allows large messages to be processed, while protecting the message bus and the client from being overwhelmed or slowed down. This pattern also helps to reduce costs, as storage is usually cheaper than resource units used by the messaging platform.</p>\n<p><img src=\"/assets/images/2021-05-10-22-26-15.png\"></p>\n<p>Store the entire message payload into an external service, such as a database. Get the reference to the stored payload, and send just that reference to the message bus. The reference acts like a claim check used to retrieve a piece of luggage, hence the name of the pattern. Clients interested in processing that specific message can use the obtained reference to retrieve the payload, if needed.</p>\n<h1 id=\"choreography\">Choreography<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#choreography\"></a></h1>\n<p>Have each component of the system participate in the decision-making process about the workflow of a business transaction, instead of relying on a central point of control.</p>\n<p><img src=\"/assets/images/2021-05-10-22-27-37.png\"></p>\n<p>A client request publishes messages to a message queue. As messages arrive, they are pushed to subscribers, or services, interested in that message. Each subscribed service does their operation as indicated by the message and responds to the message queue with success or failure of the operation. In case of success, the service can push a message back to the same queue or a different message queue so that another service can continue the workflow if needed. If an operation fails, the message bus can retry that operation.</p>\n<h1 id=\"competing-consumers\">Competing Consumers<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#competing-consumers\"></a></h1>\n<p>Enable multiple concurrent consumers to process messages received on the same messaging channel. This enables a system to process multiple messages concurrently to optimize throughput, to improve scalability and availability, and to balance the workload.</p>\n<p><img src=\"/assets/images/2021-05-10-22-30-54.png\"></p>\n<p>The application posts requests in the form of messages to the queue, and the consumer service instances receive messages from the queue and process them. This approach enables the same pool of consumer service instances to handle messages from any instance of the application.</p>\n<p>This solution has the following benefits:</p>\n<p>It provides a load-leveled system that can handle wide variations in the volume of requests sent by application instances. The queue acts as a buffer between the application instances and the consumer service instances. This can help to minimize the impact on availability and responsiveness for both the application and the service instances, as described by the Queue-based Load Leveling pattern. Handling a message that requires some long-running processing doesn't prevent other messages from being handled concurrently by other instances of the consumer service.</p>\n<p>It improves reliability. If a producer communicates directly with a consumer instead of using this pattern, but doesn't monitor the consumer, there's a high probability that messages could be lost or fail to be processed if the consumer fails. In this pattern, messages aren't sent to a specific service instance. A failed service instance won't block a producer, and messages can be processed by any working service instance.</p>\n<p>It doesn't require complex coordination between the consumers, or between the producer and the consumer instances. The message queue ensures that each message is delivered at least once.</p>\n<p>It's scalable. The system can dynamically increase or decrease the number of instances of the consumer service as the volume of messages fluctuates.</p>\n<p>It can improve resiliency if the message queue provides transactional read operations. If a consumer service instance reads and processes the message as part of a transactional operation, and the consumer service instance fails, this pattern can ensure that the message will be returned to the queue to be picked up and handled by another instance of the consumer service.</p>\n<h1 id=\"priority-queue\">Priority Queue<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#priority-queue\"></a></h1>\n<p>Prioritize requests sent to services so that requests with a higher priority are received and processed more quickly than those with a lower priority. This pattern is useful in applications that offer different service level guarantees to individual clients.</p>\n<p><img src=\"/assets/images/2021-05-10-22-33-12.png\"></p>\n<p>A queue is usually a first-in, first-out (FIFO) structure, and consumers typically receive messages in the same order that they were posted to the queue. However, some message queues support priority messaging. The application posting a message can assign a priority and the messages in the queue are automatically reordered so that those with a higher priority will be received before those with a lower priority</p>\n<h1 id=\"publisher-subscriber\">Publisher-Subscriber<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#publisher-subscriber\"></a></h1>\n<p>Enable an application to announce events to multiple interested consumers asynchronously, without coupling the senders to the receivers.</p>\n<p><img src=\"/assets/images/2021-05-10-22-34-05.png\"></p>\n<h1 id=\"queue-based-load-leveling\">Queue-Based Load Leveling<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#queue-based-load-leveling\"></a></h1>\n<p>Use a queue that acts as a buffer between a task and a service it invokes in order to smooth intermittent heavy loads that can cause the service to fail or the task to time out. This can help to minimize the impact of peaks in demand on availability and responsiveness for both the task and the service.</p>\n<p><img src=\"/assets/images/2021-05-10-22-35-25.png\"></p>\n<h1 id=\"scheduler-agent-supervisor\">Scheduler Agent Supervisor<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#scheduler-agent-supervisor\"></a></h1>\n<p>Coordinate a set of distributed actions as a single operation. If any of the actions fail, try to handle the failures transparently, or else undo the work that was performed, so the entire operation succeeds or fails as a whole. This can add resiliency to a distributed system, by enabling it to recover and retry actions that fail due to transient exceptions, long-lasting faults, and process failures.</p>\n<p><img src=\"/assets/images/2021-05-10-22-36-25.png\"></p>\n<ul>\n<li>The Scheduler arranges for the steps that make up the task to be executed and orchestrates their operation. </li>\n<li>The Agent contains logic that encapsulates a call to a remote service, or access to a remote resource referenced by a step in a task. </li>\n<li>The Supervisor monitors the status of the steps in the task being performed by the Scheduler. It runs periodically (the frequency will be system-specific), and examines the status of steps maintained by the Scheduler. If it detects any that have timed out or failed, it arranges for the appropriate Agent to recover the step or execute the appropriate remedial action</li>\n</ul>\n<p><img src=\"/assets/images/2021-05-10-22-37-41.png\"></p>\n<h1 id=\"sequential-convoy\">Sequential Convoy<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#sequential-convoy\"></a></h1>\n<p>Process a set of related messages in a defined order, without blocking processing of other groups of messages.</p>\n<p>Push related messages into categories within the queuing system, and have the queue listeners lock and pull only from one category, one message at a time.</p>\n<p><img src=\"/assets/images/2021-05-10-22-38-54.png\"></p>\n<p>In the queue, messages for different categories may be interleaved, as shown in the following diagram:</p>\n<p><img src=\"/assets/images/2021-05-10-22-39-00.png\"></p>","noteIndex":{"id":"0f1b48c7-3a25-4016-83a5-15864d7803ad","title":"Development","vault":{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},"type":"note","desc":"","links":[{"from":{"fname":"root","id":"c95dc4f5-23db-45e7-a15b-64582a183ccc","vaultName":"my_note"},"type":"backlink","position":{"start":{"line":8,"column":3,"offset":63},"end":{"line":8,"column":21,"offset":81},"indent":[]},"value":"development"}],"anchors":{},"fname":"development","updated":1618381238346,"created":1612940782409,"parent":null,"children":["400115e9-30f7-4a13-9776-db059bc9cd42","xsX5v3ZsyJ0i6gf9","1bc3b45a-b6f4-4150-87d3-5bd5b6eb8c24","6cea4852-6e7c-4140-b476-85c07b48a642","a40ef849-d301-4d74-a778-e6d9469dfb5d","09d9081f-3dff-453d-8488-7d2344cc8895","p11phg7nb10yw0wck1fyagq","92917ea3-452e-48dc-875e-5cd0002041db","2e151826-cb22-4d89-8ce0-71dad7204ce8","baa39444-0da9-4c55-8df7-2a6f8f787fa4","q4um3bc3st86ilkkvdjom6x","62daf50d-a39e-463f-aabd-be53790281fd","3524d0a7-be73-45d6-847e-c970f5c1c760","eac0f243-05b3-4b95-bec3-848e33edbc40","nc777xa48letazo00100hin"],"data":{},"custom":{"nav_order":0,"permalink":"/"},"body":"\n","contentHash":"38357962f5a50c6fd7d318dfa66bea90"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"previewV2Enabled":false,"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"randomNote":{},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"dendronVersion":"0.90.0","vaults":[{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableUserTags":true,"enableHashTags":true,"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"enableEditorDecorations":true,"enableHandlebarTemplates":true,"enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["development","life"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"my_note","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","enableMermaid":true,"siteUrl":"https://notes.tczhong.com","siteFaviconPath":"favicon.ico","siteIndex":"development"}}},"__N_SSG":true}