{"pageProps":{"note":{"id":"29ec6e3f-8b45-44b1-95c0-69042790897a","title":"Tcp","vault":{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},"type":"note","desc":"","links":[{"type":"wiki","from":{"fname":"development.network.transportlayer.tcp","id":"29ec6e3f-8b45-44b1-95c0-69042790897a","vaultName":"my_note"},"value":"tags.s","alias":"#s","position":{"start":{"line":24,"column":66,"offset":1048},"end":{"line":24,"column":68,"offset":1050},"indent":[]},"xvault":false,"to":{"fname":"tags.s"}},{"type":"ref","from":{"fname":"development.network.transportlayer.tcp","id":"29ec6e3f-8b45-44b1-95c0-69042790897a","vaultName":"my_note"},"value":"development.network.reliable_data_transfer","position":{"start":{"line":63,"column":1,"offset":2593},"end":{"line":63,"column":48,"offset":2640},"indent":[]},"xvault":false,"to":{"fname":"development.network.reliable_data_transfer"}}],"anchors":{"tcp":{"type":"header","text":"TCP","value":"tcp","line":8,"column":0,"depth":1},"connection-and-tear-down":{"type":"header","text":"connection and tear down","value":"connection-and-tear-down","line":17,"column":0,"depth":2},"rdt":{"type":"header","text":"RDT","value":"rdt","line":36,"column":0,"depth":2},"flow-control":{"type":"header","text":"Flow control","value":"flow-control","line":70,"column":0,"depth":2}},"fname":"development.network.transportlayer.tcp","updated":1618462837069,"created":1617516756079,"parent":"ad8989e5-cb41-4b92-8d49-57a81d93d294","children":[],"data":{},"custom":{},"contentHash":"44f262223284c0808cd0c49914f88bb5"},"body":"<h1 id=\"tcp\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#tcp\"></a>Tcp</h1>\n<h1 id=\"tcp-1\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#tcp-1\"></a>TCP</h1>\n<ul>\n<li>point-to-point / reliable / in-order byte stream / pipelined: sliding windows</li>\n<li>full duplex data: bi-directional data flow</li>\n<li>connection-oriented: handshaking (exchange of control messages) initializes sender &#x26; receiver state before data exchange</li>\n<li>Both sides have buffers</li>\n<li>Flow Control</li>\n<li>Congestion Control</li>\n</ul>\n<h2 id=\"connection-and-tear-down\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#connection-and-tear-down\"></a>connection and tear down</h2>\n<ul>\n<li>establish: setup state before exchanging data segements\n<ul>\n<li>step1: send SYN segment and specifies initial seq#, no data</li>\n<li>why random sn? an earlier incarnation of the same connection can interfere with a later one</li>\n<li>step2: server respond with SYNACK segment, allocates buffers and specifies initial seq#</li>\n<li>step3: replies with ACK, may contain data</li>\n<li>if host receive with SYN to a closed port, responds with a RST segments </li>\n</ul>\n</li>\n<li>teardown: free up state \n<ul>\n<li>step1: send TCP FIN to server</li>\n<li>step2: server responds with ACK and closed, send FIN</li>\n<li>step3: client receives FIN, replies with ACK , wait </li>\n<li>why? possible ACK lost</li>\n<li>Client may open the same connection again (same pair of port <a title=\"Private\" href=\"https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html\" target=\"_blank\" class=\"private\">#s (Private)</a>) </li>\n<li>then Receives FIN from earlier incarnation of connection</li>\n<li>so Immediately initiate closing of the later incarnation</li>\n<li>Step 4: server receives ACK, closes connection</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"rdt\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#rdt\"></a>RDT</h2>\n<ul>\n<li>TCP creates RDT service on top of IP’s unreliable service\n<ul>\n<li>Pipelined segments </li>\n<li>Cumulative acks</li>\n<li>Retransmission timer</li>\n</ul>\n</li>\n<li>Retransmissions are triggered by:\n<ul>\n<li>timeout events </li>\n<li>duplicate acks</li>\n</ul>\n</li>\n<li>Initially, we consider simplified TCP sender:\n<ul>\n<li>ignore duplicate acks</li>\n<li>ignore flow control, congestion control</li>\n<li>assume RTT is estimated somehow</li>\n</ul>\n</li>\n<li>SN : byte stream “number” of first byte in segment’s data</li>\n<li>ACKs: seq # of next byte expected from other side\n<ul>\n<li><strong>cumulative</strong> ACK: acknowledges bytes up to the first missing byte in the stream</li>\n</ul>\n</li>\n<li>Data received from app:\n<ul>\n<li>Create segment</li>\n<li>seq# is byte-stream number of first data byte in segment</li>\n<li>Send, if allowed by congestion &#x26; flow-control</li>\n<li>start timer if not already running (think of timer as for oldest unacked segment)</li>\n<li>expiration interval: TimeOutInterva</li>\n</ul>\n</li>\n<li>Timeout:</li>\n<li>retransmit segment that caused timeout</li>\n<li>restart timer</li>\n<li>ACK received:\n<ul>\n<li>If acknowledges previously unACKed segments</li>\n<li>update what is known to be ACKed</li>\n<li>start timer if there are outstanding segments</li>\n</ul>\n</li>\n<li>fast retransmit\n<ul>\n<li>If segment is lost, there will likely be many duplicate ACKs</li>\n<li>If sender receives 3 duplicate ACKs, it supposes that segment after ACKed data was lost: resend segment before timer expires： voodoo constant</li>\n</ul>\n</li>\n</ul>\n<p></p><p></p><div class=\"portal-container\">\n<div class=\"portal-head\">\n<div class=\"portal-backlink\">\n<div class=\"portal-title\">From <span class=\"portal-text-title\">Reliable_data_transfer</span></div>\n<a href=\"/notes/c16ae2ab-1fc3-40f4-8053-a8397954d3bb\" class=\"portal-arrow\">Go to text <span class=\"right-arrow\">→</span></a>\n</div>\n</div>\n<div id=\"portal-parent-anchor\" class=\"portal-parent\" markdown=\"1\">\n<div class=\"portal-parent-fader-top\"></div>\n<div class=\"portal-parent-fader-bottom\"></div><h1 id=\"rdt-1\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#rdt-1\"></a>RDT</h1>\n<h2 id=\"possible-failure\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#possible-failure\"></a>possible failure</h2>\n<p>bit-errors, lossy, duplicate delivery , out-of-order delivery</p>\n<h2 id=\"methods\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#methods\"></a>methods</h2>\n<ul>\n<li>checksums: bit error </li>\n<li>receiver feedback: bit error, ACK/NACK， Cumulative acknowledgments(I have received all packets with sequence numbers up to but not including sn.) allow acknowledgment of numerous packets at a time. They can be useful in pipelined protocols. 可能lost</li>\n<li>retransmission : Sender sends another copy of segment, detect loss and allows for duplicate seg</li>\n<li>sequence numbers : Distinguish between old and new, Gaps let receiver detect lost segment, find duplicate packets，restoring the transmitted order. have to be a bounded # bits</li>\n<li>timer expiration: Segment or receiver feedback is lost (sender: Resends a packet after a timer fires. Sends a new packet after an acknowledgment (positive) arrives.)</li>\n<li>window:Control sending of multiple segments, allow for reuse of sequence numbers, also allow for pipeling segments</li>\n</ul>\n<h2 id=\"protocols\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#protocols\"></a>protocols</h2>\n<h3 id=\"stop-n-wait\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#stop-n-wait\"></a>Stop-n-Wait</h3>\n<ul>\n<li>Simplest Protocol that will handle bit errors and segment loss\n<ul>\n<li>use: checksum, ack, sn, timers</li>\n<li>1 bit for sequence number</li>\n<li><img src=\"/assets/images/2021-04-03-23-06-30.png\"></li>\n<li><img src=\"/assets/images/2021-04-03-23-07-36.png\"></li>\n<li>为了解决checksum返回的时候有问题。可能ack会lost。带来的问题就是可能重复发几次。所以需要seq num</li>\n<li><img src=\"/assets/images/2021-04-03-23-08-48.png\"></li>\n<li>计时发送，看指定时间能否达到response, 没seq num. 接收者不能知道是否是重发。LOST ACK和lost segment对于发送方式一样的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"go-back-n\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#go-back-n\"></a>Go Back N</h2>\n<ul>\n<li>sliding window: A mechanism to control multiple, in-flight segments without overwhelming receiver, Sender is allowed to transmit N segments without waiting for an ACK</li>\n<li>“window” of up to N, consecutive unACKed segments allowed</li>\n<li>Sets a <strong>timer</strong> for each in-flight segment</li>\n<li>timeout(n): retransmit segment n and all <strong>higher</strong> seq# segments in window</li>\n<li>sender:\n<ul>\n<li>Sender places a k-bit seq# in header</li>\n<li>“window” of up to N, consecutive unACKed segments allowed</li>\n<li>Sets a timer for each in-flight segment</li>\n<li>timeout(n): retransmit segment n and <strong>all higher</strong> seq# segments in window</li>\n<li>ACK(n): ACKs all segments up to, including seq# n (Cumulative ACK)</li>\n</ul>\n</li>\n<li>receiver: ACK-only: always send ACK for correctly-received segment with <strong>highest in-order seq</strong>, Receipt of out-of-order segment just discard and send with highest in-order seq \n<ul>\n<li>May generate duplicate ACKs</li>\n<li>Why discard segs received out-of-order： Don’t want to buffer them, going to be re-sent anyway</li>\n</ul>\n</li>\n<li>A single segment error can cause many segments to be retransmitted</li>\n</ul>\n<h2 id=\"selective-repeat\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#selective-repeat\"></a>Selective Repeat</h2>\n<ul>\n<li>Receiver individually ACKs all correctly received segments</li>\n<li>Buffers segs for eventual in-order delivery</li>\n<li>Sender only resends segments for which ACK not received</li>\n<li>Sets timer for each segment</li>\n<li>Sender window of N consecutive seq#s</li>\n<li>Limits seq # s of sent, but unACKed segs</li>\n<li><img src=\"/assets/images/2021-04-03-23-12-02.png\"></li>\n<li>issues: both side have varying view, receiver window移动了，但是发送端没收到ack， 会重传。</li>\n<li>sequence number的space至少是2^k 个，k是window的大小</li>\n</ul>\n</div></div><p></p><p></p>\n<h2 id=\"flow-control\"><a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#flow-control\"></a>Flow control</h2>\n<ul>\n<li>\n<p>mission: Sender won’t overflow the <strong>receiver’s buffer</strong> by transmitting too much, too fast</p>\n<ul>\n<li>matching the send rate to the receiving app’s drain rate</li>\n<li>operation:</li>\n</ul>\n</li>\n<li>\n<p>mechanism</p>\n<ul>\n<li>RcvWindow = RcvBuffer - [ LastByteRcvd - LastByteRead ] (assume discard out of order)</li>\n<li>Receiver advertises spare room by including value of RcvWindow in ACK segment</li>\n<li>Gives sender permission to send this much</li>\n</ul>\n</li>\n<li>\n<p>congwin: how much data allowed in-flight at any time, >= LastByteSent-LastByteAcked</p>\n<ul>\n<li><strong>rate = congwin/RTT</strong></li>\n</ul>\n</li>\n<li>\n<p>sender perceive congestion: timeout / 3 duplicate ACKs</p>\n</li>\n<li>\n<p>self-clocking nature: use ACK to trigger its increase in congestion window size</p>\n</li>\n<li>\n<p>interaction of various phases </p>\n<ul>\n<li>When CongWin is below Threshold, window grows exponentially (slow-start phase)</li>\n<li>When CongWin is above Threshold, window grows linearly (congestion-avoidance phase)</li>\n<li>When a triple duplicate ACK occurs, Threshold set to CongWin/2 and CongWin set to Threshold. Window grows linearly</li>\n<li>When timeout occurs, Threshold set to CongWin/2 and CongWin is set to 1 MSS. Enters slow-start phase</li>\n</ul>\n</li>\n<li>\n<p>slow start</p>\n<ul>\n<li>start with MSS = 1, increase exponentially, done by increasing CongWin by 1MSS for every ACK received</li>\n<li>With Slow Start, no bandwidth wasted on retransmission</li>\n<li>end: first lost event</li>\n</ul>\n</li>\n<li>\n<p>congestion avoidance</p>\n<ul>\n<li>start: first lost event\n<ul>\n<li>cut CongWin in half after a loss event</li>\n<li>Continue probing for usable bandwidth</li>\n</ul>\n</li>\n<li>Reno: after 3 dup, cancel slow start, cut half CongWin, grows linearly\n<ul>\n<li>after timeout, set ssthrehold to half, skip ss, fast recovery.</li>\n<li>fast retransmit:  after 3 dup</li>\n</ul>\n</li>\n<li>Tahoe: after loss event, congwin set to 1, enter slow start</li>\n</ul>\n</li>\n<li>\n<p>how TCP sets timeout values.</p>\n<ul>\n<li>longer than RTT. </li>\n<li>too short, premature timeout, unnecessary retransmissions</li>\n<li>too long, slow reaction to segment loss</li>\n<li>need to measure RTT for baseline</li>\n</ul>\n</li>\n</ul>","noteIndex":{"id":"0f1b48c7-3a25-4016-83a5-15864d7803ad","title":"Development","vault":{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},"type":"note","desc":"","links":[{"from":{"fname":"root","vaultName":"my_note"},"type":"backlink","position":{"start":{"line":8,"column":3,"offset":63},"end":{"line":8,"column":21,"offset":81},"indent":[]},"value":"development","alias":"开发"}],"anchors":{},"fname":"development","updated":1618381238346,"created":1612940782409,"parent":null,"children":["400115e9-30f7-4a13-9776-db059bc9cd42","xsX5v3ZsyJ0i6gf9","1bc3b45a-b6f4-4150-87d3-5bd5b6eb8c24","6cea4852-6e7c-4140-b476-85c07b48a642","a40ef849-d301-4d74-a778-e6d9469dfb5d","774ndd6du53l5k1awv074r0","09d9081f-3dff-453d-8488-7d2344cc8895","92917ea3-452e-48dc-875e-5cd0002041db","2e151826-cb22-4d89-8ce0-71dad7204ce8","baa39444-0da9-4c55-8df7-2a6f8f787fa4","62daf50d-a39e-463f-aabd-be53790281fd","3524d0a7-be73-45d6-847e-c970f5c1c760","eac0f243-05b3-4b95-bec3-848e33edbc40"],"data":{},"custom":{"nav_order":0,"permalink":"/"},"body":"\n","contentHash":"38357962f5a50c6fd7d318dfa66bea90"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"previewV2Enabled":false,"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"randomNote":{},"copyNoteLink":{},"templateHierarchy":"template"},"workspace":{"dendronVersion":"0.90.0","vaults":[{"fsPath":"repos/dendron-aws-vault","remote":{"type":"git","url":"https://github.com/cczhong11/my_note.git"},"name":"my_note"},{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableUserTags":true,"enableHashTags":true,"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"enableEditorDecorations":true,"enableHandlebarTemplates":true,"enableFullHierarchyNoteTitle":false,"enableSmartRefs":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["development","life"],"enableSiteLastModified":true,"siteRootDir":"docs","siteUrl":"https://notes.tczhong.com","enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"writeStubs":false,"seo":{"title":"my_note","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enablePrettyLinks":true,"enableTaskNotes":true,"siteFaviconPath":"favicon.ico","siteIndex":"development"}}},"__N_SSG":true}